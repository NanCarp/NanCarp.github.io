<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="李子园">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李子园">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李子园">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>李子园</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李子园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习、生活、感悟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/在 Node.js 中处理数据 IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/03/在 Node.js 中处理数据 IO/" itemprop="url">在 Node.js 中处理数据 I/O</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T20:31:00+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="5-1-处理-JSON"><a href="#5-1-处理-JSON" class="headerlink" title="5.1 处理 JSON"></a>5.1 处理 JSON</h2><h3 id="把-JSON-转换成-JavaScript-对象"><a href="#把-JSON-转换成-JavaScript-对象" class="headerlink" title="把 JSON 转换成 JavaScript 对象"></a>把 JSON 转换成 JavaScript 对象</h3><p>例如，下面的代码片段中，注意 accountStr 被定义为一个格式化的 JSON 字符串，然后使用 JSON.parse() 将其转换为<br>JavaScript 对象，之后其成员属性就可以通过点符号来访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var accountStr = &apos;&#123;&quot;name&quot;:&quot;Jedi&quot;, &quot;members&quot;:[&quot;Yoda&quot;,&quot;Obi Wan&quot;], \</div><div class="line">				   &quot;number&quot;:34512, &quot;location&quot;: &quot;A galaxy far, far away&quot;&#125;&apos;;</div><div class="line">var accountObj = JSON.parse(accountStr);</div><div class="line">console.log(accountObj.name);</div><div class="line">console.log(accountObj.members);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node other.js</div><div class="line">Jedi</div><div class="line">[ &apos;Yoda&apos;, &apos;Obi Wan&apos; ]</div></pre></td></tr></table></figure></p>
<h3 id="5-1-2-把-JavaScript-对象转化为-JSON-对象"><a href="#5-1-2-把-JavaScript-对象转化为-JSON-对象" class="headerlink" title="5.1.2 把 JavaScript 对象转化为 JSON 对象"></a>5.1.2 把 JavaScript 对象转化为 JSON 对象</h3><p>下面定义了一个包括字符串、数字和数组属性的 JavaScript 对象。JSON.stringify() 将其转换成 JSON 字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var accountObj = &#123;</div><div class="line">	name: &quot;Baggins&quot;,</div><div class="line">	number: 10645,</div><div class="line">	numbers: [&quot;Frodo, Bilbo&quot;],</div><div class="line">	location: &quot;Shire&quot;</div><div class="line">&#125;;</div><div class="line">var accountStr = JSON.stringify(accountObj);</div><div class="line">console.log(accountStr);</div></pre></td></tr></table></figure></p>
<p>输出：<br><code>{&quot;name&quot;:&quot;Baggins&quot;,&quot;number&quot;:10645,&quot;numbers&quot;:[&quot;Frodo, Bilbo&quot;],&quot;location&quot;:&quot;Shire&quot;}</code>  </p>
<h2 id="5-2-使用-Buffer-模块缓冲数据"><a href="#5-2-使用-Buffer-模块缓冲数据" class="headerlink" title="5.2 使用 Buffer 模块缓冲数据"></a>5.2 使用 Buffer 模块缓冲数据</h2><h3 id="5-2-2-创建缓冲区"><a href="#5-2-2-创建缓冲区" class="headerlink" title="5.2.2 创建缓冲区"></a>5.2.2 创建缓冲区</h3><p>Buffer 对象实际上是原始的内存分配区。因此，必须在创建时确定其大小。创建 3 种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Buffer(sizeInBytes)</div><div class="line">new Buffer(octetArray)</div><div class="line">new Buffer(string, [encodeing])</div></pre></td></tr></table></figure></p>
<p>例如，下面分别使用字节大小、一个八位字节的缓冲区，以及一个 UTF8 字符串来设定缓冲区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var buf256 = new Buffer(256);</div><div class="line">var bufOctets = new Buffer([0x6f, 0x63, 0x74, 0x65, 0x74, 0x73]);</div><div class="line">var bufUTF8 = new Buffer(&quot;Some UTF Text \uoob6 \u30c6 \u20ac&quot;, &apos;utf8&apos;);</div></pre></td></tr></table></figure></p>
<h3 id="5-2-3-写入缓冲区"><a href="#5-2-3-写入缓冲区" class="headerlink" title="5.2.3 写入缓冲区"></a>5.2.3 写入缓冲区</h3><p> 下面代码定义了一个缓冲区，以零填充。write() 方法在开头写一些文字，write(string, offset, length) 写额外的文本<br> 改变现有缓冲区的一部分。通过直接设置索引的值增加 + 到结束处。注意，buf256.write(“more text”, 9, 9) 语句写到<br> 缓冲区的中间，而 buf256[18] = 43 修改一个字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// buffer_write.js：用各种方式来写入 Buffer 对象</div><div class="line">buf256 = new Buffer(256);</div><div class="line">buf256.fill(0);</div><div class="line">buf256.write(&quot;add some text&quot;);</div><div class="line">console.log(buf256.toString());</div><div class="line">buf256.write(&quot;more text&quot;, 9, 9);</div><div class="line">console.log(buf256.toString());</div><div class="line">buf256[18] = 43;</div><div class="line">console.log(buf256.toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ node buffer_write.js</div><div class="line">add some text</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">add some more text</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">add some more text+</div></pre></td></tr></table></figure></p>
<h3 id="5-2-4-从缓冲区读取"><a href="#5-2-4-从缓冲区读取" class="headerlink" title="5.2.4 从缓冲区读取"></a>5.2.4 从缓冲区读取</h3><p>最简单使用 toString() 方法将缓冲区的全部或一部分转换为字符串。也可以直接在缓冲区访问特定的索引，或使用 read()。<br>此外，Node.js 提供 StringDecoder 对象，它有 write(buffer) 方法来进行解码，并使用指定的编码写入缓冲区数据。<br>一下代码定义了 UTF8 编码的字符缓冲区，然后使用不带参数的 toString() 读取所有的缓冲区，之后用 encoding、start<br>和 end 参数读取缓冲区的一部分。然后使用 UTF8 编码创建 StringDecoder，并用它来把缓冲区的内容输出到控制台，<br>接下来，直接访问方法获取在索引 18 处的八进制字节值，用 readUInt32BE() 读取一个 32 位整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// buffer_read.js： 从 Buffer 对象读取数据的各种方法</div><div class="line">bufUTF8 = new Buffer(&quot;Some UTF8 Text \u00b6 \u30c6 \u20ac&quot;, &apos;utf8&apos;);</div><div class="line">console.log(bufUTF8.toString());</div><div class="line">console.log(bufUTF8.toString(&apos;utf8&apos;, 5, 9));</div><div class="line">var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;</div><div class="line">var decoder = new StringDecoder(&apos;utf8&apos;);</div><div class="line">console.log(decoder.write(bufUTF8));</div><div class="line">console.log(bufUTF8[18].toString(16));</div><div class="line">console.log(bufUTF8.readUInt32BE(18).toString(16));</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node buffer_read.js</div><div class="line">Some UTF8 Text ¶ テ €</div><div class="line">UTF8</div><div class="line">Some UTF8 Text ¶ テ €</div><div class="line">e3</div><div class="line">e3838620</div></pre></td></tr></table></figure></p>
<h3 id="5-2-5-确定缓冲区长度"><a href="#5-2-5-确定缓冲区长度" class="headerlink" title="5.2.5 确定缓冲区长度"></a>5.2.5 确定缓冲区长度</h3><p>缓冲区处理的一项常见任务是确定其长度，尤其是当你从一个字符串动态创建一个缓冲区的时候。你可以通过在 Buffer 对象上<br>调用 .length 来确定缓冲区的长度。确定字符串将在缓冲区中占用的字节长度，不能使用 .length 属性，而是用<br>Buffer.byteLength(string, [encoding])。注意，缓冲区中字符串长度和字节长度直接的区别很重要，以下语句可以说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">“UTF8 text \u00b6&quot;.length;</div><div class="line">// 计算结果是 11</div><div class="line">BUffer.byteLength(&quot;UTF8 text \u00b6&quot;, &apos;utf8&apos;);</div><div class="line">// 计算结果是 12，因为它包含双字节字符</div><div class="line">Buffer(&quot;UTF8 text \u00b6&quot;).length;</div><div class="line">// 计算结果是 12，缓冲区上的 .length 返回的是字节长度</div></pre></td></tr></table></figure></p>
<h3 id="5-2-6-复制缓冲区"><a href="#5-2-6-复制缓冲区" class="headerlink" title="5.2.6 复制缓冲区"></a>5.2.6 复制缓冲区</h3><p>Node.js 为 Buffer 对象提供 copy(targetBuffer, [targetStart], [sourceStart], [sourceIndex]) 函数。<br>targetBuffer 参数是另一个 Buffer 对象， targetStart、sourceStart 和 sourceEnd 是源和目标缓冲区内的索引。  </p>
<blockquote>
<p><strong>注意</strong><br>若要从一个缓冲区复制字符串数据到另一个缓冲区，应确保两个缓冲区使用相同的编码；否则，对结果缓冲区解码时，<br>可能得到意想不到的结果。  </p>
</blockquote>
<p>也可以通过直接索引将一个缓冲区中的数据复制到另一个缓冲区，例如：<br><code>sourceBuffer[index] = destinationBuffer[index]</code>  </p>
<p>下面代码说明了将一个缓冲区的数据复制到另一个缓冲区的 3 个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var alphabet = new Buffer(&apos;abcdefghijklmnopqrstuvwxyz&apos;);</div><div class="line">console.log(alphabet.toString());</div><div class="line">// copy full buffer </div><div class="line">var blank = new Buffer(26);</div><div class="line">blank.fill();</div><div class="line">console.log(&quot;Blank: &quot; + blank.toString());</div><div class="line">alphabet.copy(blank);</div><div class="line">console.log(&quot;Blank: &quot; + blank.toString());</div><div class="line">// copy part of buffer</div><div class="line">var dashes = new Buffer(26);</div><div class="line">dashes.fill(&apos;-&apos;);</div><div class="line">console.log(&quot;Dashes: &quot; + dashes.toString());</div><div class="line">alphabet.copy(dashes, 10, 10, 15);</div><div class="line">console.log(&quot;Dashes: &quot; + dashes.toString());</div><div class="line">// copy to and from direct indexes of buffers</div><div class="line">var dots = new Buffer(&apos;----------------------------&apos;);</div><div class="line">dots.fill(&apos;.&apos;);</div><div class="line">console.log(&quot;dots: &quot; + dots.toString());</div><div class="line">for (var i = 0; i &lt; dots.length; i++) &#123;</div><div class="line">	if (i % 2) &#123;</div><div class="line">		dots[i] = alphabet[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(&quot;dots: &quot; + dots.toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node buffer_copy.js</div><div class="line">abcdefghijklmnopqrstuvwxyz</div><div class="line">Blank:</div><div class="line">Blank: abcdefghijklmnopqrstuvwxyz</div><div class="line">Dashes: --------------------------</div><div class="line">Dashes: ----------klmno-----------</div><div class="line">dots: ............................</div><div class="line">dots: .b.d.f.h.j.l.n.p.r.t.v.x.z.</div></pre></td></tr></table></figure></p>
<h3 id="5-2-7-对缓冲区切片"><a href="#5-2-7-对缓冲区切片" class="headerlink" title="5.2.7 对缓冲区切片"></a>5.2.7 对缓冲区切片</h3><p><strong>切片（slice）</strong> 是缓冲区的开始索引能和结束索引之间的部分。对缓冲区切片可以让你操作一个特定的快。<br>可以使用 slice([start], [end]) 创建切片，它返回一个 Buffer 对象，其指向原缓冲区的 start 索引，并具有<br>end - start 的长度。请记住，切片与副本不同。编辑副本不影响原缓冲区，<strong>编辑切片，会改变原缓冲区</strong>。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 创建和操作一个 Buffer 对象的切片</div><div class="line">var numbers = new Buffer(&quot;123456789&quot;);</div><div class="line">console.log(numbers.toString());</div><div class="line">var slice = numbers.slice(3, 6);</div><div class="line">console.log(slice.toString());</div><div class="line">slice[0] = &apos;#&apos;.charCodeAt(0);</div><div class="line">console.log(slice.toString());</div><div class="line">console.log(numbers.toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node buffer_slice.js</div><div class="line">123456789</div><div class="line">456</div><div class="line">#56</div><div class="line">123#56789</div></pre></td></tr></table></figure></p>
<h3 id="5-2-8-拼接缓冲区"><a href="#5-2-8-拼接缓冲区" class="headerlink" title="5.2.8 拼接缓冲区"></a>5.2.8 拼接缓冲区</h3><p>可以把两个或多个 Buffer 对象拼接在一起，形成一个新的缓冲区。concat(list, [totalLength]) 方法接受 Buffer 对象<br>的数组作为第一个参数，并把定义缓冲区最大字节数的 totalLength 作为可选的第二个参数。Buffer 对象按照他们出现在列表<br>中的顺序被拼接，一个新的 Buffer 对象被返回，它包含至多 totalLength 字节的原始缓冲区的内容。<br>如果不提供 totalLength 参数，concat() 就计算出总长度。但是，这样它必须遍历列表，所以提供 totalLength 执行得更快<br>一点。<br>一下代码线拼接基 Buffer 对象和一个缓冲区，然后再拼接另一个缓冲区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 拼接 Buffer 字符串</div><div class="line">var af = new Buffer(&quot;African Swallow?&quot;);</div><div class="line">var eu = new Buffer(&quot;European Swallow?&quot;);</div><div class="line">var question = new Buffer(&quot;Air Speed Velocity of an &quot;);</div><div class="line">console.log(Buffer.concat([question, af]).toString());</div><div class="line">console.log(Buffer.concat([question, eu]).toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node buffer_concat.js</div><div class="line">Air Speed Velocity of an African Swallow?</div><div class="line">Air Speed Velocity of an European Swallow?</div></pre></td></tr></table></figure></p>
<h2 id="5-3-使用-Stream-模块来传递数据"><a href="#5-3-使用-Stream-模块来传递数据" class="headerlink" title="5.3 使用 Stream 模块来传递数据"></a>5.3 使用 Stream 模块来传递数据</h2><p>数据流是可读，可写，或既可读又可写的内存结构。<br>流的目的是提供一种从一个地方向另一个地方传送数据的通用机制。它们还公开各种事件，如数据可被读取时的 data，当<br>错误发生时的 error 等等，这样可以注册监听器来在流变为可用或已准备好被写入时处理数据。<br>流一般用于 HTTP 数据和文件。可以作为读取流，打开文件，或者从 HTTP 请求访问数据，并读出所需的字节。  </p>
<h3 id="5-3-1-Readable-流"><a href="#5-3-1-Readable-流" class="headerlink" title="5.3.1 Readable 流"></a>5.3.1 Readable 流</h3><p>Readable 流旨在提供一种机制，以方便地读取从其他来源进入应用程序的数据。<br>常见实例：  </p>
<ul>
<li>在客户端的 HTTP 响应</li>
<li>在服务器的 HTTP 请求</li>
<li>fs 读取流</li>
<li>zlib 流</li>
<li>TCP 套接字</li>
<li>子进程的 stdout 和 stderr</li>
<li>process.stdin</li>
</ul>
<p>Readable 流提供 read([size]) 方法来读取数据，size 指定从流中读取的字节数。read() 可以返回一个 String 对象、<br>Buffer 对象或 null。Readable 流也公开了以下事件：  </p>
<ul>
<li>readable：在数据块可以从流中读取的时候发出。</li>
<li>data：类似于 readable，不同之处在于，当数据的事件处理程序被连接时，流转变成流动的模式，并且数据处理程序被<br>连续地调用，直到所有数据都被用尽。</li>
<li>end：当数据将不再被提供时由流发出。</li>
<li>close：当底层的资源，如文件，已关闭时发出。</li>
<li>error：当在接收数据中出现错误时发出。</li>
</ul>
<p>Readable 对象也提供了许多函数： </p>
<ul>
<li>read([size])：从流中读取数据。这些数据可以是 String、Buffer 或者 null （null 表示没有剩下任何更多的数据）。<br>如果指定 size 参数，那么被读取的数据将仅限于那个字节数。</li>
<li>setEncoding(encoding)：设置从 read() 请求读取返回 String 时使用的编码。</li>
<li>pause()：暂停从该对象发出的 data 事件。</li>
<li>resume()：恢复从该对象发出的 data 事件。</li>
<li>pipe(destination, [options])：把这个流的输出传输到 destination（目的地）指定的 Writable 流对象。options 是<br>一个 JavaScript 对象。例如，{end:true} 当 Readable 结束时就结束 Writable 目的地。</li>
<li>unpipe([destination])：从 Writable 目的地断开这一对象。</li>
</ul>
<p>为了实现自定义 Readable 流对象，需要首先继承 Readable 流的功能。最简单的方法是使用 util 模块的 inherits() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(MyReadableStream, stream.Readable);</div></pre></td></tr></table></figure></p>
<p>然后创建对象调用的实例：<br><code>stream.Readable.call(this, opt);</code><br>还需要实现一个调用 push() 来输出 Readable 对象中的数据的 _read() 方法。push() 调用应推入的是一个 String、<br>Buffer 或者 null。<br>下面实现了一个 Readable 流，并从中读取数据。注意，Answers() 类继承自 Readable，然后实现了<br>Answers.prototype._read() 函数来处理数据的推出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 实现一个 Readable 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Answers, stream.Readable);</div><div class="line">function Answers(opt) &#123;</div><div class="line">	stream.Readable.call(this, opt);</div><div class="line">	this.quotes = [&quot;yes&quot;, &quot;no&quot;, &quot;maybe&quot;];</div><div class="line">	this._index = 0;</div><div class="line">&#125;</div><div class="line">Answers.prototype._read = function() &#123;</div><div class="line">	if (this._index &gt; this.quotes.length) &#123;</div><div class="line">		this.push(null);</div><div class="line">	&#125; else &#123;</div><div class="line">		this.push(this.quotes[this._index]);</div><div class="line">		this._index += 1;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var r = new Answers();</div><div class="line">// 直接 read() 调用从流中读取第一个条目</div><div class="line">console.log(&quot;Direct read: &quot; + r.read().toString());</div><div class="line">// 数据处理程序读取其余条目</div><div class="line">r.on(&apos;data&apos;, function(data)&#123;</div><div class="line">	console.log(&quot;Callback read: &quot; + data.toString());</div><div class="line">&#125;);</div><div class="line">r.on(&apos;end&apos;, function(data)&#123;</div><div class="line">	console.log(&quot;No more answers.&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node stream_read.js</div><div class="line">Direct read: yes</div><div class="line">Callback read: no</div><div class="line">Callback read: maybe</div><div class="line">No more answers.</div></pre></td></tr></table></figure></p>
<h3 id="5-3-2-Writable-流"><a href="#5-3-2-Writable-流" class="headerlink" title="5.3.2 Writable 流"></a>5.3.2 Writable 流</h3><p>Writable 流旨在提供把数据写入一种可以轻松地在代码的另一个区域被使用的形式的机制。<br>Writable 流的常见实例：  </p>
<ul>
<li>在客户端的 HTTP 请求</li>
<li>在服务器的 HTTP 响应</li>
<li>fs 写入刘</li>
<li>zlib 流</li>
<li>TCP 套接字</li>
<li>子进程的 stdin</li>
<li>process.stdout 和 process.stderr</li>
</ul>
<p>Writable 流提供 write(chunk, [encoding], [callback]) 方法来将数据写入流中。其中，chunk（数据块）中包含要<br>写入的数据；encoding 指定字符串的编码；callback 指定当数据已经完全刷新时执行的一个回调函数。如果数据被成功写入，<br>则 write() 函数返回 true。<br>Writable 公开了以下事件：  </p>
<ul>
<li>drain：在 write() 调用返回 false 后，当准备好开始写更多的数据时，发出此事件通知监听器。</li>
<li>finish：当 end() 在 Writable 对象上被调用，所有的数据都被刷新，并且不会有更多的数据将被接收时发出此事件。</li>
<li>pipe：当 pipe() 方法在 Readable 流上被调用，以添加此 Writable 为目的地时，发出此事件。</li>
<li>unpipe： 当 unpipe() 方法在 Readable 流上被调用，以删除此 Writable 为目的地时，发出此事件。</li>
</ul>
<p>可用的 Writable 流对象的方法：  </p>
<ul>
<li>write(chunk, [encoding], [callback])：将数据块写入流对象的数据位置。该数据可以是字符串或缓冲区。如果<br>指定 encoding，那么将其用于对字符串数据的编码。如果指定 callback，那么它在数据已被刷新后调用。</li>
<li>end([chunk], [encoding], [callback])：与 write() 相同，但是它把 Writable 对象置于不再接收数据的状态，<br>并发送 finish 事件。</li>
</ul>
<p>实现自定义 Writable 流对象，首先继承 Writable 流的功能，使用 util模块的 inherits() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(MyWritableStream, stream.Writable);</div></pre></td></tr></table></figure></p>
<p>创建对象调用的实例：<br><code>stream.Writable.call(this, opt);</code><br>还需实现一个 _write(data, encoding, callback) 方法存储 Writable 对象的数据。<br>下面代码说明了实现和写入 Writable 流的基本知识：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 实现一个 Writable 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Writer, stream.Writable);</div><div class="line">function Writer(opt) &#123;</div><div class="line">	stream.Writable.call(this, opt);</div><div class="line">	this.data = new Array();</div><div class="line">&#125;</div><div class="line">Writer.prototype._write = function(data, encoding, callback) &#123;</div><div class="line">	this.data.push(data.toString(&apos;utf8&apos;));</div><div class="line">	console.log(&quot;Adding: &quot; + data);</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">var w = new Writer();</div><div class="line">for (var i = 1; i &lt;= 5; i++) &#123;</div><div class="line">	w.write(&quot;Item&quot; + i, &apos;utf8&apos;);</div><div class="line">&#125;</div><div class="line">w.end(&quot;ItemLast&quot;);</div><div class="line">console.log(w.data);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node stream_write.js</div><div class="line">Adding: Item1</div><div class="line">Adding: Item2</div><div class="line">Adding: Item3</div><div class="line">Adding: Item4</div><div class="line">Adding: Item5</div><div class="line">Adding: ItemLast</div><div class="line">[ &apos;Item1&apos;, &apos;Item2&apos;, &apos;Item3&apos;, &apos;Item4&apos;, &apos;Item5&apos;, &apos;ItemLast&apos; ]</div></pre></td></tr></table></figure></p>
<h3 id="5-3-3-Duplex-流"><a href="#5-3-3-Duplex-流" class="headerlink" title="5.3.3 Duplex 流"></a>5.3.3 Duplex 流</h3><p>Duplex（双向）流是结合可读写功能的流。Duplex 流的很好地例子是 TCP 套接字连接。可在创建套接字后读取和写入它。<br>实现自定义 Duplex 流对象，首先继承 Duplex 流的功能，使用 util 模块的 inherits() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(MuDuplexStream, stream.Duplex);</div></pre></td></tr></table></figure></p>
<p>然后创建对象调用实例：<br><code>stream.Duplex.call(this, opt);</code><br>创建一个 Duplex 流的 opt 参数接受一个 allowHalfOpen 数次那个设置为 true 或 false 的对象。true：即使可写入端<br>已经结束，可读取端也保持打开状态，反之亦然。false：结束可写入端也会结束可读取端，反之亦然。<br>当实现一个全 Duplex 流时，在原型化 Duplex 类的时候需要同时实现 _read(size) 和 _write(data, encoding, callback)<br>方法。<br>下面代码实现、写入、读取 Duplex 流。Duplex() 类继承自 Duplex 流，并实现了基本的 _write() 函数来将数据存储在该<br>对象中的数组内。_read() 函数使用 shift() 来获得此数组的第一个条目，如果等于“stop”，那么推入 null；如果有值，<br>那么推入它；或者如果没有值，则设置超时时间定时器来回调到 _read() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 实现 Duplex 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Duplexer, stream.Duplex);</div><div class="line">function Duplexer(opt) &#123;</div><div class="line">	stream.Duplex.call(this, opt);</div><div class="line">	this.data = [];</div><div class="line">&#125;</div><div class="line">Duplexer.prototype._read = function readItem(size) &#123;</div><div class="line">	var chunk = this.data.shift();</div><div class="line">	if (chunk == &quot;stop&quot;) &#123;</div><div class="line">		this.push(null);</div><div class="line">	&#125; else &#123;</div><div class="line">		if (chunk) &#123;</div><div class="line">			this.push(chunk);</div><div class="line">		&#125; else &#123;</div><div class="line">			setTimeout(readItem.bind(this), 500, size);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">Duplexer.prototype._write = function(data, encoding, callback) &#123;</div><div class="line">	this.data.push(data);</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">var d = new Duplexer();</div><div class="line">d.on(&apos;data&apos;, function(chunk)&#123;</div><div class="line">	console.log(&apos;read: &apos;, chunk.toString());</div><div class="line">&#125;);</div><div class="line">d.on(&apos;end&apos;, function()&#123;</div><div class="line">	console.log(&apos;Message Complete&apos;);</div><div class="line">&#125;);</div><div class="line">d.write(&quot;I think, &quot;);</div><div class="line">d.write(&quot;therefore &quot;);</div><div class="line">d.write(&quot;I am.&quot;);</div><div class="line">d.write(&quot;Rene Descartes&quot;);</div><div class="line">d.write(&quot;stop&quot;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node stream_duplex.js</div><div class="line">read:  I think,</div><div class="line">read:  therefore</div><div class="line">read:  I am.</div><div class="line">read:  Rene Descartes</div><div class="line">Message Complete</div></pre></td></tr></table></figure></p>
<h3 id="5-3-4-Transform-流"><a href="#5-3-4-Transform-流" class="headerlink" title="5.3.4 Transform 流"></a>5.3.4 Transform 流</h3><p>Transform（变换）流扩展了 Duplex 流，但它修改 Writable 流和 Readable 流之间的数据。当需要修改从一个系统到<br>另一个系统的数据时，此类型会非常有用。<br>实例：  </p>
<ul>
<li>zlib 流</li>
<li>crypto 流</li>
</ul>
<p>Duplex 和 Transform 流区别：Transform 流不用实现 _read() 和 _write() 原型方法。这些被作为直通函数提供。但是<br>需要实现 _transform(chunk, encoding, callback) 和 _flush(callback) 方法。此 _transform() 方法应该接受来自<br>write() 请求的数据，对其修改，并推出修改后的数据。  </p>
<p>以下代码，实现 Transform 流，这个流接受 JSON 字符串，将它们转换为对象，然后发出发送对象的名为 object 的自定义<br>事件给所有监听器。该 _transform() 函数也修改对象来包括一个 handled 属性，然后以字符串形式发送。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 实现 Transform 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(JSONObjectStream, stream.Transform);</div><div class="line">function JSONObjectStream(opt) &#123;</div><div class="line">	stream.Transform.call(this, opt);</div><div class="line">&#125;</div><div class="line">JSONObjectStream.prototype._transform = function(data, encoding, callback) &#123;</div><div class="line">	object = data ? JSON.parse(data.toString()) : &quot;&quot;;</div><div class="line">	this.emit(&quot;object&quot;, object);</div><div class="line">	object.handled = true;</div><div class="line">	this.push(JSON.stringify(object));</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">JSONObjectStream.prototype._flush = function(cb) &#123;</div><div class="line">	cb();</div><div class="line">&#125;;</div><div class="line">var tc = new JSONObjectStream();</div><div class="line">tc.on(&quot;object&quot;, function() &#123;</div><div class="line">	console.log(&quot;Name: %s&quot;, object.name);</div><div class="line">	console.log(&quot;Color: %s&quot;, object.color);</div><div class="line">&#125;);</div><div class="line">tc.on(&quot;data&quot;, function(data) &#123;</div><div class="line">	console.log(&quot;Data: %s&quot;, data.toString());</div><div class="line">&#125;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Carolinus&quot;, &quot;color&quot;: &quot;Green&quot;&#125;&apos;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Solarius&quot;, &quot;color&quot;: &quot;Blue&quot;&#125;&apos;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Lo Tae Zhao&quot;, &quot;color&quot;: &quot;Gold&quot;&#125;&apos;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Ommadon&quot;, &quot;color&quot;: &quot;Red&quot;&#125;&apos;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ node stream_transform.js</div><div class="line">Name: Carolinus</div><div class="line">Color: Green</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Carolinus&quot;,&quot;color&quot;:&quot;Green&quot;,&quot;handled&quot;:true&#125;</div><div class="line">Name: Solarius</div><div class="line">Color: Blue</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Solarius&quot;,&quot;color&quot;:&quot;Blue&quot;,&quot;handled&quot;:true&#125;</div><div class="line">Name: Lo Tae Zhao</div><div class="line">Color: Gold</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Lo Tae Zhao&quot;,&quot;color&quot;:&quot;Gold&quot;,&quot;handled&quot;:true&#125;</div><div class="line">Name: Ommadon</div><div class="line">Color: Red</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Ommadon&quot;,&quot;color&quot;:&quot;Red&quot;,&quot;handled&quot;:true&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-3-5-把-Readable-流用管道输送到-Writable-流"><a href="#5-3-5-把-Readable-流用管道输送到-Writable-流" class="headerlink" title="5.3.5 把 Readable 流用管道输送到 Writable 流"></a>5.3.5 把 Readable 流用管道输送到 Writable 流</h3><p>通过 pipe(writableStream, [options]) 函数把 Readable 流的输出直接输入到 Writable 流。options 参数接受一个<br>end 属性为 true 或 false 的对象。true：Writable 流随着 Readable 流的结束而结束。这是默认行为。例如：<br><code>readStream.pipe(writeStream, {end:true});</code><br>可以使用 unpipe(destinationStream) 选项来打破管道。<br>下面代码实现了一个 Readable 流和 Writable 流，然后使用 pipe() 函数把它们链接在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 把 Readable 流传送到 Writable 流</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Reader, stream.Readable);</div><div class="line">util.inherits(Writer, stream.Writable);</div><div class="line">function Reader(opt) &#123;</div><div class="line">	stream.Readable.call(this, opt);</div><div class="line">	this._index = 1;</div><div class="line">&#125;</div><div class="line">Reader.prototype._read = function(size) &#123;</div><div class="line">	var i = this._index++;</div><div class="line">	if (i &gt; 10) &#123;</div><div class="line">		this.push(null);</div><div class="line">	&#125; else &#123;</div><div class="line">		this.push(&quot;Item &quot; + i.toString());</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">function Writer(opt) &#123;</div><div class="line">	stream.Writable.call(this, opt);</div><div class="line">	this._index = 1;</div><div class="line">&#125;</div><div class="line">Writer.prototype._write = function(data, encoding, callback) &#123;</div><div class="line">	console.log(data.toString());</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">var r = new Reader();</div><div class="line">var w = new Writer();</div><div class="line">r.pipe(w);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ node stream_piped.js</div><div class="line">Item 1</div><div class="line">Item 2</div><div class="line">Item 3</div><div class="line">Item 4</div><div class="line">Item 5</div><div class="line">Item 6</div><div class="line">Item 7</div><div class="line">Item 8</div><div class="line">Item 9</div><div class="line">Item 10</div></pre></td></tr></table></figure></p>
<h2 id="5-4-用-Zlib-压缩与解压缩数据"><a href="#5-4-用-Zlib-压缩与解压缩数据" class="headerlink" title="5.4 用 Zlib 压缩与解压缩数据"></a>5.4 用 Zlib 压缩与解压缩数据</h2><p>在使用大的系统或移动大量数据时，压缩/解压缩数据的能力极为有用。<br>记住，压缩数据需要花费 CPU 周期，所以在招致压缩/解压缩成本之前，应该确信压缩数据会带来好处。<br>Zlib 支持如下压缩方法：  </p>
<ul>
<li>gzip/gunzip：标准 gzip 压缩。</li>
<li>deflate/inflate：基于 Huffman 编码的标准 deflate 压缩算法。</li>
<li>deflateRaw/inflateRaw：针对原始缓冲区的 deflate 压缩算法。</li>
</ul>
<h3 id="5-4-1-压缩和解压缩缓冲区"><a href="#5-4-1-压缩和解压缩缓冲区" class="headerlink" title="5.4.1 压缩和解压缩缓冲区"></a>5.4.1 压缩和解压缩缓冲区</h3><p>Zlib 模块提供了几个辅助含税，基本格式 function(buffer, callback)，其中 buffer 是被压缩/解压缩的缓冲区，<br>callback 是压缩/解压缩发生之后所执行的回调函数。<br>以下几种示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 使用 Zlib 模块压缩/解压缩缓冲区</div><div class="line">var zlib = require(&apos;zlib&apos;);</div><div class="line">var input = &apos;..................text................&apos;;</div><div class="line">zlib.deflate(input, function(err, buffer) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		console.log(&quot;deflate (%s): &quot;, buffer.length, buffer.toString(&apos;base64&apos;));</div><div class="line">		zlib.inflate(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;inflate (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		zlib.unzip(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;unzip deflate (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">zlib.deflateRaw(input, function(err, buffer) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		console.log(&quot;deflateRaw (%s): &quot;, buffer.length, buffer.toString(&apos;base64&apos;));</div><div class="line">		zlib.inflateRaw(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;inflateRaw (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">zlib.gzip(input, function(err, buffer) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		console.log(&quot;gzip (%s): &quot;, buffer.length, buffer.toString(&apos;base64&apos;));</div><div class="line">		zlib.gunzip(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;gunzip (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		zlib.unzip(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;unzip gzip (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ node zlib_buffers.js</div><div class="line">deflate (17):  eJzT00MHJakVJehiAJizB+I=</div><div class="line">deflateRaw (11):  09NDByWpFSXoYgA=</div><div class="line">gzip (29):  H4sIAAAAAAAACtPTQwclqRUl6GIAandyAiYAAAA=</div><div class="line">inflate (38):  ..................text................</div><div class="line">unzip deflate (38):  ..................text................</div><div class="line">inflateRaw (38):  ..................text................</div><div class="line">gunzip (38):  ..................text................</div><div class="line">unzip gzip (38):  ..................text................</div></pre></td></tr></table></figure></p>
<h3 id="5-2-4-压缩-解压缩流"><a href="#5-2-4-压缩-解压缩流" class="headerlink" title="5.2.4 压缩/解压缩流"></a>5.2.4 压缩/解压缩流</h3><p>对流操作使用 pipe() 函数，用过压缩/解压缩对象把数据从一个流输送到另一个流。 适用于把任何 Readable 数据压缩成<br>Writable 流。<br>示例使用 fs.ReadStream 和 fs.WriteStream 压缩文件内容，通过使用 xlib.Gzip() 对象压缩一个文件的内容，然后<br>用 zlib.Gunzip() 对象对它解压缩。注意，在试图解压缩文件，以允许数据被刷新到磁盘之前，有 3 秒的超时时间延迟。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 使用 Zlib 模块压缩/解压缩文件流</div><div class="line">var zlib = require(&quot;zlib&quot;);</div><div class="line">var gzip = zlib.createGzip();</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var inFile = fs.createReadStream(&apos;zlib_file.js&apos;);</div><div class="line">var outFile = fs.createWriteStream(&apos;zlib_file.gz&apos;);</div><div class="line">inFile.pipe(gzip).pipe(outFile);</div><div class="line">setTimeout(function()&#123;</div><div class="line">	var gunzip = zlib.createUnzip(&#123;flush: zlib.Z_FULL_FLUSH&#125;);</div><div class="line">	var inFile = fs.createReadStream(&apos;zlib_file.gz&apos;);</div><div class="line">	var outFile = fs.createWriteStream(&apos;zlib_file.unzipped&apos;);</div><div class="line">	inFile.pipe(gunzip).pipe(outFile);</div><div class="line">&#125;, 3000);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/在 Node.js 中使用事件、监听器、定时器和回调/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/在 Node.js 中使用事件、监听器、定时器和回调/" itemprop="url">在 Node.js 中使用事件、监听器、定时器和回调</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T21:31:29+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在-Node-js-中使用事件、监听器、定时器和回调"><a href="#在-Node-js-中使用事件、监听器、定时器和回调" class="headerlink" title="在 Node.js 中使用事件、监听器、定时器和回调"></a>在 Node.js 中使用事件、监听器、定时器和回调</h1><h3 id="4-2-1-实现定时器"><a href="#4-2-1-实现定时器" class="headerlink" title="4.2.1 实现定时器"></a>4.2.1 实现定时器</h3><p><strong>用超时时间来延迟工作</strong><br>超时定时器用于将工作延迟一个特定时间数量。当时间到了时，回调函数执行，而定时器会消失。对于只需要执行一次的工作，<br>应当使用超时时间。<br>创建超时时间定时器使用 Node.js 中内置的 setTimeout(callback, delayMilliSeconds, [args]) 方法。当你调用<br>setTimeout() 时，回调函数在 delayMilliSeconds 到期后执行。例如，下面的语句在 1 秒后执行 myFunc()：<br><code>setTimeout(myFunc, 1000)</code><br>setTimeout() 函数返回定时器对象的 ID，可以在 delayMilliSeconds 到期前任何时候把此 ID 传递给 clearTimeout(timeoutId)<br>来取消超时时间函数。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myTimeout = setTimeout(myFunc,, 100000);</div><div class="line">...</div><div class="line">clearTimeout(myTimeout);</div></pre></td></tr></table></figure></p>
<p>以下代码实现了调用 simpleTimeout() 函数的一系列简单超时时间，它输出自从超时时间被安排后经历的毫秒数。请注意，<br>setTimeout() 的调用次序是无关紧要的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// simple_timer.js 在不同的时间间隔实现了一系列超时时间</div><div class="line">function simpleTimeout(consoleTimer) &#123;</div><div class="line">	console.timeEnd(consoleTimer);</div><div class="line">&#125;</div><div class="line">console.time(&quot;twoSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 2000, &quot;twoSecond&quot;);</div><div class="line">console.time(&quot;oneSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 1000, &quot;oneSecond&quot;);</div><div class="line">console.time(&quot;fiveSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 5000, &quot;fiveSecond&quot;);</div><div class="line">console.time(&quot;50MilliSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 50, &quot;50MilliSecond&quot;);</div></pre></td></tr></table></figure></p>
<p>下面结果按照其中的延时结束的顺序出现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node simple_timer.js</div><div class="line">50MilliSecond: 51.578ms</div><div class="line">oneSecond: 999.679ms</div><div class="line">twoSecond: 2001.768ms</div><div class="line">fiveSecond: 5000.161ms</div></pre></td></tr></table></figure></p>
<p><strong>用时间间隔执行定期工作</strong><br>时间间隔定时器用于按定期的延迟时间执行工作。当延时结束时，回调函数被执行，然后再次重新调度为改延迟时间，对于必须<br>定期进行的工作，你应该使用时间间隔。<br>可以通过 Node,js 中内置的 setInterval(callback, delayMilliSeconds, [args]) 方法创建时间间隔计时器。当你调用<br>setInterval() 时，么个 delayMilliSeconds 间隔到后，回调函数执行。例如，下面的语句每秒执行一次  myFunc()：<br><code>setInterval(myFunc, 1000);</code><br>setInterval() 函数返回定时器对象的 ID，你可以在 delayMilliSeconds 到期前把 ID 传递给 clearInterval(intervalId)<br>来取消超时时间函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myInterval = setInterval(myFunc, 1000);</div><div class="line">...</div><div class="line">clearInterval(myInterval);</div></pre></td></tr></table></figure></p>
<p>下面的代码实现了一系列在不同的时间间隔更新变量 x、y 和 z 值得简单时间间隔回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// simple_interval.js 在不同的时间间隔实现了一系列的更新回调</div><div class="line">var x=0, y=0, z=0;</div><div class="line">function displayValue() &#123;</div><div class="line">	console.log(&quot;X=%d; Y=%d; Z=%d&quot;, x, y, z);</div><div class="line">&#125;</div><div class="line">function updateX() &#123;</div><div class="line">	x += 1;</div><div class="line">&#125;</div><div class="line">function updateY() &#123;</div><div class="line">	y += 1;</div><div class="line">&#125;</div><div class="line">function updateZ() &#123;</div><div class="line">	z += 1;</div><div class="line">	displayValue();</div><div class="line">&#125;</div><div class="line">setInterval(updateX, 500);</div><div class="line">setInterval(updateY, 1000);</div><div class="line">setInterval(updateZ, 2000);</div></pre></td></tr></table></figure></p>
<p>请注意 x、y 和 z 的值的改变不同，因为该时间间隔量是不同的；x 得递增速度是 y 的两倍，y 的递增速度又是 z 的两倍，<br>输出如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ node simple_interval.js</div><div class="line">X=3; Y=1; Z=1</div><div class="line">X=7; Y=3; Z=2</div><div class="line">X=11; Y=5; Z=3</div><div class="line">X=15; Y=7; Z=4</div><div class="line">X=19; Y=9; Z=5</div><div class="line">X=23; Y=11; Z=6</div><div class="line">X=27; Y=13; Z=7</div><div class="line">X=31; Y=15; Z=8</div><div class="line">X=35; Y=17; Z=9</div><div class="line">X=39; Y=19; Z=10</div><div class="line">X=43; Y=21; Z=11</div><div class="line">X=47; Y=23; Z=12</div></pre></td></tr></table></figure></p>
<p><strong>使用及时计时器立即执行工作</strong><br>即时计时器用来在 I/O 事件的回调函数开始执行后，但任何超时时间或时间间隔事件被执行之前，立刻执行工作。它们允许你<br>把工作调度为在事件队列中的当前事件完成之后执行。你应该使用即时定时器为其他回调产生长期运行的执行段，以防止 I/O<br>事件饥饿。<br>可以使用 Node.js 中内置的 setImmediate(callback, [args]) 方法创建即时计时器。当你调用 setImmediate() 时，<br>回调函数被放置在事件队列中，并在遍历事件队列循环的每次迭代中，在 I/O 有机会被调用后弹出一次。例如，下面的代码调度<br>myFunc() 来在遍历事件队列的下一个周期内执行：<br><code>setimmediate(myFunc(), 1000);</code><br>setImmediate() 函数返回一个定时器对象的 ID，你可以在从事件队列提取出它前的任何时候把 ID 传递给 clearImmediate(<br>immediateId)。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myImmediate = setImmediate(myFunc);</div><div class="line">...</div><div class="line">clearImmediate(myImmediate);</div></pre></td></tr></table></figure></p>
<p><strong>从事件循环中取消定时器引用</strong><br>当定时器事件回调是留在事件队列中的仅有事件时，通常你不会希望它们继续被调度。setInterval 和 setTimeout 返回的对象<br>中的 unref() 函数，能在这些事件是队列中仅有的事件时，通知事件循环不要继续。<br>例如，下面的代码取消 myInterval 时间间隔定时器引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myInterval = setInterval(myFunc);</div><div class="line">myInterval.unref();</div></pre></td></tr></table></figure></p>
<p>如果以后由于某种原因，你不想在时间间隔函数是留在队列中的仅有事件时终止程序，就可以使用 ref() 函数来重新引用它：<br><code>myInterval.ref()</code>  </p>
<blockquote>
<p><strong>警告</strong><br>当 unref() 与 setTimeout 定时器结合使用时，要用一个独立的定时器来唤醒时间循环。大量使用这些功能会对你<br>的代码性能产生不利影响，所以应该尽量少地创建它们。  </p>
</blockquote>
<h3 id="4-2-2-使用-nextTick-来调度工作"><a href="#4-2-2-使用-nextTick-来调度工作" class="headerlink" title="4.2.2 使用 nextTick 来调度工作"></a>4.2.2 使用 nextTick 来调度工作</h3><p>在事件队列上调度工作的一个非常有用的方法是使用 process.nextTick(callback) 函数。此函数调度要在事件循环的下一次<br>循环中运行的工作。不像 setImmediate() 方法，nextTick() 在 I/O 事件被触发之前执行。这可能会导致 I/O 事件的饥饿，<br>所以 Node.js 通过默认值为 1000 的 process.maxTickDepth 来限制事件队列的每次循环可执行的 nextTick 事件的数目。<br>下面的代码说明了使用阻塞 I/O 调用、定时器和 nextTick() 时，事件的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// nexttick.js：实现了一系列阻塞 fs 调用，即时计时器和 nextTick() 调用来显示执行顺序</div><div class="line">var fs = require(&quot;fs&quot;);</div><div class="line">fs.stat(&quot;nexttick.js&quot;, function(err, stats) &#123;</div><div class="line">	if(stats) &#123;</div><div class="line">		console.log(&quot;nexttick.js Exists&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">setImmediate(function() &#123;</div><div class="line">	console.log(&quot;Immediate Timer 1 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">setImmediate(function() &#123;</div><div class="line">	console.log(&quot;Immediate Timer 2 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">process.nextTick(function() &#123;</div><div class="line">	console.log(&quot;Next Tick 1 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">process.nextTick(function() &#123;</div><div class="line">	console.log(&quot;Next Tick 2 Executed&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出如下，显示 nextTick() 调用先得到执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node nexttick.js</div><div class="line">Next Tick 1 Executed</div><div class="line">Next Tick 2 Executed</div><div class="line">Immediate Timer 1 Executed</div><div class="line">Immediate Timer 2 Executed</div><div class="line">nexttick.js Exists</div></pre></td></tr></table></figure></p>
<h3 id="4-2-3-实现事件发射器和监听器"><a href="#4-2-3-实现事件发射器和监听器" class="headerlink" title="4.2.3 实现事件发射器和监听器"></a>4.2.3 实现事件发射器和监听器</h3><p>本节重点介绍创建自己的自定义事件，以及实现党一个事件被发出时执行的监听器回调。<br><strong>将自定义事件添加到 JavaSript 对象</strong><br>事件使用一个 EventEmitter 对象来发出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var events = require(&apos;events&apos;);</div><div class="line">var emitter = new events.EventEmitter();</div><div class="line">emitter.emit(&quot;simpleEvent&apos;);</div></pre></td></tr></table></figure></p>
<p>直接把事件添加到 JavaScript 对象，需要通过在对象实例中调用 events.EventEmitter.call(this) 来在对象中继承<br>EventEmitter 功能，还需要把 events.EventEmitter.prototype 添加到对象的原型中。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function MyObj() &#123;</div><div class="line">    Events.EventEmitter.call(this);</div><div class="line">&#125;</div><div class="line">MyObj.prototype.__proto__ = events.EventEmitter.prototype;</div></pre></td></tr></table></figure></p>
<p>然后，就可以直接从对象实例中触发事件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myObj = new MyObj();</div><div class="line">myObj.emit(&quot;someEvent&quot;):</div></pre></td></tr></table></figure></p>
<p><strong>把事件监听器添加到对象</strong><br>一旦有了一个会发出事件的对象实例，就可以喂自己所关心的事件添加监听器。可以通过使用下面的功能之一把监听器添加到<br>EventEmitter 对象。  </p>
<ul>
<li><strong>.addListener(eventName, callback)</strong>：将回调函数附加到对象的监听器中。每当 eventName 事件被触发时，<br>回调函数就被放置在事件队列中执行。</li>
<li><strong>.on(eventName, callback)</strong>：同 .addListener()。</li>
<li><strong>.once(eventName, callback)</strong>：只有 eventName 事件第一次被触发时，回调函数才被放置在事件队列中执行。  </li>
</ul>
<p>例如，要在前面定义的 MyObject EventEmitter 类的实例中增加一个监听器，可以使用如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function myCallback() &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">var myObject = new MyObj();</div><div class="line">myObject.on(&quot;someEvent&quot;, myCallback);</div></pre></td></tr></table></figure></p>
<p><strong>从对象中删除监听器</strong><br>监听器会导致开销，只在必要时使用。Node.js 在 EventEmitter 对象上提供了多个辅助函数来管理监听器。  </p>
<ul>
<li><strong>.listener(eventName)：</strong> 返回一个连接到 eventName 事件的监听器函数的数组。</li>
<li><strong>.setMaxListeners(n)：</strong> 如果多于 n 的监听器都加入到 EventEmitter 对象，就会触发警报。默认值 10。</li>
<li><strong>.removeListener(eventName, callback)：</strong> 将 callback 函数从 EventEmitter 对象的 eventName 事件中删除。  </li>
</ul>
<p><strong>实现事件监听器和发射器事件</strong><br>一下代码演示在 Node.js 实现监听器和自定义事件发射器的过程。Account 对象从 EventEmitter 类继承并提供了两种方法，即<br>deposit（存款）和 withdraw（取款），它们都发射 balanceChanged 事件。然后，3 个回调函数的实现连接到 Account 对象<br>实例的 balanceChanged 事件并显示各种形式的数据。<br>请注意，checkGoal(acc, goal) 回调函数的实现有点不同于其他回调函数。这说明了如何在事件被触发时，将变量传递到该事件<br>监听函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// emitter_listener.js：创建一个自定义 EventEmitter 对象并实现当</div><div class="line">// balanceChanged 事件被触发时所触发的 3 个监听器</div><div class="line">var events = require(&apos;events&apos;);</div><div class="line">function Account() &#123;</div><div class="line">	this.balance = 0;</div><div class="line">	events.EventEmitter.call(this);</div><div class="line">	this.deposit = function(amount) &#123;</div><div class="line">		this.balance += amount;</div><div class="line">		this.emit(&apos;balanceChanged&apos;);</div><div class="line">	&#125;;</div><div class="line">	this.withdraw = function(amount) &#123;</div><div class="line">		this.balance -= amount;</div><div class="line">		this.emit(&apos;balanceChanged&apos;);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">Account.prototype.__proto__ = events.EventEmitter.prototype;</div><div class="line">function displayBalance()&#123;</div><div class="line">	console.log(&quot;Account balance: $%d&quot;, this.balance);</div><div class="line">&#125;</div><div class="line">function checkOverdraw() &#123;</div><div class="line">	if (this.balance &lt; 0) &#123;</div><div class="line">		console.log(&quot;Account overdrawn!!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function checkGoal(acc, goal) &#123;</div><div class="line">	if (acc.balance &gt; goal) &#123;</div><div class="line">		console.log(&quot;Goal Achieved!!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var account = new Account();</div><div class="line">account.on(&quot;balanceChanged&quot;, displayBalance);</div><div class="line">account.on(&quot;balanceChanged&quot;, checkOverdraw);</div><div class="line">account.on(&quot;balanceChanged&quot;, function() &#123;</div><div class="line">	checkGoal(this, 1000);</div><div class="line">&#125;);</div><div class="line">account.deposit(220);</div><div class="line">account.deposit(320);</div><div class="line">account.deposit(600);</div><div class="line">account.withdraw(1200);</div></pre></td></tr></table></figure></p>
<p>emitter_listener.js 的输出，显示了监听器回调函数输出的会计报表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node emitter_listener.js</div><div class="line">Account balance: $220</div><div class="line">Account balance: $540</div><div class="line">Account balance: $1140</div><div class="line">Goal Achieved!!!</div><div class="line">Account balance: $-60</div><div class="line">Account overdrawn!!!</div></pre></td></tr></table></figure></p>
<h2 id="4-3-实现回调"><a href="#4-3-实现回调" class="headerlink" title="4.3 实现回调"></a>4.3 实现回调</h2><h3 id="4-3-1-向回调函数传递额外的参数"><a href="#4-3-1-向回调函数传递额外的参数" class="headerlink" title="4.3.1 向回调函数传递额外的参数"></a>4.3.1 向回调函数传递额外的参数</h3><p>大部分回调函数都有传递给它们的自动参数，如错误或结果缓冲区。使用回调时，常见的一个问题是如何从调用函数给它们传递额外<br>的参数。方法是在一个匿名函数中实现该参数，然后用来自匿名函数的参数调用回调函数。<br>一下代码展示了如何实现回调函数的参数。有两个 sawCar 事件处理程序。请注意，sawCar 仅发出 make 参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// callback_parameter.js 创建一个匿名函数来添加未由事件发出的附加参数</div><div class="line">var events = require(&apos;events&apos;);</div><div class="line">function CarShow() &#123;</div><div class="line">	events.EventEmitter.call(this);</div><div class="line">	this.seeCar = function(make) &#123;</div><div class="line">		this.emit(&apos;sawCar&apos;, make);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">CarShow.prototype.__proto__ = events.EventEmitter.prototype;</div><div class="line">var show = new CarShow();</div><div class="line">function logCar(make) &#123;</div><div class="line">	console.log(&quot;Saw a &quot; + make);</div><div class="line">&#125;</div><div class="line">function logColorCar(make, color) &#123;</div><div class="line">	console.log(&quot;Saw a %s %s&quot;, color, make);</div><div class="line">&#125;</div><div class="line">// 实现了 logCar(make) 回调处理程序</div><div class="line">show.on(&quot;sawCar&quot;, logCar);</div><div class="line">// 事件处理程序调用了一个匿名函数，随机选择的颜色被传递到 logColorCar(make, color) 调用</div><div class="line">show.on(&quot;sawCar&quot;, function(make) &#123;</div><div class="line">	var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;black&apos;];</div><div class="line">	var color = colors[Math.floor(Math.random() * 3)];</div><div class="line">	logColorCar(make, color);</div><div class="line">&#125;);</div><div class="line">show.seeCar(&quot;Ferrari&quot;);</div><div class="line">show.seeCar(&quot;Porsche&quot;);</div><div class="line">show.seeCar(&quot;Bugatti&quot;);</div><div class="line">show.seeCar(&quot;Lamborghini&quot;);</div><div class="line">show.seeCar(&quot;Aston Martin&quot;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ node callback_parameter</div><div class="line">Saw a Ferrari</div><div class="line">Saw a blue Ferrari</div><div class="line">Saw a Porsche</div><div class="line">Saw a blue Porsche</div><div class="line">Saw a Bugatti</div><div class="line">Saw a blue Bugatti</div><div class="line">Saw a Lamborghini</div><div class="line">Saw a red Lamborghini</div><div class="line">Saw a Aston Martin</div><div class="line">Saw a black Aston Martin</div></pre></td></tr></table></figure></p>
<h3 id="4-3-2-在回调中实现闭包"><a href="#4-3-2-在回调中实现闭包" class="headerlink" title="4.3.2 在回调中实现闭包"></a>4.3.2 在回调中实现闭包</h3><p>一个与异步回调的有趣问题是闭包。闭包（Closure） 是一个 JavaScript 的术语，它表示变量被绑定到一个函数的作用域，但<br>不绑定到它的父函数的作用域。当你执行一个异步回调时，父函数的作用域可能更改（例如，通过遍历列表并在每次迭代时改变值）。<br>如果某个函数需要访问父函数的作用域的变量，就需要提供闭包，使这些值在回调函数从事件队列被提取出时可以得到。一个基本<br>方法是在函数块内部封装一个异步调用，并传入所需要的变量。<br>下面代码说明了如何实现为 logCar() 异步函数提供闭包的包装器函数。循环 1 实现了一个基本的回调函数。然而，输出显示中，<br>汽车的名字始终是被读取的最后一个条目，因为每次循环迭代时， message 的值都会变化。<br>循环 2 实现了把消息作为 msg 参数传递的包装器函数，而 msg 值被附着在回调函数上。因此，输出了正确的消息。为了使回调<br>真正异步，使用 process.nextTick() 方法来调度函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// callback_closure.js：创建一个包装器函数来提供异步回调所需的变量的闭包</div><div class="line">function logCar(logMsg, callback) &#123;</div><div class="line">	process.nextTick(function() &#123;</div><div class="line">		callback(logMsg);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">var cars = [&quot;Ferrari&quot;, &quot;Porsche&quot;, &quot;Bugatti&quot;];</div><div class="line">// 循环 1，基本的回调函数</div><div class="line">for (var idx in cars) &#123;</div><div class="line">	var message = &quot;Saw a &quot; + cars[idx];</div><div class="line">	logCar(message, function() &#123;</div><div class="line">		console.log(&quot;Normal Callback: &quot; + message);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">// 循环 2，把消息作为 msg 参数传递的包装器函数函数</div><div class="line">for (var idx in cars) &#123;</div><div class="line">	var message = &quot;Saw a &quot; + cars[idx];</div><div class="line">	(function(msg) &#123;</div><div class="line">		logCar(msg, function() &#123;</div><div class="line">			console.log(&quot;Closure Callback: &quot; + msg);</div><div class="line">		&#125;);</div><div class="line">	&#125;)(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node callback_closure.js</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Closure Callback: Saw a Ferrari</div><div class="line">Closure Callback: Saw a Porsche</div><div class="line">Closure Callback: Saw a Bugatti</div></pre></td></tr></table></figure></p>
<h3 id="4-3-3-链式回调"><a href="#4-3-3-链式回调" class="headerlink" title="4.3.3 链式回调"></a>4.3.3 链式回调</h3><p>使用异步函数时，如果两个函数都在事件队列上，无法保证它们的运行顺序。最佳方法是让来自异步函数的回调在此调用该函数，<br>直到没有更多的工作要做，以执行链式回调。这样，异步函数永远不会在时间队列上超过一次。<br>以下代码中，条目列表被传递到函数 logCars()，然后异步函数 logCar() 被调用，并且 logCars() 函数作为当 logCar() 完成<br>时的回调函数。一次，同一时间只有一个版本的 logCar() 在事件队列上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// callback_chain.js：实现一个回调链，在此来自一个匿名函数的</div><div class="line">// 回调函数回调到最初的函数来遍历列表</div><div class="line">function logCar(car, callback) &#123;</div><div class="line">	console.log(&quot;Saw a %s&quot;, car);</div><div class="line">	if(cars.length) &#123;</div><div class="line">		process.nextTick(function() &#123;</div><div class="line">			callback();</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function logCars(cars) &#123;</div><div class="line">	var car = cars.pop();</div><div class="line">	logCar(car, function() &#123;</div><div class="line">		logCars(cars);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">var cars = [&quot;Ferrari&quot;, &quot;Porsche&quot;, &quot;Bugatti&quot;, &quot;Lamborghini&quot;, &quot;Aston Martin&quot;];</div><div class="line">logCars(cars);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node callback_chain.js</div><div class="line">Saw a Aston Martin</div><div class="line">Saw a Lamborghini</div><div class="line">Saw a Bugatti</div><div class="line">Saw a Porsche</div><div class="line">Saw a Ferrari</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/开始使用 Node.js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/开始使用 Node.js/" itemprop="url">开始使用 Node.js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T20:29:15+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-开始使用-Node-js"><a href="#3-开始使用-Node-js" class="headerlink" title="3 开始使用 Node.js"></a>3 开始使用 Node.js</h1><h2 id="3-2-Node-js-安装"><a href="#3-2-Node-js-安装" class="headerlink" title="3.2 Node.js 安装"></a>3.2 Node.js 安装</h2><h3 id="3-2-1-纵观-Node-js-安装位置"><a href="#3-2-1-纵观-Node-js-安装位置" class="headerlink" title="3.2.1 纵观 Node.js 安装位置"></a>3.2.1 纵观 Node.js 安装位置</h3><ul>
<li><strong>node：</strong> 该文件启动一个 Node.js JavaScript 引擎。如果你传递一个 JavaScript 文件的位置， Node.js 就执行该脚本。如果没有制定目标 JavaScript 文件，就会出来一个脚本提示符，可以利用它直接从控制台执行 JavaScript 代码。  </li>
<li><strong>npm：</strong> 你可以侍弄此命令来管理 Node.js 包。  </li>
<li><strong>node_modules：</strong> 此文件夹包含安装的Node.js 包。这些包作为扩展 node.js 功能的库。  </li>
</ul>
<h3 id="3-2-2-验证-Node-js-可执行文件"><a href="#3-2-2-验证-Node-js-可执行文件" class="headerlink" title="3.2.2 验证 Node.js 可执行文件"></a>3.2.2 验证 Node.js 可执行文件</h3><p>打开命令提示符，执行以下命令，这将弹出一个 Node.js 虚拟机：<br><code>node</code><br>接下来，执行以下命令，将 “Hello World” 写到屏幕上：<br><code>&gt;console.log(&quot;Hello World&quot;);</code><br>当你看到 “Hello World” 被写入控制台屏幕后，可以按 Ctrl+C 组合键退出控制台。<br>接下来，通过在命令提示符下执行以下命令来验证 npm 命令能正常工作：<br><code>npm version</code><br>你应该看到类似如下的输出：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123; censorify: &apos;0.1.1&apos;,  </div><div class="line">  npm: &apos;3.10.10&apos;,  </div><div class="line">  ares: &apos;1.10.1-DEV&apos;,  </div><div class="line">  http_parser: &apos;2.7.0&apos;,  </div><div class="line">  icu: &apos;58.2&apos;,  </div><div class="line">  modules: &apos;48&apos;,  </div><div class="line">  node: &apos;6.10.3&apos;,  </div><div class="line">  openssl: &apos;1.0.2k&apos;,  </div><div class="line">  uv: &apos;1.9.1&apos;,  </div><div class="line">  v8: &apos;5.1.281.101&apos;,  </div><div class="line">  zlib: &apos;1.2.11&apos; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-3-选择-Node-js-IDE"><a href="#3-2-3-选择-Node-js-IDE" class="headerlink" title="3.2.3 选择 Node.js IDE"></a>3.2.3 选择 Node.js IDE</h3><p>暂时用 MarkdwonPad2 ，仍然有些问题。计划用 WebStorm。  </p>
<h2 id="3-3-使用-Node-js-包"><a href="#3-3-使用-Node-js-包" class="headerlink" title="3.3 使用 Node.js 包"></a>3.3 使用 Node.js 包</h2><p>Node.js 框架最强大功能之一是能够轻松地使用 Node 包管理器（Node Packaged Manager，NPM）用额外的 Node 封装模块<br>（NPM）将其扩展。没错：在 Node.js 世界，NPM 意味着两种东西。本文将 Node 封装模块成为模块（Node Package Module，<br>module），而不是 NPM，以避免混乱。  </p>
<h3 id="3-3-1-什么是-Node-封装模块"><a href="#3-3-1-什么是-Node-封装模块" class="headerlink" title="3.3.1 什么是 Node 封装模块"></a>3.3.1 什么是 Node 封装模块</h3><p>Node 封装模块是一个打包的库，它可以很容易地在不同的项目中被共享、重用和安装。  </p>
<h3 id="3-3-2-了解-Node-包注册表"><a href="#3-3-2-了解-Node-包注册表" class="headerlink" title="3.3.2 了解 Node 包注册表"></a>3.3.2 了解 Node 包注册表</h3><p>Node 包注册表位于 <a href="http://npmjs.org。" target="_blank" rel="external">http://npmjs.org。</a>  </p>
<h3 id="3-3-3-使用-Node-包管理器"><a href="#3-3-3-使用-Node-包管理器" class="headerlink" title="3.3.3 使用 Node 包管理器"></a>3.3.3 使用 Node 包管理器</h3><p>Node 包管理器是一个命令行实用程序，它可以让你查找、安装、删除、发布，以及做与 Node 封装模块相关的其他很多东西。<br>Node 包管理器提供了 Node 包的注册表和开发环境之间的联系。  </p>
<h3 id="3-3-4-搜索-Node-封装模块"><a href="#3-3-4-搜索-Node-封装模块" class="headerlink" title="3.3.4 搜索 Node 封装模块"></a>3.3.4 搜索 Node 封装模块</h3><p>你可以直接在命令提示符下使用 npm search <search_string> 命令搜索在 Node 程序包注册表中的模块。  </search_string></p>
<h3 id="3-3-5-安装-Node-封装模块"><a href="#3-3-5-安装-Node-封装模块" class="headerlink" title="3.3.5 安装 Node 封装模块"></a>3.3.5 安装 Node 封装模块</h3><p>在应用程序中使用 Node 模块，它必须先被安装在 Node 可以找到它的地方。要安装 Node 模块，使用 npm install <module_name><br>命令下载 Node 模块到你的开发环境，并将其放置在 node_modules 文件夹中，在哪里运行 install 命令。  </module_name></p>
<h3 id="3-3-6-使用-package-json"><a href="#3-3-6-使用-package-json" class="headerlink" title="3.3.6 使用 package.json"></a>3.3.6 使用 package.json</h3><p>所用 Node 的模块必须在其根目录下包含一个 package.json 文件。package.json 是定义了一个模块，包括其依赖关系的一个<br>简单的JSON 文本文件。改文件可以包含多个不同的指令来告诉 Node 包管理器如何处理模块。<br>下面是一个包含名称、版本、描述和依赖关系的 package.json 文件的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;my_module&quot;,</div><div class="line">    &quot;version&quot;: &quot;0.1.0&quot;,</div><div class="line">    &quot;description&quot;: &quot;a simple node.js module&quot;,</div><div class="line">    &quot;dependencies&quot;: &#123;</div><div class="line">        &quot;express&quot;: &quot;latest&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 package.json 文件中必须的指令只是名称和版本；其余取决于你想要包含什么。<br>从包的根目录运行下面的命令，express 模块会自动安装：<br><code>npm install</code><br>请注意，npm install 命令没有指定任何模块。这是因为 npm 在默认情况下会蟾照一个 package.json 文件。需要增加额外模块，<br>只要将这些模块添加到依赖指令中，然后再次运行 npm install。  </p>
<h2 id="3-4-创建-Node-js-应用程序"><a href="#3-4-创建-Node-js-应用程序" class="headerlink" title="3.4 创建 Node.js 应用程序"></a>3.4 创建 Node.js 应用程序</h2><p>本节中，将会创建自己的 Node 封装模块，然后把该模块在一个 Node.js 应用程序中作为库来使用。  </p>
<h3 id="3-4-1-创建-Node-js-模块封装"><a href="#3-4-1-创建-Node-js-模块封装" class="headerlink" title="3.4.1 创建 Node.js 模块封装"></a>3.4.1 创建 Node.js 模块封装</h3><p>建立一个 Node.js 封装模块 censorify，该模块接受文本并用星号代替某些特定的单词。  </p>
<ol>
<li>创建名为…/censorify 的项目文件夹。这将是此包的根目录。    </li>
<li>在该文件夹中创建 censortext.js 文件。  </li>
<li>添加以下代码  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var censoredWords = [&quot;sad&quot;, &quot;bad&quot;, &quot;mad&quot;];</div><div class="line">var customCensoredWords = [];</div><div class="line">function censor(inStr) &#123;</div><div class="line">    for (idx in censoredWords) &#123;</div><div class="line">        inStr = inStr.replace(censoredWords[idx], &quot;****&quot;);</div><div class="line">    &#125;</div><div class="line">    for (idx in customCensoredWords) &#123;</div><div class="line">        inStr = inStr.replace(customCensoredWords[idx], &quot;****&quot;);</div><div class="line">    &#125;</div><div class="line">    return inStr;</div><div class="line">&#125;</div><div class="line">function addCensoredWord(word) &#123;</div><div class="line">    customCensoredWords.push(word);</div><div class="line">&#125;</div><div class="line">function getCensoredWords() &#123;</div><div class="line">    return censoredWords.concat(customCensoredWords);</div><div class="line">&#125;</div><div class="line">// 导出函数</div><div class="line">exports.censor = censor;</div><div class="line">exports.addCensoredWord = addCensoredWord;</div><div class="line">exports.getCensoredWords = getCensoredWords;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>导出 censor 是使用这个模块的 Node.js 应用程序能够访问 censor() 函数所需的，对于其他两个函数也是如此。  </p>
<ol>
<li>要生成 Node.js 封装模块，需要 package.json 文件，在 …/censorify 文件夹中创建 package.json<br>文件。添加类似以下代码：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;author&quot;: &quot;Brad Dayley&quot;,</div><div class="line">  &quot;name&quot;: &quot;censorify&quot;,</div><div class="line">  &quot;version&quot;: &quot;0.1.1&quot;,</div><div class="line">  &quot;description&quot;: &quot;Censors words out of text&quot;,</div><div class="line">  &quot;main&quot;: &quot;censortext&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;&#125;,</div><div class="line">  &quot;engines&quot;: &#123;</div><div class="line">    &quot;node&quot;: &quot;*&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>具体而言，至少需要添加 name（名称）、version（版本）和 main 指令。main 指令需要时被加载的主 JavaScript<br>的模块的名称，本例中是 censortext。注意，.js 不是必需的：Node.js 会自动搜索 .js 扩展名。  </p>
<ol>
<li>在 …/censorify 文件夹中创建 README.md 的文件，填写任意自述说明。  </li>
<li>在控制台导航到 …/censorify 文件夹，执行以下命令来建立本地封装模块：<br><code>npm pack</code><br>npm pack 命令会在…/censorify 文件夹中生成 censorify-0.1.1.tgz 文件。这是你的第一个 Node.js<br>封装模块。   </li>
</ol>
<h3 id="3-4-2-将-Node-js-封装模块发布到-NPM-注册表"><a href="#3-4-2-将-Node-js-封装模块发布到-NPM-注册表" class="headerlink" title="3.4.2 将 Node.js 封装模块发布到 NPM 注册表"></a>3.4.2 将 Node.js 封装模块发布到 NPM 注册表</h3><h3 id="3-4-3-在-Node-js-应用程序中使用-Node-js-封装模块"><a href="#3-4-3-在-Node-js-应用程序中使用-Node-js-封装模块" class="headerlink" title="3.4.3 在 Node.js 应用程序中使用 Node.js 封装模块"></a>3.4.3 在 Node.js 应用程序中使用 Node.js 封装模块</h3><p>很简单，只要将模块安装到你的应用程序的结构中，再用 require() 方法加载该模块。<br>require() 方法接受任何已安装的模块名或位于文件系统上的 .js 文件路径。例如：<br>require(“censorify”)<br>require(“./lib/utils.js”)<br>.js 文件扩展名是可选的。如果它被省略，那么 Node.js 将搜索它。<br>按以下步骤操作：  </p>
<ol>
<li>创建项目文件夹 …/readwords，以此为根目录。    </li>
<li>从根目录的命令提示符下，使用以下命令来安装先前创建的 censorify-0.1.1.tgz 包 censorify 模块：<br><code>npm install ../censorify/censorify-0.1.1.tgz</code>  </li>
<li>或者，如果你已经发布了 censorify 模块，可使用标准命令从 NPM 注册表下载和安装：<br><code>npm install censorify</code>  </li>
<li>确认名为 node_modules 的文件夹，连同 censorify 的子文件夹应被创建。  </li>
<li>创建 …/readwords/readwords.js 文件。  </li>
<li><p>写入以下代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// readwords.js：一个显示文本时加载 censorify 模块的 Node.js 应用程序</div><div class="line">var censor = require(&quot;censorify&quot;);</div><div class="line">console.log(censor.getCensoredWords());</div><div class="line">console.log(censor.censor(&quot;Some very sad, bad and mad text&quot;));</div><div class="line">censor.addCensoredWord(&quot;gloomy&quot;);</div><div class="line">console.log(censor.getCensoredWords());</div><div class="line">console.log(censor.censor(&quot;A very gloomy day.&quot;));</div></pre></td></tr></table></figure>
</li>
<li><p>以下命令运行：<br><code>node readwords.js</code><br>输出如下，注意，审查词都被替换为 <em>**</em>，而且新的审查词 gloomy 被加入到 censorify 模块实例 sensor 中。  </p>
<pre><code>$ node readwords.js
[ &apos;sad&apos;, &apos;bad&apos;, &apos;mad&apos; ]
Some very ****, **** and **** text
[ &apos;sad&apos;, &apos;bad&apos;, &apos;mad&apos;, &apos;gloomy&apos; ]
A very **** day.
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/项目经理如何对接需求会议总结_20170621/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/21/项目经理如何对接需求会议总结_20170621/" itemprop="url">项目经理如何对接需求会议总结_20170621</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T20:44:43+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天下午开了关于“项目经理如何对接需求”的会议，受益良多，简单梳理一下。   </p>
<h3 id="1-0-目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？"><a href="#1-0-目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？" class="headerlink" title="1.0 目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？"></a>1.0 目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？</h3><h5 id="（1）无纸化“软件”"><a href="#（1）无纸化“软件”" class="headerlink" title="（1）无纸化“软件”"></a>（1）无纸化“软件”</h5><p>脱离纸张…  </p>
<h5 id="（2）流程化软件"><a href="#（2）流程化软件" class="headerlink" title="（2）流程化软件"></a>（2）流程化软件</h5><p>ERP 系统等… </p>
<h5 id="（3）智能化系统"><a href="#（3）智能化系统" class="headerlink" title="（3）智能化系统"></a>（3）智能化系统</h5><p>根据企业存在问题，提出解决方案…  </p>
<p>主要做前两种，第三种要求较高，是我们努力的目标。</p>
<h3 id="2-0-对于需求，我们分为哪些，同时对应几个阶段？"><a href="#2-0-对于需求，我们分为哪些，同时对应几个阶段？" class="headerlink" title="2.0 对于需求，我们分为哪些，同时对应几个阶段？"></a>2.0 对于需求，我们分为哪些，同时对应几个阶段？</h3><p>需求分为业务需求和开发需求。业务需求是在与客户交流的阶段，通过各种方式挖掘痛点，找出客户真正需要的；<br>开发需求是在开发阶段，根据业务需求制定的关于系统开发方方面面的，细节性的功能的需求。  </p>
<h3 id="3-0-如何挖掘用户的业务需求"><a href="#3-0-如何挖掘用户的业务需求" class="headerlink" title="3.0 如何挖掘用户的业务需求"></a>3.0 如何挖掘用户的业务需求</h3><h4 id="3-1-客户在你面前，你是否存在不知如何入手？"><a href="#3-1-客户在你面前，你是否存在不知如何入手？" class="headerlink" title="3.1 客户在你面前，你是否存在不知如何入手？"></a>3.1 客户在你面前，你是否存在不知如何入手？</h4><p>进行“破冰”，让客户打开话匣子，聊起来，双方不再尴尬，再过渡到深入挖掘客户的需求。 </p>
<p>不知如何入手原因：<br>（1） 知道要讲什么，但性格原因，不善于打交道<br>（2） 擅长打交道，但不知道要讲什么<br>（3） 不知道要什么，不擅长打交道<br>一些解决方案：<br>大声读文章 –》对着镜子背诵，观察面部表情 –》去街上进行调查问卷    </p>
<h4 id="3-2-客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？"><a href="#3-2-客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？" class="headerlink" title="3.2 客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？"></a>3.2 客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？</h4><p>客户可能很啰嗦，说不到重点。我们不能表现出不耐烦，不能让客户看出我们觉得他很“傻逼”，这不仅表现出我们缺乏基本的礼仪，有损个人形象，而且会损害本公司的形象，不利于与客户的进一步交流。我们应当认真倾听，从“啰嗦话”中挖掘客户真实需求。若能力足够，尽可能礼貌地引导客户到正确的方向。   </p>
<h4 id="3-3-你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？"><a href="#3-3-你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？" class="headerlink" title="3.3 你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？"></a>3.3 你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？</h4><p>类似于 3.2<br>了解客户所在行业情况，脑海中要有系统的雏形，再与客户进行系统可行性相关的、各种实现细节的论证。  </p>
<h4 id="3-4-你是不是觉得害怕自己提出的东西被否定？"><a href="#3-4-你是不是觉得害怕自己提出的东西被否定？" class="headerlink" title="3.4 你是不是觉得害怕自己提出的东西被否定？"></a>3.4 你是不是觉得害怕自己提出的东西被否定？</h4><p>用于提出自己的意见，有上级领导、公司做你的后盾，但不能过。东西被否定，也是好现象，说明客户知道自己想要什么。对接需求是双向的，相互交流，相互反馈，利于工作进展。  </p>
<h4 id="3-5-你觉得还有什么？"><a href="#3-5-你觉得还有什么？" class="headerlink" title="3.5 你觉得还有什么？"></a>3.5 你觉得还有什么？</h4><h4 id="3-6-你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？"><a href="#3-6-你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？" class="headerlink" title="3.6 你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？"></a>3.6 你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？</h4><p>这个需要大量项目经验的积累，经验不足的情况下，寻找大量优秀的系统，分析其需求，内化为自身知识。  </p>
<h4 id="业务需求最重要的是什么？"><a href="#业务需求最重要的是什么？" class="headerlink" title="业务需求最重要的是什么？"></a>业务需求最重要的是什么？</h4><p>将实际需求、客户的真实需求融入到系统开发之中。  </p>
<h3 id="4-0-根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？"><a href="#4-0-根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？" class="headerlink" title="4.0 根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？"></a>4.0 根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？</h3><h4 id="4-1-脱离无纸化的“软件”，我们要注意什么？"><a href="#4-1-脱离无纸化的“软件”，我们要注意什么？" class="headerlink" title="4.1 脱离无纸化的“软件”，我们要注意什么？"></a>4.1 脱离无纸化的“软件”，我们要注意什么？</h4><p>比较“简单粗暴”，可能只需要将单据融合到系统中就可以，风险、周期可控。但是要注意：单据格式正确、单据数据齐全，确保单据是我们系统所需要的。  </p>
<h4 id="4-2-有一定业务流程甚至是-ERP-类型的流程性的系统，我们要注意什么？"><a href="#4-2-有一定业务流程甚至是-ERP-类型的流程性的系统，我们要注意什么？" class="headerlink" title="4.2 有一定业务流程甚至是 ERP 类型的流程性的系统，我们要注意什么？"></a>4.2 有一定业务流程甚至是 ERP 类型的流程性的系统，我们要注意什么？</h4><p>尤其注意体量大的、多部门的公司，甚至集团，业务流程极其繁杂。<br>（1）没有专门的负责人，可能需要与很多领导协调，不利于工作进展。建议对方有单一对接人，或者说能拍板的人。<br>（2）需求对接周期很长，对接前请示领导。<br>（3）客户需求变更频繁。对于已经确认的需求，我们最好立马让客户在需求文档或者流程文档上签字，以防以后需求变更导致的种种问题。</p>
<h2 id="关于项目经理如何带项目"><a href="#关于项目经理如何带项目" class="headerlink" title="关于项目经理如何带项目"></a>关于项目经理如何带项目</h2><p>检验控制<br>（1）让所有人理解需求，且能复述出来；<br>（2）看页面，指出存在问题，并要求后面的模块遵循相同要求；<br>（3）看代码，团队统一代码规范，团队成员间互相阅读无障碍；<br>周期控制<br>开发周期 + 测试周期 + 改 bug 周期 </p>
<h2 id="关于项目-A-存在的问题及反思"><a href="#关于项目-A-存在的问题及反思" class="headerlink" title="关于项目 A 存在的问题及反思"></a>关于项目 A 存在的问题及反思</h2><p>（1）病态的合同关系<br>客户甲与公司乙签订合同，项目有公司乙完成；公司乙再与公司丙签订合同，把项目外包给公司丙做。<br>公司乙所理解的需求与客户甲的真实需求有所偏差。公司丙理解的需求与公司乙有所偏差，与客户需求则偏差更大。需求问题是个大坑。  </p>
<p>尽量不做二包，最好能直接与客户交流。</p>
<p>（2）初期没有让客户确认需求<br>仅靠口头约定，客户可能会出尔反尔，或者强加各种额外需求。  </p>
<p>为避免这种情况，对于已经确认的需求，我们最好立马让客户在需求文档或者流程文档上签字。如果有需求变化，增加工作周期，提高项目价格。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/JFinal Weixin 学习笔记（9）-- 微信账号二维码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/24/JFinal Weixin 学习笔记（9）-- 微信账号二维码/" itemprop="url">JFinal Weixin 学习笔记（9）-- 微信账号二维码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T17:02:43+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><hr>
<h4 id="生成带参数的二维码-QrcodeApi"><a href="#生成带参数的二维码-QrcodeApi" class="headerlink" title="生成带参数的二维码 QrcodeApi"></a>生成带参数的二维码 <code>QrcodeApi</code></h4><p>为了满足用户渠道推广分析和用户帐号绑定等场景的需要，公众平台提供了生成带参数二维码的接口。使用该接口可以获得多个带不同场景值的二维码，用户扫描后，公众号可以接收到事件推送。<br>1、临时二维码，是有过期时间的，最长可以设置为在二维码生成后的30天（即2592000秒）后过期，但能够生成较多数量。临时二维码主要用于帐号绑定等不要求二维码永久保存的业务场景  。<br>2、永久二维码，是无过期时间的，但数量较少（目前为最多10万个）。永久二维码主要用于适用于帐号绑定、用户来源统计等场景。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 创建临时二维码</div><div class="line"> * @param expireSeconds 该二维码有效时间，以秒为单位。 最大不超过604800（即7天）。</div><div class="line"> * @param sceneId 场景值ID，临时二维码时为32位非0整型</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createTemporary(int expireSeconds, int sceneId);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建永久二维码</div><div class="line"> * @param sceneId 场景值ID，永久二维码时最大值为100000（目前参数只支持1--100000）</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createPermanent(int sceneId);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建永久二维码</div><div class="line"> * @param sceneStr 场景值ID（字符串形式的ID），字符串类型，长度限制为1到64，仅永久二维码支持此字段</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createPermanent(String sceneStr);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过ticket换取二维码地址，拼接二维码连接，可直接通过&lt;img&gt;显示</div><div class="line"> * @param ticket 换取二维码参数</div><div class="line"> * @return String url</div><div class="line"> */</div><div class="line">public static String getShowQrcodeUrl(String ticket);</div></pre></td></tr></table></figure>
<h4 id="长链接转短链接接口-ShorturlApi"><a href="#长链接转短链接接口-ShorturlApi" class="headerlink" title="长链接转短链接接口 ShorturlApi"></a>长链接转短链接接口 <code>ShorturlApi</code></h4><p>将一条长链接转成短链接。<br>主要使用场景： 开发者用于生成二维码的原链接（商品、支付二维码等）太长导致扫码速度和成功率下降，将原长链接通过此接口转成短链接再生成二维码将大大提升扫码速度和成功率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 长链接转短链接接口</div><div class="line"> * @param longUrl 需要转换的长链接，支持http://、https://、weixin://wxpay 格式的url</div><div class="line"> * @return ApiResult 短连接信息</div><div class="line"> */</div><div class="line">public static ApiResult getShortUrl(String longUrl);</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><hr>
<h4 id="WeixinApiController-java"><a href="#WeixinApiController-java" class="headerlink" title="WeixinApiController.java"></a>WeixinApiController.java</h4><pre><code>// 生成带参数的二维码
// 创建临时二维码
public void createTemporary(){
    ApiResult apiResult = null;
    // 过期时间
    int expireSeconds = 604800;
    // 场景值
    int sceneId = 111;
    // 生成临时二维码
    apiResult = QrcodeApi.createTemporary(expireSeconds, sceneId);
    // 获取 ticket,拼接 url 
    JSONObject jsonObjec = JSONObject.parseObject(apiResult.getJson());
    String ticket = jsonObjec.getString(&quot;ticket&quot;);
    String outMessage = &quot;apiResult: &quot; + apiResult.getJson() +&quot;\n&quot;
            + &quot;QrcodeUrl: &quot; + QrcodeApi.getShowQrcodeUrl(ticket);
    renderText(outMessage);
}

// 长链接转短链接接口 ShorturlApi
public void getShortUrl(){
    ApiResult apiResult = null;
    String longUrl = &quot;https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQHT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyemlhcVFPa0JmUWoxM01GRk5wMW0AAgRw7x9ZAwSAOgkA&quot;;
    apiResult = ShorturlApi.getShortUrl(longUrl);
    JSONObject jsonObjec = JSONObject.parseObject(apiResult.getJson());
    String shorUrl = jsonObjec.getString(&quot;short_url&quot;);
    String outMessage = &quot;apiResult: &quot; + apiResult.getJson() +&quot;\n&quot;
            + &quot;longUrl: &quot; + longUrl + &quot;\n\n&quot;
            + &quot;shorUrl: &quot; + shorUrl;
    renderText(outMessage);
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;h3&gt;微信账号二维码&lt;/h3&gt;
点击&lt;a href=&apos;/api/createTemporary&apos;&gt;【创建临时二维码】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/getShortUrl&apos;&gt;【长链接转短链接】&lt;/a&gt;&lt;br&gt;
</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><hr>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9f40e18fe79d47a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试页面">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9d519c902e908093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建临时二维码"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-7a07dbca0607d4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长链接转短链接">  </p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/zyw_java/article/details/54024672" target="_blank" rel="external">微信开发之推广支持</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E5%B8%90%E5%8F%B7%E7%AE%A1%E7%90%86#长链接转短链接接口shorturlapi" target="_blank" rel="external">jfinal-weixin-wiki 帐号管理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/23/JFinal Weixin 学习笔记（8）-- 微信自定义菜单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/JFinal Weixin 学习笔记（8）-- 微信自定义菜单/" itemprop="url">JFinal Weixin 学习笔记（8）-- 微信自定义菜单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-23T11:05:43+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="自定义菜单接口"><a href="#自定义菜单接口" class="headerlink" title="自定义菜单接口"></a>自定义菜单接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 查询菜单</div><div class="line"> */</div><div class="line">MenuApi.getMenu();</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建菜单</div><div class="line"> */</div><div class="line">MenuApi.createMenu(String jsonStr);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 自定义菜单删除接口</div><div class="line"> */</div><div class="line">MenuApi.deleteMenu();</div></pre></td></tr></table></figure>
<h4 id="WeinxinApiController-java"><a href="#WeinxinApiController-java" class="headerlink" title="WeinxinApiController.java"></a>WeinxinApiController.java</h4><p><code>createMenu(String jsonStr)</code> 接受 json 格式的字符串，我们根据微信技术文档拼接自定义菜单字符串：</p>
<pre><code>/**
 * 创建菜单
 */
public void createMenu() {
    String path = Constants.HOST;
    String jsonstr = &quot;{&quot; +
            &quot;    \&quot;button\&quot;: [&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单1\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单11\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单12\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单13\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单14\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单15\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        },&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单2\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;测　　试\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api/index\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;click\&quot;,\&quot;type\&quot;: \&quot;click\&quot;,\&quot;key\&quot;: \&quot;22\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单23\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;百度\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;http://www.baidu.com\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单25\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        },&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单3\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot;+
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单31\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单32\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单33\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单34\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单35\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        }&quot; +
            &quot;    ]&quot; +
            &quot;}&quot;;
    ApiResult apiResult = MenuApi.createMenu(jsonstr);
    renderText(apiResult.getJson());
}
</code></pre><p>自定义菜单接口可实现多种类型按钮，详见：<a href="https://mp.weixin.qq.com/wiki" target="_blank" rel="external">微信公众平台技术文档</a>。<br>这里使用了两种：<br>1、<code>click</code>：点击推事件用户点击 click 类型按钮后，微信服务器会通过消息接口推送消息类型为 event 的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的 key 值，开发者可以通过自定义的 key 值与用户进行交互；<br>2、<code>view</code>：跳转 URL 用户点击 view 类型按钮后，微信客户端将会打开开发者在按钮中填写的网页 URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</p>
<p><code>getMenu()</code> 方法，查询自定义菜单：</p>
<pre><code>/**
 * 查询菜单
 */
public void getMenu() {
    ApiResult apiResult = MenuApi.getMenu();
    renderText(apiResult.getJson());
}
</code></pre><h4 id="WeixinMsgController-java"><a href="#WeixinMsgController-java" class="headerlink" title="WeixinMsgController.java"></a>WeixinMsgController.java</h4><p><code>processInMenuEvent(InMenuEvent inMenuEvent)</code>  方法接受菜单中 <code>click</code> 类型按钮的点击事件</p>
<pre><code>// 自定义菜单事件
@Override
protected void processInMenuEvent(InMenuEvent inMenuEvent) {
    OutTextMsg outMsg = new OutTextMsg(inMenuEvent);
    outMsg.setContent(&quot;processInMenuEvent() 方法测试成功&quot;);
    render(outMsg);
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;h3&gt;自定义菜单&lt;/h3&gt;
点击&lt;a href=&apos;/api/createMenu&apos;&gt;【创建自定义菜单】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/getMenu&apos;&gt;【获取自定义菜单】&lt;/a&gt;&lt;br&gt;
</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>点击创建菜单，微信客户端不会立马刷新。想立马看到效果，可以取消关注再关注。<br>微信菜单：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-9d135134a26c0b34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一级菜单"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-989b1cdda1ae9bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二级菜单"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9db99bf82a64d269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三级菜单"></p>
<p>点击 <code>click22</code><br><img src="http://upload-images.jianshu.io/upload_images/5343805-1f2158641ce18284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>新增了“测试”按钮，可以直接跳转主页面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-70dcadb1095aebd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试页面"></p>
<p>点击“获取自定义菜单”<br>得到 json 格式的菜单数据：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-72c4afa586b48cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="菜单数据"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/2d740d059fa0" target="_blank" rel="external">JFinal Weixin 学习笔记（9）– 微信账号二维码</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/zyw_java/article/details/61415114" target="_blank" rel="external">微信公众号开发之自定义菜单</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">jfinal-weixin-wiki 自定义菜单接口</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/23/JFinal Weixin 学习笔记（7）-- 微信用户管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/JFinal Weixin 学习笔记（7）-- 微信用户管理/" itemprop="url">JFinal Weixin 学习笔记（7）-- 微信用户管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-23T11:04:43+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="GroupsApi-接口"><a href="#GroupsApi-接口" class="headerlink" title="GroupsApi 接口"></a>GroupsApi 接口</h4><p>开发者可以使用 <code>GroupsApi</code> 接口，对公众平台的分组进行查询、创建、修改、删除等操作。  </p>
<p>相关方法：<br><code>create(String name)</code> 方法：<br>创建分组，一个公众账号，最多支持创建 100 个分组<br>参数 name： 分组名  </p>
<p><code>get()</code> 方法：<br>查询所有分组  </p>
<p><code>getId(String openid)</code> 方法：<br>通过用户的OpenID查询其所在的 GroupID<br>参数 openid： 普通用户的标识，对当前开发者帐号唯一  </p>
<p><code>update(int id, String name)</code> 方法：<br>修改分组名<br>参数 id：分组 id，由微信分配<br>参数 name： 分组名字（30 个字符以内）  </p>
<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>修改 <code>WeixinApiController.java</code>   </p>
<pre><code>// 获取用户分组列表
public void getGroups () {
    ApiResult apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 创建分组
public void createGroup () {
    Date date = new Date();
    GroupsApi.create(date.toString());
    ApiResult apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 删除分组
public void deleteGroup () {
    ApiResult apiResult = null;
    // 获取当前用户分组列表
    apiResult = GroupsApi.get();
    // 结果转化成 JSONArray 对象
    JSONArray jsonArray = JSON.parseObject(apiResult.toString()).getJSONArray(&quot;groups&quot;);
    // 删除 id &gt;= 100 的用户分组
    for(int i = 0, size = jsonArray.size(); i &lt; size; i++){
        // 转化成 JSONObject 对象
        JSONObject jsonObject = (JSONObject) jsonArray.get(i);
        // 获取分组 id
        int id = jsonObject.getInteger(&quot;id&quot;);
        if (id &gt;= 100){
            // 删除用户分组
            GroupsApi.delete(id);
        }
    }
    // 获取删除后的用户数组
    apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 修改分组名
public void updateGroup(){
    String msg = new String();

    // 更新前
    GroupsApi.create(&quot;原分组名&quot;);
    ApiResult apiResult = GroupsApi.get();
    msg += &quot;更新前： &quot; + apiResult.toString() + &quot;\n&quot;;

    // 结果转化成 JSONArray 对象
    JSONArray jsonArray = JSON.parseObject(apiResult.toString()).getJSONArray(&quot;groups&quot;);
    // 更新用户分组
    for(int i = 0, size = jsonArray.size(); i &lt; size; i++){
        // 转化成 JSONObject 对象
        JSONObject jsonObject = (JSONObject) jsonArray.get(i);
        // 获取分组名
        String origin = jsonObject.getString(&quot;name&quot;);
        if (&quot;原分组名&quot;.equals(origin)){
            // 更新用户分组
            GroupsApi.update(jsonObject.getInteger(&quot;id&quot;), &quot;新分组名&quot;);
            break;
        }
    }

    // 更新后
    msg += &quot;更新后： &quot; + GroupsApi.get().toString() + &quot;\n&quot;;
    renderText(msg);
}
</code></pre><p>修改 <code>index.html</code> </p>
<pre><code>&lt;h3&gt;用户管理&lt;/h3&gt;
点击&lt;a href=&apos;/api/getGroups&apos;&gt;【获取用户分组列表】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/createGroup&apos;&gt;【创建用户分组】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/deleteGroup&apos;&gt;【删除用户分组】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/updateGroup&apos;&gt;【修改用户分组名】&lt;/a&gt;&lt;br&gt;
</code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>主页面：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-250d7a21f6ea6191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页">  </p>
<p>获取用户分组列表：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-8c170d7c51dac536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取用户分组列表"></p>
<p>创建用户分组：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-1f12e305ac37050f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建用户分组"></p>
<p>删除用户分组：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-154a6af55b6672cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除用户分组"></p>
<p>修改用户分组名：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-4156f14aba45b9df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改用户分组名"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/0039f943f91d" target="_blank" rel="external">JFinal Weixin 学习笔记（8）– 微信自定义菜单</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86" target="_blank" rel="external">jfinal-weixin-wiki 用户管理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/20/JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据/" itemprop="url">JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T09:06:43+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="利用-AccessTokenApi-获取-access-token"><a href="#利用-AccessTokenApi-获取-access-token" class="headerlink" title="利用 AccessTokenApi 获取 access_token"></a>利用 AccessTokenApi 获取 access_token</h4><p><code>access_token</code> 是公众号的全局唯一票据，公众号调用各接口时都需使用 <code>access_token</code>。<br><code>jfinal-wein</code> 提供了 <code>AccessTokenApi</code> 接口，其中:<br><code>getAccessTokenStr()</code> 方法直接获取 <code>access_token</code> 字符串，方便使用；<br><code>getAccessToken()</code> 方法从缓存中获取 <code>access token</code>，如果未取到或者 <code>access token</code> 不可用则先更新再获取。  </p>
<h4 id="修改-WeixinApiController-java"><a href="#修改-WeixinApiController-java" class="headerlink" title="修改 WeixinApiController.java"></a>修改 WeixinApiController.java</h4><pre><code>// 获取 access token 字符串
public void getAccessTokenStr() {
    String accessTokenStr = AccessTokenApi.getAccessTokenStr();
    renderText(accessTokenStr);
}

// 获取 access token
public void getAccessToken() {
    AccessToken accessToken = AccessTokenApi.getAccessToken();
    renderText(accessToken.getAccessToken());
}
</code></pre><h4 id="修改-index-html"><a href="#修改-index-html" class="headerlink" title="修改 index.html"></a>修改 index.html</h4><pre><code>&lt;body&gt;
    &lt;h1&gt;欢迎来到主页&lt;/h1&gt;
    &lt;h3&gt;获取接口调用凭据&lt;/h3&gt;
    点击&lt;a href=&apos;/api/getAccessTokenStr&apos;&gt;【获取 access token 字符串】&lt;/a&gt;&lt;br&gt;
    点击&lt;a href=&apos;/api/getAccessToken&apos;&gt;【获取 access token】&lt;/a&gt;&lt;br&gt;
&lt;/body&gt;
</code></pre><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p>打开主页面    </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-f41c64286c149d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页面"></p>
<p>点击页面链接<br>微信服务器会返回 <code>access_token</code>，如图：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-457cd62b7f248b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信服务器返回的 access_token"></p>
<h4 id="获取微信服务器-IP-地址"><a href="#获取微信服务器-IP-地址" class="headerlink" title="获取微信服务器 IP 地址"></a>获取微信服务器 IP 地址</h4><p>如果公众号基于安全等考虑，需要获知微信服务器的 IP 地址列表，以便进行相关限制。<br>可以通过 <code>CallbackIpApi</code> 接口的 <code>getCallbackIp()</code> 方法获得微信服务器 IP 地址列表。<br>同上，修改 <code>WeixinApiController.java</code> 与 <code>index.html</code> 文件：    </p>
<pre><code>// 获取微信服务器IP地址
public void getCallbackIp() {
    ApiResult apiResult = CallbackIpApi.getCallbackIp();
    renderText(apiResult.toString());
}

// index.html 页面添加链接
点击&lt;a href=&apos;/api/getCallbackIp&apos;&gt;【获取微信服务器 IP 地址】&lt;/a&gt;&lt;br&gt;
</code></pre><p>运行结果：     </p>
<pre><code>// 微信服务器 IP 地址， IP 地址很多，多余结果已略去
{&quot;ip_list&quot;:[&quot;101.226.62.77&quot;,&quot;101.226.62.78&quot;&quot;]}
</code></pre><hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/061ad5a23e1f" target="_blank" rel="external">JFinal Weixin 学习笔记（7）– 微信用户管理</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%87%AD%E6%8D%AE" target="_blank" rel="external">jfinal-weixin-wiki 获取接口调用凭据</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/JFinal Weixin 学习笔记（5）-- 微信页面跳转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/JFinal Weixin 学习笔记（5）-- 微信页面跳转/" itemprop="url">JFinal Weixin 学习笔记（5）-- 微信页面跳转</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-18T16:42:43+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="http://upload-images.jianshu.io/upload_images/5343805-568813dea75afbc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构">  </p>
<h4 id="WeixinApiController"><a href="#WeixinApiController" class="headerlink" title="WeixinApiController"></a>WeixinApiController</h4><p><code>WeixinApiController</code> 继承 <code>ApiController</code> ，所有使用 Api 的 controller 都需要继承此类。<br>目前没有使用 jfinal-weixin 接口，只是简单地跳转到主页。</p>
<pre><code>package com.nancarp.controller;

import com.jfinal.weixin.sdk.api.ApiConfig;
import com.jfinal.weixin.sdk.jfinal.ApiController;
import com.nancarp.utils.WeixinUtil;

public class WeixinApiController extends ApiController {

    /**
     * 如果要支持多公众账号，只需要在此返回各个公众号对应的 ApiConfig 对象即可 可以通过在请求 url 中挂参数来动态从数据库中获取
     * ApiConfig 属性值
     */
    @Override
    public ApiConfig getApiConfig() {
        return WeixinUtil.getApiConfig();
    }

    // 主页
    public void index(){
        render(&quot;index.html&quot;);
    }

}
</code></pre><h4 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h4><p><code>Constants</code> 类保存项目中用到的常量</p>
<pre><code>package com.nancarp.utils;

import com.jfinal.kit.PropKit;

public class Constants {
    // 获取域名
    public static String host = PropKit.get(&quot;host&quot;);

}
</code></pre><h4 id="WeixinConfig-增加路由"><a href="#WeixinConfig-增加路由" class="headerlink" title="WeixinConfig 增加路由"></a>WeixinConfig 增加路由</h4><pre><code>@Override
public void configRoute(Routes me) {
    // HelloWorld 路由
    me.add(&quot;/hello&quot;,HelloWorldController.class);
    // 接收用户消息和发送消息
    me.add(&quot;/msg&quot;, WeixinMsgController.class);
    // 操作微信接口
    me.add(&quot;/api&quot;, WeixinApiController.class,&quot;/api&quot;);
}
</code></pre><h4 id="修改-WeixinMsgController"><a href="#修改-WeixinMsgController" class="headerlink" title="修改 WeixinMsgController"></a>修改 WeixinMsgController</h4><p><code>url</code>  要以 <code>http://</code> 或 <code>https://</code> 开头，否则微信返回的信息只是单纯的文本。</p>
<pre><code>@Override
protected void processInTextMsg(InTextMsg inTextMsg) {
    // 文本内容
    String msgContent = inTextMsg.getContent().trim();
    // 回复主页链接
    if (&quot;1&quot;.equals(msgContent) || &quot;主页&quot;.equals(msgContent)){
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        String url = Constants.host + &quot;/api/index&quot;;
        String urlStr = &quot;&lt;a href=\&quot;&quot;+url+&quot;\&quot;&gt;点击跳转主页&lt;/a&gt;&quot;;
        outMsg.setContent(urlStr);
        render(outMsg);
    } else {
        // 其它文本消息直接返回原值
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        outMsg.setContent(&quot;\t文本消息已成功接收，内容为： &quot; + inTextMsg.getContent());
        render(outMsg);
    }
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;主页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;欢迎来到主页&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>不出意外，将会得到如下结果：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-36366efdc5f74778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回复消息"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-c579c9fbffedc9e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/cfb13d02465f" target="_blank" rel="external">JFinal Weixin 学习笔记（6）– 获取微信接口调用凭据</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.jianshu.com/p/6e8caa616577" target="_blank" rel="external">微信公众号开发之如何实现消息交互</a><br><a href="http://www.jfinal.com/project/2" target="_blank" rel="external">JFinal Weixin 极速开发 SDK</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/JFinal Weixin 学习笔记（4）-- 实现微信信息交互/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/JFinal Weixin 学习笔记（4）-- 实现微信信息交互/" itemprop="url">JFinal Weixin 学习笔记（4）-- 实现微信信息交互</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-18T13:42:43+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="http://upload-images.jianshu.io/upload_images/5343805-cbd15bd39f5857bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构">    </p>
<h4 id="WeixinMsgController"><a href="#WeixinMsgController" class="headerlink" title="WeixinMsgController"></a>WeixinMsgController</h4><p> <code>WixinMsgController</code>  继承自 <code>MsgControllerAdapter</code>，后者对 <code>MsgController</code> 的部分方法提供了默认实现，以便开发者不去关注 <code>MsgController</code> 中不需要处理的抽象方法，节省代码量。<br><code>getApiConfig()</code> 方法从 <code>a_little_config.txt</code> 文件中读取配置信息。<br><code>processInTextMsg()</code> 方法接受用户在微信中输入的文本信息，并对此作出相关回应。<br>现在我们实现最简单的功能，直接返回用输入的文本信息。  </p>
<pre><code>package com.nancarp.controller;

import com.jfinal.weixin.sdk.api.ApiConfig;
import com.jfinal.weixin.sdk.jfinal.MsgControllerAdapter;
import com.jfinal.weixin.sdk.msg.in.InTextMsg;
import com.jfinal.weixin.sdk.msg.in.event.InFollowEvent;
import com.jfinal.weixin.sdk.msg.in.event.InMenuEvent;
import com.jfinal.weixin.sdk.msg.out.OutTextMsg;
import com.nancarp.utils.WeixinUtil;

public class WeixinMsgController extends MsgControllerAdapter {

    /**
     * 如果要支持多公众账号，只需要在此返回各个公众号对应的 ApiConfig 对象即可 可以通过在请求 url 中挂参数来动态从数据库中获取
     * ApiConfig 属性值
     */
    @Override
    public ApiConfig getApiConfig() {
        return WeixinUtil.getApiConfig();
    }

    /* 
     * 接收文本消息事件
     */
    @Override
    protected void processInTextMsg(InTextMsg inTextMsg) {
        // 其它文本消息直接返回原值
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        outMsg.setContent(&quot;\t文本消息已成功接收，内容为： &quot; + inTextMsg.getContent());
        render(outMsg);
    }

    @Override
    protected void processInFollowEvent(InFollowEvent inFollowEvent) {
        // TODO Auto-generated method stub

    }

    @Override
    protected void processInMenuEvent(InMenuEvent inMenuEvent) {
        // TODO Auto-generated method stub

    }

}
</code></pre><h4 id="WeixinUtil"><a href="#WeixinUtil" class="headerlink" title="WeixinUtil"></a>WeixinUtil</h4><p><code>getApiConfig()</code> 方法，获取 <code>token</code>、<code>appId</code>、<code>appSecret</code> 信息。</p>
<pre><code>package com.nancarp.utils;

import com.jfinal.kit.PropKit;
import com.jfinal.weixin.sdk.api.ApiConfig;

/**
 * 
 * 公众平台通用接口工具类
 */
public class WeixinUtil {
    /**
     * 获取配置
     */
    public static ApiConfig getApiConfig() {
        ApiConfig ac = new ApiConfig();

        // 配置微信 API 相关常量
        ac.setToken(PropKit.get(&quot;token&quot;));
        ac.setAppId(PropKit.get(&quot;appId&quot;));
        ac.setAppSecret(PropKit.get(&quot;appSecret&quot;));

        /**
         *  是否对消息进行加密，对应于微信平台的消息加解密方式：
         *  1：true进行加密且必须配置 encodingAesKey
         *  2：false采用明文模式，同时也支持混合模式
         */
        ac.setEncryptMessage(PropKit.getBoolean(&quot;encryptMessage&quot;, false));
        ac.setEncodingAesKey(PropKit.get(&quot;encodingAesKey&quot;, &quot;setting it in config file&quot;));
        return ac;
    }
}
</code></pre><h4 id="a-little-config-txt"><a href="#a-little-config-txt" class="headerlink" title="a_little_config.txt"></a>a_little_config.txt</h4><p><code>token</code>、<code>appId</code>、<code>appSecret</code>  参数要与先前申请的测试号保持一致。<a href="http://www.jianshu.com/p/e47edf0a49bf" target="_blank" rel="external">详见《微信开发前的准备》</a>  </p>
<pre><code># 微信服务器回调所用的 token
token=weixin

# 测试用的账号
appId=wxde758064398fa9bf
appSecret=89622f356fc2bca96ec647d55929afa5
</code></pre><h4 id="WeixinConfig-配置"><a href="#WeixinConfig-配置" class="headerlink" title="WeixinConfig 配置"></a>WeixinConfig 配置</h4><pre><code>@Override
public void configConstant(Constants me) {
    // 加载配置文件
    PropKit.use(&quot;a_little_config.txt&quot;);
    // 读取配置文件，判断是否为开发模式，默认 false
    me.setDevMode(PropKit.getBoolean(&quot;devMode&quot;, false));
    // ApiConfigKit 设为开发模式可以在开发阶段输出请求交互的 xml 与 json 数据
    ApiConfigKit.setDevMode(me.getDevMode());
    // 默认使用的jackson，下面示例是切换到fastJson
    //me.setJsonFactory(new FastJsonFactory());
}

@Override
public void configRoute(Routes me) {
    // HelloWorld 路由
    me.add(&quot;/hello&quot;,HelloWorldController.class);
    // 接收用户消息和发送消息
    me.add(&quot;/msg&quot;, WeixinMsgController.class);
}
</code></pre><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><ol>
<li>启动 Tomcat  </li>
<li>启动 ngrok<br>参考 <a href="http://www.cnblogs.com/zyw-205520/p/4733062.html" target="_blank" rel="external">让微信公众平台通过80端口访问本机</a>  </li>
</ol>
<h4 id="微信客户端的操作"><a href="#微信客户端的操作" class="headerlink" title="微信客户端的操作"></a>微信客户端的操作</h4><p>关注测试账号，输入内容“1”，测试号回复“文本消息已成功接收，内容为： 1”，大功告成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-0ebb11e9f5a49a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信回复信息"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/e7ecdc6a85f3" target="_blank" rel="external">JFinal Weixin 学习笔记（5）– 微信页面跳转</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.jianshu.com/p/6e8caa616577" target="_blank" rel="external">微信公众号开发之如何实现消息交互</a><br><a href="http://www.jfinal.com/project/2" target="_blank" rel="external">JFinal Weixin 极速开发 SDK</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/JFinal-weixin%E4%B8%AD%E7%9A%84WeixinConfig%E9%85%8D%E7%BD%AE" target="_blank" rel="external">JFinal weixin中的WeixinConfig配置</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="NanCarp" />
          <p class="site-author-name" itemprop="name">NanCarp</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NanCarp</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
