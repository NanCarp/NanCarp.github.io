<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="李子园">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李子园">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李子园">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>李子园</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李子园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习、生活、感悟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/05/从 Node.js 访问文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/05/从 Node.js 访问文件系统/" itemprop="url">从 Node.js 访问文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-05T22:56:40+08:00">
                2017-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="6-1-同步和异步文件调用"><a href="#6-1-同步和异步文件调用" class="headerlink" title="6.1 同步和异步文件调用"></a>6.1 同步和异步文件调用</h2><p>重要区别：  </p>
<ul>
<li>异步调用需要一个回调函数作为额外的参数。回调函数在系统的请求完成时被执行，并且通常包含一个错误作为其第一个参数。</li>
<li>异步调用自动处理异常；且如果发生异常，就把错误对象作为第一个参数传递。同步调用中处理异常，必须使用 try/catch 快。</li>
<li>同步调用立即运行，除非完成，否则不会返回到当前线程。异步调用被放置在事件队列中，并且执行返回到正在运行的线程的<br>代码，但是实际的调用知道它被事件循环提取出时才会执行。</li>
</ul>
<h2 id="6-2-打开和关闭文件"><a href="#6-2-打开和关闭文件" class="headerlink" title="6.2 打开和关闭文件"></a>6.2 打开和关闭文件</h2><p>一旦文件被打开，就可以从中读取数据或写入数据，这取决于用来打开文件的标志。要在 Node.js 应用程序中大打开文件，可以<br>使用下面的异步或同步语句之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.open(path, flags, [mode], callback)</div><div class="line">fs.openSync(path, flags, [mode])</div></pre></td></tr></table></figure></p>
<ul>
<li>path：指定文件系统的标准路径字符串。</li>
<li>flags：打开文件的模式，读、写、追加等。</li>
<li>mode：文件访问模式，默认为 0666，表示刻度且可写。</li>
</ul>
<p>定义文件如何打开的标志：  </p>
<ul>
<li>r：打开文件用于读取。如果该文件不存在，则会出现异常</li>
<li>r+：打开文件用于读写。如果该文件不存在，则会出现异常</li>
<li>rs：在同步模式下打开文件用于读取。这与强制使用 fs.openSync() 不一样。当使用这种模式时，操作系统将绕过本地文件系统<br>缓存。因为它可以跳过可能是小的本地缓存，所以这对 NFS 挂在是有用的。你用该只在必要时使用该标志，因为它可能对性能产生<br>负面影响</li>
<li>rs+：同 rs，除了打开文件用于读写外</li>
<li>w：打开文件用于写操作，如果它不存在，就创建该文件；或者如果它确实存在，则截断该文件</li>
<li>wx：同 w；但如果路径存在，则打开失败</li>
<li>w+：打开文件用于读写。如果它不存在，就创建该文件；或者如果它确实存在，则截断该文件</li>
<li>wx+：同 w+；但如果路径存在，则打开失败</li>
<li>a：打开文件用于追加。如果它不存在，则创建该文件</li>
<li>ax：同 a；但如果路径存在，则打开失败</li>
<li>a+：打开文件用于读取和追加。如果它不存在，则创建该文件</li>
<li>ax+：同 a+；但如果路径存在，则打开失败</li>
</ul>
<p>一旦文件被打开，你需要关闭它以迫使操作系统把更改刷新到磁盘并释放操作系统锁。要关闭文件，可使用下列方法，并传递文件<br>操作符。异步 close() 方法调用，还需要指定回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.close(fd, callback)</div><div class="line">fs.closeSync(fd)</div></pre></td></tr></table></figure></p>
<p>以下是以异步模式打开和关闭文件的例子。注意：回调函数被指定，且接收 err 和 fd 参数。fd 是用来读取或写入该文件的文件<br>描述符：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fs.open(&quot;myFile&quot;, &apos;w&apos;, function(err, fd) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		fs.close(fd);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>以下是同步模式，无回调函数，文件描述符直接从 fs.openSync() 返回：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var fd = fs.openSync(&quot;myFile&quot;, &apos;w&apos;);</div><div class="line">fs.closeSync(fd);</div></pre></td></tr></table></figure></p>
<h2 id="6-3-写入文件"><a href="#6-3-写入文件" class="headerlink" title="6.3 写入文件"></a>6.3 写入文件</h2><h3 id="6-3-1-简单文件写入"><a href="#6-3-1-简单文件写入" class="headerlink" title="6.3.1 简单文件写入"></a>6.3.1 简单文件写入</h3><p>这些方法把一个字符串或缓冲区的全部内容写入一个文件，语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.writeFile(path, data, [options], callback)</div><div class="line">fs.writeFileSync(path, data, [options])</div></pre></td></tr></table></figure></p>
<ul>
<li>path：文件路径，相对或绝对路径。</li>
<li>data：将被写入到文件中的 String 或 Buffer 对象。</li>
<li>options：一个对象，可以包含定义字符串编码，以及代开文件时使用得模式和标志的 encoding、mode 和 flag 属性。</li>
<li>callback：当文件写入已经完成时被调用。</li>
</ul>
<p>以下实现异步请求来在文件中存储 config（配置）对象的 JSON 字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 将 JSON 字符串写入文件</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var config = &#123;</div><div class="line">	maxFile: 20,</div><div class="line">	maxConnections: 15,</div><div class="line">	rootPath: &quot;/webroot&quot;</div><div class="line">&#125;;</div><div class="line">var configTxt = JSON.stringify(config);</div><div class="line">var options = &#123;encoding:&apos;utf8&apos;, flag:&apos;w&apos;&#125;;</div><div class="line">fs.writeFile(&apos;config.txt&apos;, configTxt, options, function(err) &#123;</div><div class="line">	if (err) &#123;</div><div class="line">		console.log(&quot;Config Write Failed.&quot;);</div><div class="line">	&#125; else &#123;</div><div class="line">		console.log(&quot;Config Saved.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><code>Config Saved.</code></p>
<h3 id="6-3-2-同步文件写入"><a href="#6-3-2-同步文件写入" class="headerlink" title="6.3.2 同步文件写入"></a>6.3.2 同步文件写入</h3><p>同步方法涉及在返回执行正在运行的线程之前，将数据写入文件。这提供了使你能够在相同的代码段写入多次的优点，但如果该<br>文件写入控制住其他线程，它就可能是一个缺点。<br>同步写入文件，先用 openSync() 打开它来获取文件描述符，然后使用 fs.writeSync() 将数据写入文件。语法：<br><code>fs.writeSync(fd, data, offset, length, position)</code></p>
<ul>
<li>fd：openSync() 返回的文件描述符</li>
<li>data：指定将被写入文件中的 String 或 Buffer 对象</li>
<li>offset：指定 data 参数中开始阅读的索引。如果想从字符串或缓冲区的当前索引开始，值应该为 null。</li>
<li>length：指定要写入的字节数，可以指定 null，表示一直写到数据缓冲区的末尾</li>
<li>position：指定在文件中写入的位置，null 表示使用文件当前位置</li>
</ul>
<p>以下实现基本同步写入把一系列字符串存储到文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 执行同步写入文件</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var veggieTray = [&apos;carrots&apos;, &apos;celery&apos;, &apos;olives&apos;];</div><div class="line">fd = fs.openSync(&apos;veggie.txt&apos;, &apos;w&apos;);</div><div class="line">while (veggieTray.length) &#123;</div><div class="line">	veggie = veggieTray.pop() + &quot; &quot;;</div><div class="line">	var bytes = fs.writeSync(fd, veggie, null, null);</div><div class="line">	console.log(&quot;Wrote %s %dbytes&quot;, veggie, bytes);</div><div class="line">&#125;</div><div class="line">fs.closeSync(fd);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ node file_write_sync.js</div><div class="line">Wrote olives  7bytes</div><div class="line">Wrote celery  7bytes</div><div class="line">Wrote carrots  8bytes</div></pre></td></tr></table></figure></p>
<h3 id="异步写入文件"><a href="#异步写入文件" class="headerlink" title="异步写入文件"></a>异步写入文件</h3><p>文件写入的异步方法在事件队列中放置一个写入请求，然后将控制返回给调用代码。除非事件循环提取出写入请求，并且执行它，<br>否则实际的写操作不会发生。在同一个文件上执行多个异步写入请求时，除非在执行下一个写入前等待第一个写入回调函数完成，<br>否则不能保证执行的顺序。通常情况下，最简单的是把写操作嵌套在上一个写操作的回调函数中。<br>要异步写入一个文件，首先使用 open() 打开它，然后在打开请求的回调函数已经执行后，使用 fs.write() 将数据写入文件。<br>以下是 fs.write() 语法：<br><code>fs.write(fd, data, offset, length, position, callback)</code>  </p>
<ul>
<li>fd：openSync() 返回的文件描述符。</li>
<li>data：指定将被写入文件中的 String 或 Buffer 对象。</li>
<li>offset：指定要开始读取数据的输入数据中的索引。如果想从字符串或缓冲区的当前索引开始，值应该为 null。</li>
<li>length：指定要写入的字节数，可以指定 null，表示一直写到数据缓冲区的末尾。</li>
<li>position：指定在文件中写入的位置，null 表示使用文件当前位置。</li>
<li>callback：必须是可以接受 error 和 bytes 两个参数的函数，其中 error 是在写过程中发生的错误，bytes 指定写入<br>字节数。</li>
</ul>
<p>以下代码显示了如何实现基本的异步写入来把一系列字符串数据存储到一个文件。注意，open() 的 callback 所指定的回调函数<br>调用 writeFruit() 函数，并传递文件描述符，write() 方法的回调也调用 writeFruit() ，并传递文件描述符。这确保了异步<br>写入在另一个执行前完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 执行异步写入文件</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var fruitBowl = [&apos;apple&apos;, &apos;orange&apos;, &apos;banana&apos;, &apos;grapes&apos;];</div><div class="line">function writeFruit(fd) &#123;</div><div class="line">	if (fruitBowl.length) &#123;</div><div class="line">		var fruit = fruitBowl.pop() + &quot; &quot;;</div><div class="line">		fs.write(fd, fruit, null, null, function(err, bytes) &#123;</div><div class="line">			if (err) &#123;</div><div class="line">				console.log(&quot;File Write Failed.&quot;);</div><div class="line">			&#125; else &#123;</div><div class="line">				console.log(&quot;Wrote: %s %dbytes&quot;, fruit, bytes);</div><div class="line">				writeFruit(fd);</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">		&#125;);</div><div class="line">	&#125; else &#123;</div><div class="line">		fs.close(fd);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">fs.open(&apos;fruit.txt&apos;, &apos;w&apos;, function(err, fd) &#123;</div><div class="line">	writeFruit(fd);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node file_write_async.js</div><div class="line">Wrote: grapes  7bytes</div><div class="line">Wrote: banana  7bytes</div><div class="line">Wrote: orange  7bytes</div><div class="line">Wrote: apple  6bytes</div></pre></td></tr></table></figure></p>
<h3 id="6-3-4-流式文件写入"><a href="#6-3-4-流式文件写入" class="headerlink" title="6.3.4 流式文件写入"></a>6.3.4 流式文件写入</h3><p>往一个文件写入大量数据时，最好的方法之一是使用流，其中包括把文件作为一个 Writable 流打开。<br>要将数据异步传送到文件，首先用以下语法创建一个 Writable 对象：<br><code>fs.createWritableStream(path, [options])</code>  </p>
<ul>
<li>path：指定文件路径</li>
<li>options：可选，是一个对象，可以包含定义字符串编码，以及打开文件时使用得模式和标志的 encoding、mode 和 flag<br>属性。<br>一旦打开了 Writable 文件流，就可以使用标准的流式 write(buffer) 方法来写入它。当写入完成后，再调用 end() 方法<br>来关闭流。<br>以下代码实现了基本的 Writable 文件流。注意，代码完成写入后，执行 end() 方法，触发 close 事件。  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 实现一个 Writable 流，允许流式写入一个文件</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var grains = [&apos;wheat&apos;, &apos;rice&apos;, &apos;oats&apos;];</div><div class="line">var options = &#123;encoding: &apos;utf8&apos;, flag: &apos;w&apos;&#125;;</div><div class="line">var fileWriteStream = fs.createWriteStream(&quot;grains.txt&quot;, options);</div><div class="line">fileWriteStream.on(&quot;close&quot;, function() &#123;</div><div class="line">	console.log(&quot;File Closed.&quot;);</div><div class="line">&#125;);</div><div class="line">while (grains.length) &#123;</div><div class="line">	var data = grains.pop() + &quot; &quot;;</div><div class="line">	fileWriteStream.write(data);</div><div class="line">	console.log(&quot;Wrote: %s&quot;, data);</div><div class="line">&#125;</div><div class="line">fileWriteStream.end();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node file_write_stream.js</div><div class="line">Wrote: oats</div><div class="line">Wrote: rice</div><div class="line">Wrote: wheat</div><div class="line">File Closed.</div></pre></td></tr></table></figure></p>
<h3 id="6-4-1-简单文件读取"><a href="#6-4-1-简单文件读取" class="headerlink" title="6.4.1 简单文件读取"></a>6.4.1 简单文件读取</h3><p>readFile(） 方法从文件中把全部内容读取到数据缓冲区，语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.readFile(path, [options], callback)</div><div class="line">fs.readFileSync(path, [options])</div></pre></td></tr></table></figure></p>
<ul>
<li>path：文件路径，相对或绝对路径</li>
<li>options：可选，是一个对象，可以包含定义字符串编码，以及打开文件时使用得模式和标志的 encoding、mode 和 flag<br>属性。</li>
<li>callback：异步方法需要，文件读取完成时将被调用。</li>
</ul>
<p>以下代码实现了简单的异步 readFile() 请求来从一个配置文件中读取 JSON 字符串，然后用它来创建一个 config 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 读取 JSON 字符串文件到一个对象</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var options = &#123;encoding:&apos;utf8&apos;, flag:&apos;r&apos;&#125;;</div><div class="line">fs.readFile(&apos;config.txt&apos;, options, function(err, data) &#123;</div><div class="line">	if (err) &#123;</div><div class="line">		console.log(&quot;Failed to open Config File.&quot;);</div><div class="line">	&#125; else &#123;</div><div class="line">		console.log(&quot;Config Loaded.&quot;);</div><div class="line">		var config = JSON.parse(data);</div><div class="line">		console.log(&quot;Max Files: &quot; + config.maxFilse);</div><div class="line">		console.log(&quot;Max Connecttions: &quot; + config.maxConnections);</div><div class="line">		console.log(&quot;Root Path: &quot; + config.rootPath);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node file_read.js</div><div class="line">Config Loaded.</div><div class="line">Max Files: undefined</div><div class="line">Max Connecttions: 15</div><div class="line">Root Path: /webroot</div></pre></td></tr></table></figure></p>
<h3 id="6-4-2-同步文件读取"><a href="#6-4-2-同步文件读取" class="headerlink" title="6.4.2 同步文件读取"></a>6.4.2 同步文件读取</h3><p>文件读取的同步方法涉及在返回执行正在运行的线程之前，读取文件中的数据。这提供了使你能够在代码相同的部分多次读取<br>的优点，但如果该文件读取操作控制住其他线程，它就可能是一个缺点。<br>要同步读取一个文件，先用 openSync() 打开它来获取一个文件描述符，然后使用 readSync() 从文件中读取数据。语法：<br><code>fs.readSync(fd, buffer, offset, length, position)</code>  </p>
<ul>
<li>fd：openSync() 返回的文件描述符。</li>
<li>buffer：指定将被从文件中读入的 Buffer 对象。</li>
<li>offset：指定缓冲区将开始写入数据的索引；置为 null，表示从缓冲区的当前索引处开始。</li>
<li>position：指定文件中开始读取的位置；置为 null，表示使用文件的当前位置。</li>
</ul>
<p>以下代码实现从一个文件中读取字符串数据开的基本同步读取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 执行从文件同步读取</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">fd = fs.openSync(&apos;veggie.txt&apos;, &apos;r&apos;);</div><div class="line">var veggies = &quot;&quot;;</div><div class="line">do &#123;</div><div class="line">	var buf = new Buffer(5);</div><div class="line">	buf.fill();</div><div class="line">	var bytes = fs.readSync(fd, buf, null, 5);</div><div class="line">	console.log(&quot;read %dbytes&quot;, bytes);</div><div class="line">	veggies += buf.toString();</div><div class="line">&#125; while (bytes &gt; 0);</div><div class="line">fs.closeSync(fd);</div><div class="line">console.log(&quot;Veggies: &quot; + veggies);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node file_read_sync.js</div><div class="line">read 5bytes</div><div class="line">read 5bytes</div><div class="line">read 5bytes</div><div class="line">read 5bytes</div><div class="line">read 2bytes</div><div class="line">read 0bytes</div><div class="line">Veggies: olives celery carrots</div></pre></td></tr></table></figure></p>
<h3 id="6-4-3-异步文件读取"><a href="#6-4-3-异步文件读取" class="headerlink" title="6.4.3 异步文件读取"></a>6.4.3 异步文件读取</h3><p>文件读取的异步方法在事件队列中放置一个读取请求，然后将控制返回给调用代码。除非事件循环提取出读取请求，并且执行它，<br>否则实际的读操作不会发生。在同一个文件上执行多个异步读取请求时，除非在执行下一个读取前等待第一个读取回调函数完成，<br>否则不能保证执行的顺序。通常情况下，最简单的是把写操作嵌套在上一个读取操作的回调函数中。<br>要从异步文件中读取，首先使用 open() 打开它，然后在来自打开请求的回调函数已经执行后，使用 read() 读取文件数据。<br>以下是 read() 语法：<br><code>fs.read(fd, buffer, offset, length, position, callback)</code></p>
<ul>
<li>fd：openSync() 返回的文件描述符。</li>
<li>buffer：指定将被从文件中读入的 Buffer 对象。</li>
<li>offset：指定缓冲区将开始写入数据的索引；置为 null，表示从缓冲区的当前索引处开始。</li>
<li>position：指定文件中开始读取的位置；置为 null，表示使用文件的当前位置。</li>
<li>callback：必须是可以接受 error、bytes 和 buffer 这三个参数的函数。<ul>
<li>error：读取过程发生的错误</li>
<li>bytes：读取的字节数</li>
<li>buffer：从读请求填充数据的缓冲区</li>
</ul>
</li>
</ul>
<p>以下代码从一个文件中异步读取数据块。注意，open() 的回调函数调用 readFruit() 函数，并传递文件描述符。 read() 的<br>回调函数也调用 readFruit()，并传递文件描述符，这保证了异步读取在另一个读取之前完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 执行从文件异步读取</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">function readFruit(fd, fruits) &#123;</div><div class="line">	var buf = new Buffer(5);</div><div class="line">	buf.fill();</div><div class="line">	fs.read(fd, buf, 0, 5, null, function(err, bytes, data) &#123;</div><div class="line">		if (bytes &gt; 0) &#123;</div><div class="line">			console.log(&quot;read %dbytes&quot;, bytes);</div><div class="line">			fruits += data;</div><div class="line">			readFruit(fd, fruits);</div><div class="line">		&#125; else &#123;</div><div class="line">			fs.close(fd);</div><div class="line">			console.log(&quot;Fruits: %s&quot;, fruits);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">fs.open(&apos;fruit.txt&apos;, &apos;r&apos;, function(err, fd) &#123;</div><div class="line">	readFruit(fd, &quot;&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node file_read_async.js</div><div class="line">read 5bytes</div><div class="line">read 5bytes</div><div class="line">read 5bytes</div><div class="line">read 5bytes</div><div class="line">read 5bytes</div><div class="line">read 2bytes</div><div class="line">Fruits: grapes banana orange apple</div></pre></td></tr></table></figure></p>
<h3 id="6-4-4-流式文件读取"><a href="#6-4-4-流式文件读取" class="headerlink" title="6.4.4 流式文件读取"></a>6.4.4 流式文件读取</h3><p>要异步从文件传输数据，首先创建一个 Readable 流对象：<br><code>fs.createReadStream(path, [options])</code>  </p>
<ul>
<li>path：指定文件路径，相对或绝对路径。</li>
<li>options：可选，是一个对象，可以包含定义字符串编码，以及打开文件时使用得模式和标志的 encoding、mode 和 flag<br>属性。</li>
</ul>
<p>当打开 Readable 文件流后，可以用过使用 readable 事件和 read() 请求，或通过实现 data 事件处理程序轻松地从它<br>读出。<br>以下代码实现了一个基本的 Readable 文件流。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 实现 Readable 流，使得能够流式读取一个文件</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var options = &#123;encoding: &apos;utf8&apos;, flag: &apos;r&apos;&#125;;</div><div class="line">var fileReadStream = fs.createReadStream(&quot;grains.txt&quot;, options);</div><div class="line">// data 事件处理程序不断地从流中读取数据</div><div class="line">fileReadStream.on(&apos;data&apos;, function(chunk) &#123;</div><div class="line">	console.log(&apos;Grains: %s&apos;, chunk);</div><div class="line">	console.log(&apos;Read %d bytes of data.&apos;, chunk.length);</div><div class="line">&#125;);</div><div class="line">fileReadStream.on(&quot;close&quot;, function() &#123;</div><div class="line">	console.log(&quot;File Closed.&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ node file_read_stream.js</div><div class="line">Grains: oats rice wheat</div><div class="line">Read 16 bytes of data.</div><div class="line">File Closed.</div></pre></td></tr></table></figure></p>
<h2 id="6-5-其他文件系统任务"><a href="#6-5-其他文件系统任务" class="headerlink" title="6.5 其他文件系统任务"></a>6.5 其他文件系统任务</h2><h3 id="6-5-1-验证路径的存在性"><a href="#6-5-1-验证路径的存在性" class="headerlink" title="6.5.1 验证路径的存在性"></a>6.5.1 验证路径的存在性</h3><p>在对文件或目录执行任何形式的读/写操作之前，都要验证路径是否存在。可以使用以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.exists(path, callback)</div><div class="line">fs.existsSync(path)</div></pre></td></tr></table></figure></p>
<p>fs.existsSync(path) 返回 true 或 false ，这取决于路径是否存在。fs.exists() 的回调函数将被传入 true 或 false，<br>例如，下面的代码验证在当前路径中以 filesystem.js 命名的文件是否存在，并显示验证的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.exists(&apos;filesystem.js&apos;, function (exists) &#123;</div><div class="line">	console.log(exits ? &quot;Path Exists&quot; : &quot;Path Does Not Exist&quot;);</div><div class="line">&#125;):</div></pre></td></tr></table></figure></p>
<h3 id="6-5-2-获取文件信息"><a href="#6-5-2-获取文件信息" class="headerlink" title="6.5.2 获取文件信息"></a>6.5.2 获取文件信息</h3><p>获取文件系统对象的基本信息，如文件大小、模式、修改时间，以及条目是否是一个文件或文件夹等。使用下面的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.stats(path, callback)</div><div class="line">fs.statsSync(path)</div></pre></td></tr></table></figure></p>
<p>fsStatsSync() 方法返回一个 Stats 对象。执行 fs.stats() 方法，Stats 对象作为第二个参数被传递到回调函数。第一个<br>参数是 error。<br>附加到 Stats 对象上的最常用的属性和方法：  </p>
<ul>
<li>isFile()：如果该条目是一个文件，则返回 true</li>
<li>isDirectory()：如果该条目是一个目录，则返回 true</li>
<li>isSocket()：如果该条目是一个套接字，则返回 true</li>
<li>dev：指定文件所在的设备 ID</li>
<li>mode：指定文件的访问模式</li>
<li>size：指定文件的字节数</li>
<li>blksize：指定用于存储文件的快的大小，以字节为单位</li>
<li>blocks：指定文件在磁盘上占用的块的数目</li>
<li>atime：指定上次访问文件的时间</li>
<li>mtime：指定文件的最后修改时间</li>
<li>ctime：指定文件的创建时间</li>
</ul>
<p>下面代码先执行 fs.stats() 调用，然后作为 JSON 字符串输出对象的结果，并使用 isFile()、isDirector() 和 isSocket()<br>调用，说明了如何使用 fs.stas() 调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 实现一个 fs.stats() 调用来检索有关文件的信息</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">fs.stat(&apos;file_stats.js&apos;, function (err, stats) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		console.log(&apos;stats: &apos; + JSON.stringify(stats, null, &apos; &apos;));</div><div class="line">		console.log(stats.isFile() ? &quot;Is a File&quot; : &quot;Is not a File&quot;);</div><div class="line">		console.log(stats.isDirectory() ? &quot;Is a Folder&quot; : &quot;Is not a Folder&quot;);</div><div class="line">		console.log(stats.isSocket() ? &quot;Is a Socket&quot; : &quot;Is not a Socket&quot;);</div><div class="line">		stats.isDirectory();</div><div class="line">		stats.isBlockDevice();</div><div class="line">		stats.isCharacterDevice();</div><div class="line">		//stats.isSymbolicLink(); //only lstat</div><div class="line">		stats.isFIFO();</div><div class="line">		stats.isSocket();</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ node file_stats.js</div><div class="line">stats: &#123;</div><div class="line"> &quot;dev&quot;: -996849395,</div><div class="line"> &quot;mode&quot;: 33206,</div><div class="line"> &quot;nlink&quot;: 1,</div><div class="line"> &quot;uid&quot;: 0,</div><div class="line"> &quot;gid&quot;: 0,</div><div class="line"> &quot;rdev&quot;: 0,</div><div class="line"> &quot;ino&quot;: 147211412819692740,</div><div class="line"> &quot;size&quot;: 577,</div><div class="line"> &quot;atime&quot;: &quot;2017-07-07T13:57:45.893Z&quot;,</div><div class="line"> &quot;mtime&quot;: &quot;2017-07-07T14:04:33.741Z&quot;,</div><div class="line"> &quot;ctime&quot;: &quot;2017-07-07T14:04:33.741Z&quot;,</div><div class="line"> &quot;birthtime&quot;: &quot;2017-07-07T13:57:45.892Z&quot;</div><div class="line">&#125;</div><div class="line">Is a File</div><div class="line">Is not a Folder</div><div class="line">Is not a Socket</div></pre></td></tr></table></figure></p>
<h3 id="6-5-3-列出文件"><a href="#6-5-3-列出文件" class="headerlink" title="6.5.3 列出文件"></a>6.5.3 列出文件</h3><p>常见任务：列出在目录中的文件和文件夹——例如列出一个目录中的文件，以确定是否需要进行清理；在目录结构上动态操作等。<br>可以使用以下名利读取条目列表来访问文件系统中的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.readdir(path, callback)</div><div class="line">fs.readdirSync(path)</div></pre></td></tr></table></figure></p>
<p>readdirSync() 返回指定路径中条目名称的字符串数组。 readdir() ，该列表作为第二个参数被传递给回调函数，如果有错误，<br>此错误作为第一个参数传递。<br>下面实现了一个嵌套的回调链来遍历目录结构并输出其中的条目。注意，回调函数实现了一个包装器，它提供一个 fullPath 变量<br>的闭包，并且通过一部回调函数使 WalkDirs() 函数循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 实现一个回调链来遍历和输出目录结构的内容</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var Path = require(&apos;path&apos;);</div><div class="line">function WalkDirs(dirPath) &#123;</div><div class="line">	console.log(dirPath);</div><div class="line">	fs.readdir(dirPath, function(err, entries) &#123;</div><div class="line">		for (var idx in entries) &#123;</div><div class="line">			var fullPath = Path.join(dirPath, entries[idx]);</div><div class="line">			(function(fullPath) &#123;</div><div class="line">				fs.stat(fullPath, function(err, stats) &#123;</div><div class="line">					if (stats &amp;&amp; stats.isFile()) &#123;</div><div class="line">						console.log(fullPath);</div><div class="line">					&#125; else &#123;</div><div class="line">						WalkDirs(fullPath);</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">			&#125;)(fullPath);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">WalkDirs(&quot;../ch6&quot;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ node file_readdir.js</div><div class="line">../ch6</div><div class="line">..\ch6\config.txt</div><div class="line">..\ch6\file_read.js</div><div class="line">..\ch6\file_readdir.js</div><div class="line">..\ch6\file_read_async.js</div><div class="line">..\ch6\file_read_stream.js</div><div class="line">..\ch6\file_read_sync.js</div><div class="line">..\ch6\file_stats.js</div><div class="line">..\ch6\file_write.js</div><div class="line">..\ch6\file_write_sync.js</div><div class="line">..\ch6\file_write_async.js</div><div class="line">..\ch6\file_write_stream.js</div><div class="line">..\ch6\README.md</div><div class="line">..\ch6\fruit.txt</div><div class="line">..\ch6\grains.txt</div><div class="line">..\ch6\other.js</div><div class="line">..\ch6\test</div><div class="line">..\ch6\veggie.txt</div><div class="line">..\ch6\test\test.js</div></pre></td></tr></table></figure></p>
<h3 id="6-5-4-删除文件"><a href="#6-5-4-删除文件" class="headerlink" title="6.5.4 删除文件"></a>6.5.4 删除文件</h3><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.unlink(path, callback)</div><div class="line">fs.unlinkSync(path)</div></pre></td></tr></table></figure></p>
<p>unlinkSync(path) 函数返回 true 或 false，这取决于是否删除成功。如果删除该文件时遇到错误，异步的 unlink() 调用<br>就传回一个错误值给回调函数。<br>下面代码使用 unlink() 异步 fs 调用删除 new.txt 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.unlink(&quot;new.txt&quot;, function(err) &#123;</div><div class="line">	console.log(err ? &quot;File Deleted Failed&quot; : &quot;File Deleted&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="6-5-5-截断文件"><a href="#6-5-5-截断文件" class="headerlink" title="6.5.5 截断文件"></a>6.5.5 截断文件</h3><p>截断（Truncate）文件是指通过把文件结束处设置为比当前值小的值来减小文件的大小。可能需要截断不断增长，但不包含<br>关键数据的文件（例如，临时日志）。可使用下面的 fs 调用之一来截断文件，传入希望文件截断完成时要包含的字节数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.truncate(path, len, callback)</div><div class="line">fs.truncateSync(path, len)</div></pre></td></tr></table></figure></p>
<p>fs.truncateSync(path) 函数返回 true 或 false，这取决于是否截断成功。如果截断该文件时遇到错误，异步的 truncate()<br>调用就传回一个错误值给回调函数。<br>下面代码把 log.txt 的文件截断成零字节：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fs.truncate(&quot;log.txt&quot;, function(err) &#123;</div><div class="line">	console.log(err ? &quot;File Truncate Failed&quot; : &quot;File Truncated&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="6-5-6-建立和删除目录"><a href="#6-5-6-建立和删除目录" class="headerlink" title="6.5.6 建立和删除目录"></a>6.5.6 建立和删除目录</h3><p>从 Node.js 添加目录，使用以下 fs 调用之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.mkdir(path, [mode], callback)</div><div class="line">fs.mkdirSync(path, [mode])</div></pre></td></tr></table></figure></p>
<ul>
<li>path：可以是绝对或相对路径</li>
<li>mode：可选，指定新目录的访问模式</li>
</ul>
<p>mkdirSync(path)  返回 true 或 false，取决于目录是否已经成功创建。另一方面，如果遇到错误，异步的 mkdir() 调用<br>传递一个 error 值给回调函数。<br>使用异步方法的时候，需要等待创建目录的回调函数完成后，才能创建该目录的子目录。下面演示了如何将创建一个子目录<br>结构的操作链接在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fs.mkdir(&quot;./data&quot;, function(err) &#123;</div><div class="line">	fs.mkdir(&quot;./data/folderA&quot;, function(err) &#123;</div><div class="line">		fs.mkdir(&quot;./data/folderA/folderB&quot;, function(err) &#123;</div><div class="line">			fs.mkdir(&quot;./data/folderA/folderB/folderD&quot;, function(err) &#123;</div><div class="line">				</div><div class="line">			&#125;);</div><div class="line">		&#125;);</div><div class="line">		fs.mkdir(&quot;./data/folderA/folderC&quot;, function(err) &#123;</div><div class="line">			fs.mkdir(&quot;./data/folderA/folderC/folderE&quot;, function(err) &#123;</div><div class="line">				</div><div class="line">			&#125;);</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>要从 Node.js 删除目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.rmdir(path, callback)</div><div class="line">fs.rmdirSync(path)</div></pre></td></tr></table></figure></p>
<p>rmdirSync(path)  返回 true 或 false，取决于目录是否已经成功删除。另一方面，如果遇到错误，异步的 rmdir() 调用<br>传递一个 error 值给回调函数。<br>使用异步方法的时候，再删除父目录之前，需要等待删除该目录的回调函数完成。下面演示了如何将删除子目录结构的操作<br>链接在一起：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">fs.rmdir(&quot;./data/folderA/folderB/folderC&quot;, function(err)&#123;</div><div class="line">	fs.rmdir(&quot;./data/folderA/folderB&quot;, function(err) &#123;</div><div class="line">		fs.rmdir(&quot;./data/folderD&quot;, function(err) &#123;</div><div class="line">			</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">	fs.rmdir(&quot;./data/folderA/folderC&quot;, function(err) &#123;</div><div class="line">		fs.rmdir(&quot;./data/folderE&quot;, function(err) &#123;</div><div class="line">			</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="6-5-7-重命名文件和目录"><a href="#6-5-7-重命名文件和目录" class="headerlink" title="6.5.7 重命名文件和目录"></a>6.5.7 重命名文件和目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fs.rename(oldPath, newPath, callback)</div><div class="line">fs.renameSync(oldPath, new Path)</div></pre></td></tr></table></figure>
<p>oldPath 指定现有的文件或目录的路径，而 newPath 指定新名称。renameSync(path) 返回 true 或 false，取决于文件或<br>目录是否已经成功更名。遇到错误，异步 remane() 调用传递 error 给回调函数。<br>下面代码，把一个名为 old.txt 的文件重命名为 new.txt，并把一个名为 testDir 的目录重命名为 renamedDir：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">fs.rename(&quot;old.txt&quot;, &quot;new.txt&quot;, function(err) &#123;</div><div class="line">	console.log(err ? &quot;Rename Failed&quot; : &quot;File Renamed&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">fs.rename(&quot;testDir&quot;, &quot;renameDir&quot;, function(err) &#123;</div><div class="line">	console.log(err ? &quot;Rename Failed&quot; : &quot;Folder Renamed&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="6-5-8-监视文件更改"><a href="#6-5-8-监视文件更改" class="headerlink" title="6.5.8 监视文件更改"></a>6.5.8 监视文件更改</h3><p>监视文件，在文件发生变化时执行回调函数。如果希望当文件被修改时触发事件的发生，但不希望从应用程序中直接不断地<br>轮询，这会很有用。但是监视在底层操作系统中产生了一些开销，适可而止地使用。<br>监视文件，课使用下面的命令传递想要见识的文件的 path（路径）：<br><code>fs.wathcFile(Path, [optins], callback)</code><br>可以传入 options 对象，它包含 persistent（持续）和 interval 属性。如果想持续监视，设置 persistent 属性为 true。<br>interval 属性指定所需的文件更改的轮询时间，以毫秒为单位。<br>当文件发生变化时，callback 函数就会执行，并传递 Stats 对象。<br>下面代码每个 5 秒监视 log.txt 文件，并使用 Stats 对象来输出本次和上次文件被修改的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fs.watchFile(&quot;log.txt&quot;, &#123;persistent:true, interval:5000&#125;, function (curr, prev) &#123;</div><div class="line">	console.log(&quot;log.txt modified at: &quot; + curr.mtime);</div><div class="line">	console.log(&quot;Previous modification was: &quot; + prev.mtime);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/在 Node.js 中处理数据 IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/03/在 Node.js 中处理数据 IO/" itemprop="url">在 Node.js 中处理数据 I/O</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-03T20:31:00+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="5-1-处理-JSON"><a href="#5-1-处理-JSON" class="headerlink" title="5.1 处理 JSON"></a>5.1 处理 JSON</h2><h3 id="把-JSON-转换成-JavaScript-对象"><a href="#把-JSON-转换成-JavaScript-对象" class="headerlink" title="把 JSON 转换成 JavaScript 对象"></a>把 JSON 转换成 JavaScript 对象</h3><p>例如，下面的代码片段中，注意 accountStr 被定义为一个格式化的 JSON 字符串，然后使用 JSON.parse() 将其转换为<br>JavaScript 对象，之后其成员属性就可以通过点符号来访问：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var accountStr = &apos;&#123;&quot;name&quot;:&quot;Jedi&quot;, &quot;members&quot;:[&quot;Yoda&quot;,&quot;Obi Wan&quot;], \</div><div class="line">				   &quot;number&quot;:34512, &quot;location&quot;: &quot;A galaxy far, far away&quot;&#125;&apos;;</div><div class="line">var accountObj = JSON.parse(accountStr);</div><div class="line">console.log(accountObj.name);</div><div class="line">console.log(accountObj.members);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node other.js</div><div class="line">Jedi</div><div class="line">[ &apos;Yoda&apos;, &apos;Obi Wan&apos; ]</div></pre></td></tr></table></figure></p>
<h3 id="5-1-2-把-JavaScript-对象转化为-JSON-对象"><a href="#5-1-2-把-JavaScript-对象转化为-JSON-对象" class="headerlink" title="5.1.2 把 JavaScript 对象转化为 JSON 对象"></a>5.1.2 把 JavaScript 对象转化为 JSON 对象</h3><p>下面定义了一个包括字符串、数字和数组属性的 JavaScript 对象。JSON.stringify() 将其转换成 JSON 字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var accountObj = &#123;</div><div class="line">	name: &quot;Baggins&quot;,</div><div class="line">	number: 10645,</div><div class="line">	numbers: [&quot;Frodo, Bilbo&quot;],</div><div class="line">	location: &quot;Shire&quot;</div><div class="line">&#125;;</div><div class="line">var accountStr = JSON.stringify(accountObj);</div><div class="line">console.log(accountStr);</div></pre></td></tr></table></figure></p>
<p>输出：<br><code>{&quot;name&quot;:&quot;Baggins&quot;,&quot;number&quot;:10645,&quot;numbers&quot;:[&quot;Frodo, Bilbo&quot;],&quot;location&quot;:&quot;Shire&quot;}</code>  </p>
<h2 id="5-2-使用-Buffer-模块缓冲数据"><a href="#5-2-使用-Buffer-模块缓冲数据" class="headerlink" title="5.2 使用 Buffer 模块缓冲数据"></a>5.2 使用 Buffer 模块缓冲数据</h2><h3 id="5-2-2-创建缓冲区"><a href="#5-2-2-创建缓冲区" class="headerlink" title="5.2.2 创建缓冲区"></a>5.2.2 创建缓冲区</h3><p>Buffer 对象实际上是原始的内存分配区。因此，必须在创建时确定其大小。创建 3 种方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Buffer(sizeInBytes)</div><div class="line">new Buffer(octetArray)</div><div class="line">new Buffer(string, [encodeing])</div></pre></td></tr></table></figure></p>
<p>例如，下面分别使用字节大小、一个八位字节的缓冲区，以及一个 UTF8 字符串来设定缓冲区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var buf256 = new Buffer(256);</div><div class="line">var bufOctets = new Buffer([0x6f, 0x63, 0x74, 0x65, 0x74, 0x73]);</div><div class="line">var bufUTF8 = new Buffer(&quot;Some UTF Text \uoob6 \u30c6 \u20ac&quot;, &apos;utf8&apos;);</div></pre></td></tr></table></figure></p>
<h3 id="5-2-3-写入缓冲区"><a href="#5-2-3-写入缓冲区" class="headerlink" title="5.2.3 写入缓冲区"></a>5.2.3 写入缓冲区</h3><p> 下面代码定义了一个缓冲区，以零填充。write() 方法在开头写一些文字，write(string, offset, length) 写额外的文本<br> 改变现有缓冲区的一部分。通过直接设置索引的值增加 + 到结束处。注意，buf256.write(“more text”, 9, 9) 语句写到<br> 缓冲区的中间，而 buf256[18] = 43 修改一个字节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// buffer_write.js：用各种方式来写入 Buffer 对象</div><div class="line">buf256 = new Buffer(256);</div><div class="line">buf256.fill(0);</div><div class="line">buf256.write(&quot;add some text&quot;);</div><div class="line">console.log(buf256.toString());</div><div class="line">buf256.write(&quot;more text&quot;, 9, 9);</div><div class="line">console.log(buf256.toString());</div><div class="line">buf256[18] = 43;</div><div class="line">console.log(buf256.toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ node buffer_write.js</div><div class="line">add some text</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">add some more text</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">add some more text+</div></pre></td></tr></table></figure></p>
<h3 id="5-2-4-从缓冲区读取"><a href="#5-2-4-从缓冲区读取" class="headerlink" title="5.2.4 从缓冲区读取"></a>5.2.4 从缓冲区读取</h3><p>最简单使用 toString() 方法将缓冲区的全部或一部分转换为字符串。也可以直接在缓冲区访问特定的索引，或使用 read()。<br>此外，Node.js 提供 StringDecoder 对象，它有 write(buffer) 方法来进行解码，并使用指定的编码写入缓冲区数据。<br>一下代码定义了 UTF8 编码的字符缓冲区，然后使用不带参数的 toString() 读取所有的缓冲区，之后用 encoding、start<br>和 end 参数读取缓冲区的一部分。然后使用 UTF8 编码创建 StringDecoder，并用它来把缓冲区的内容输出到控制台，<br>接下来，直接访问方法获取在索引 18 处的八进制字节值，用 readUInt32BE() 读取一个 32 位整数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// buffer_read.js： 从 Buffer 对象读取数据的各种方法</div><div class="line">bufUTF8 = new Buffer(&quot;Some UTF8 Text \u00b6 \u30c6 \u20ac&quot;, &apos;utf8&apos;);</div><div class="line">console.log(bufUTF8.toString());</div><div class="line">console.log(bufUTF8.toString(&apos;utf8&apos;, 5, 9));</div><div class="line">var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;</div><div class="line">var decoder = new StringDecoder(&apos;utf8&apos;);</div><div class="line">console.log(decoder.write(bufUTF8));</div><div class="line">console.log(bufUTF8[18].toString(16));</div><div class="line">console.log(bufUTF8.readUInt32BE(18).toString(16));</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node buffer_read.js</div><div class="line">Some UTF8 Text ¶ テ €</div><div class="line">UTF8</div><div class="line">Some UTF8 Text ¶ テ €</div><div class="line">e3</div><div class="line">e3838620</div></pre></td></tr></table></figure></p>
<h3 id="5-2-5-确定缓冲区长度"><a href="#5-2-5-确定缓冲区长度" class="headerlink" title="5.2.5 确定缓冲区长度"></a>5.2.5 确定缓冲区长度</h3><p>缓冲区处理的一项常见任务是确定其长度，尤其是当你从一个字符串动态创建一个缓冲区的时候。你可以通过在 Buffer 对象上<br>调用 .length 来确定缓冲区的长度。确定字符串将在缓冲区中占用的字节长度，不能使用 .length 属性，而是用<br>Buffer.byteLength(string, [encoding])。注意，缓冲区中字符串长度和字节长度直接的区别很重要，以下语句可以说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">“UTF8 text \u00b6&quot;.length;</div><div class="line">// 计算结果是 11</div><div class="line">BUffer.byteLength(&quot;UTF8 text \u00b6&quot;, &apos;utf8&apos;);</div><div class="line">// 计算结果是 12，因为它包含双字节字符</div><div class="line">Buffer(&quot;UTF8 text \u00b6&quot;).length;</div><div class="line">// 计算结果是 12，缓冲区上的 .length 返回的是字节长度</div></pre></td></tr></table></figure></p>
<h3 id="5-2-6-复制缓冲区"><a href="#5-2-6-复制缓冲区" class="headerlink" title="5.2.6 复制缓冲区"></a>5.2.6 复制缓冲区</h3><p>Node.js 为 Buffer 对象提供 copy(targetBuffer, [targetStart], [sourceStart], [sourceIndex]) 函数。<br>targetBuffer 参数是另一个 Buffer 对象， targetStart、sourceStart 和 sourceEnd 是源和目标缓冲区内的索引。  </p>
<blockquote>
<p><strong>注意</strong><br>若要从一个缓冲区复制字符串数据到另一个缓冲区，应确保两个缓冲区使用相同的编码；否则，对结果缓冲区解码时，<br>可能得到意想不到的结果。  </p>
</blockquote>
<p>也可以通过直接索引将一个缓冲区中的数据复制到另一个缓冲区，例如：<br><code>sourceBuffer[index] = destinationBuffer[index]</code>  </p>
<p>下面代码说明了将一个缓冲区的数据复制到另一个缓冲区的 3 个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var alphabet = new Buffer(&apos;abcdefghijklmnopqrstuvwxyz&apos;);</div><div class="line">console.log(alphabet.toString());</div><div class="line">// copy full buffer </div><div class="line">var blank = new Buffer(26);</div><div class="line">blank.fill();</div><div class="line">console.log(&quot;Blank: &quot; + blank.toString());</div><div class="line">alphabet.copy(blank);</div><div class="line">console.log(&quot;Blank: &quot; + blank.toString());</div><div class="line">// copy part of buffer</div><div class="line">var dashes = new Buffer(26);</div><div class="line">dashes.fill(&apos;-&apos;);</div><div class="line">console.log(&quot;Dashes: &quot; + dashes.toString());</div><div class="line">alphabet.copy(dashes, 10, 10, 15);</div><div class="line">console.log(&quot;Dashes: &quot; + dashes.toString());</div><div class="line">// copy to and from direct indexes of buffers</div><div class="line">var dots = new Buffer(&apos;----------------------------&apos;);</div><div class="line">dots.fill(&apos;.&apos;);</div><div class="line">console.log(&quot;dots: &quot; + dots.toString());</div><div class="line">for (var i = 0; i &lt; dots.length; i++) &#123;</div><div class="line">	if (i % 2) &#123;</div><div class="line">		dots[i] = alphabet[i];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">console.log(&quot;dots: &quot; + dots.toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node buffer_copy.js</div><div class="line">abcdefghijklmnopqrstuvwxyz</div><div class="line">Blank:</div><div class="line">Blank: abcdefghijklmnopqrstuvwxyz</div><div class="line">Dashes: --------------------------</div><div class="line">Dashes: ----------klmno-----------</div><div class="line">dots: ............................</div><div class="line">dots: .b.d.f.h.j.l.n.p.r.t.v.x.z.</div></pre></td></tr></table></figure></p>
<h3 id="5-2-7-对缓冲区切片"><a href="#5-2-7-对缓冲区切片" class="headerlink" title="5.2.7 对缓冲区切片"></a>5.2.7 对缓冲区切片</h3><p><strong>切片（slice）</strong> 是缓冲区的开始索引能和结束索引之间的部分。对缓冲区切片可以让你操作一个特定的快。<br>可以使用 slice([start], [end]) 创建切片，它返回一个 Buffer 对象，其指向原缓冲区的 start 索引，并具有<br>end - start 的长度。请记住，切片与副本不同。编辑副本不影响原缓冲区，<strong>编辑切片，会改变原缓冲区</strong>。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 创建和操作一个 Buffer 对象的切片</div><div class="line">var numbers = new Buffer(&quot;123456789&quot;);</div><div class="line">console.log(numbers.toString());</div><div class="line">var slice = numbers.slice(3, 6);</div><div class="line">console.log(slice.toString());</div><div class="line">slice[0] = &apos;#&apos;.charCodeAt(0);</div><div class="line">console.log(slice.toString());</div><div class="line">console.log(numbers.toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node buffer_slice.js</div><div class="line">123456789</div><div class="line">456</div><div class="line">#56</div><div class="line">123#56789</div></pre></td></tr></table></figure></p>
<h3 id="5-2-8-拼接缓冲区"><a href="#5-2-8-拼接缓冲区" class="headerlink" title="5.2.8 拼接缓冲区"></a>5.2.8 拼接缓冲区</h3><p>可以把两个或多个 Buffer 对象拼接在一起，形成一个新的缓冲区。concat(list, [totalLength]) 方法接受 Buffer 对象<br>的数组作为第一个参数，并把定义缓冲区最大字节数的 totalLength 作为可选的第二个参数。Buffer 对象按照他们出现在列表<br>中的顺序被拼接，一个新的 Buffer 对象被返回，它包含至多 totalLength 字节的原始缓冲区的内容。<br>如果不提供 totalLength 参数，concat() 就计算出总长度。但是，这样它必须遍历列表，所以提供 totalLength 执行得更快<br>一点。<br>一下代码线拼接基 Buffer 对象和一个缓冲区，然后再拼接另一个缓冲区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 拼接 Buffer 字符串</div><div class="line">var af = new Buffer(&quot;African Swallow?&quot;);</div><div class="line">var eu = new Buffer(&quot;European Swallow?&quot;);</div><div class="line">var question = new Buffer(&quot;Air Speed Velocity of an &quot;);</div><div class="line">console.log(Buffer.concat([question, af]).toString());</div><div class="line">console.log(Buffer.concat([question, eu]).toString());</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ node buffer_concat.js</div><div class="line">Air Speed Velocity of an African Swallow?</div><div class="line">Air Speed Velocity of an European Swallow?</div></pre></td></tr></table></figure></p>
<h2 id="5-3-使用-Stream-模块来传递数据"><a href="#5-3-使用-Stream-模块来传递数据" class="headerlink" title="5.3 使用 Stream 模块来传递数据"></a>5.3 使用 Stream 模块来传递数据</h2><p>数据流是可读，可写，或既可读又可写的内存结构。<br>流的目的是提供一种从一个地方向另一个地方传送数据的通用机制。它们还公开各种事件，如数据可被读取时的 data，当<br>错误发生时的 error 等等，这样可以注册监听器来在流变为可用或已准备好被写入时处理数据。<br>流一般用于 HTTP 数据和文件。可以作为读取流，打开文件，或者从 HTTP 请求访问数据，并读出所需的字节。  </p>
<h3 id="5-3-1-Readable-流"><a href="#5-3-1-Readable-流" class="headerlink" title="5.3.1 Readable 流"></a>5.3.1 Readable 流</h3><p>Readable 流旨在提供一种机制，以方便地读取从其他来源进入应用程序的数据。<br>常见实例：  </p>
<ul>
<li>在客户端的 HTTP 响应</li>
<li>在服务器的 HTTP 请求</li>
<li>fs 读取流</li>
<li>zlib 流</li>
<li>TCP 套接字</li>
<li>子进程的 stdout 和 stderr</li>
<li>process.stdin</li>
</ul>
<p>Readable 流提供 read([size]) 方法来读取数据，size 指定从流中读取的字节数。read() 可以返回一个 String 对象、<br>Buffer 对象或 null。Readable 流也公开了以下事件：  </p>
<ul>
<li>readable：在数据块可以从流中读取的时候发出。</li>
<li>data：类似于 readable，不同之处在于，当数据的事件处理程序被连接时，流转变成流动的模式，并且数据处理程序被<br>连续地调用，直到所有数据都被用尽。</li>
<li>end：当数据将不再被提供时由流发出。</li>
<li>close：当底层的资源，如文件，已关闭时发出。</li>
<li>error：当在接收数据中出现错误时发出。</li>
</ul>
<p>Readable 对象也提供了许多函数： </p>
<ul>
<li>read([size])：从流中读取数据。这些数据可以是 String、Buffer 或者 null （null 表示没有剩下任何更多的数据）。<br>如果指定 size 参数，那么被读取的数据将仅限于那个字节数。</li>
<li>setEncoding(encoding)：设置从 read() 请求读取返回 String 时使用的编码。</li>
<li>pause()：暂停从该对象发出的 data 事件。</li>
<li>resume()：恢复从该对象发出的 data 事件。</li>
<li>pipe(destination, [options])：把这个流的输出传输到 destination（目的地）指定的 Writable 流对象。options 是<br>一个 JavaScript 对象。例如，{end:true} 当 Readable 结束时就结束 Writable 目的地。</li>
<li>unpipe([destination])：从 Writable 目的地断开这一对象。</li>
</ul>
<p>为了实现自定义 Readable 流对象，需要首先继承 Readable 流的功能。最简单的方法是使用 util 模块的 inherits() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(MyReadableStream, stream.Readable);</div></pre></td></tr></table></figure></p>
<p>然后创建对象调用的实例：<br><code>stream.Readable.call(this, opt);</code><br>还需要实现一个调用 push() 来输出 Readable 对象中的数据的 _read() 方法。push() 调用应推入的是一个 String、<br>Buffer 或者 null。<br>下面实现了一个 Readable 流，并从中读取数据。注意，Answers() 类继承自 Readable，然后实现了<br>Answers.prototype._read() 函数来处理数据的推出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 实现一个 Readable 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Answers, stream.Readable);</div><div class="line">function Answers(opt) &#123;</div><div class="line">	stream.Readable.call(this, opt);</div><div class="line">	this.quotes = [&quot;yes&quot;, &quot;no&quot;, &quot;maybe&quot;];</div><div class="line">	this._index = 0;</div><div class="line">&#125;</div><div class="line">Answers.prototype._read = function() &#123;</div><div class="line">	if (this._index &gt; this.quotes.length) &#123;</div><div class="line">		this.push(null);</div><div class="line">	&#125; else &#123;</div><div class="line">		this.push(this.quotes[this._index]);</div><div class="line">		this._index += 1;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var r = new Answers();</div><div class="line">// 直接 read() 调用从流中读取第一个条目</div><div class="line">console.log(&quot;Direct read: &quot; + r.read().toString());</div><div class="line">// 数据处理程序读取其余条目</div><div class="line">r.on(&apos;data&apos;, function(data)&#123;</div><div class="line">	console.log(&quot;Callback read: &quot; + data.toString());</div><div class="line">&#125;);</div><div class="line">r.on(&apos;end&apos;, function(data)&#123;</div><div class="line">	console.log(&quot;No more answers.&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node stream_read.js</div><div class="line">Direct read: yes</div><div class="line">Callback read: no</div><div class="line">Callback read: maybe</div><div class="line">No more answers.</div></pre></td></tr></table></figure></p>
<h3 id="5-3-2-Writable-流"><a href="#5-3-2-Writable-流" class="headerlink" title="5.3.2 Writable 流"></a>5.3.2 Writable 流</h3><p>Writable 流旨在提供把数据写入一种可以轻松地在代码的另一个区域被使用的形式的机制。<br>Writable 流的常见实例：  </p>
<ul>
<li>在客户端的 HTTP 请求</li>
<li>在服务器的 HTTP 响应</li>
<li>fs 写入刘</li>
<li>zlib 流</li>
<li>TCP 套接字</li>
<li>子进程的 stdin</li>
<li>process.stdout 和 process.stderr</li>
</ul>
<p>Writable 流提供 write(chunk, [encoding], [callback]) 方法来将数据写入流中。其中，chunk（数据块）中包含要<br>写入的数据；encoding 指定字符串的编码；callback 指定当数据已经完全刷新时执行的一个回调函数。如果数据被成功写入，<br>则 write() 函数返回 true。<br>Writable 公开了以下事件：  </p>
<ul>
<li>drain：在 write() 调用返回 false 后，当准备好开始写更多的数据时，发出此事件通知监听器。</li>
<li>finish：当 end() 在 Writable 对象上被调用，所有的数据都被刷新，并且不会有更多的数据将被接收时发出此事件。</li>
<li>pipe：当 pipe() 方法在 Readable 流上被调用，以添加此 Writable 为目的地时，发出此事件。</li>
<li>unpipe： 当 unpipe() 方法在 Readable 流上被调用，以删除此 Writable 为目的地时，发出此事件。</li>
</ul>
<p>可用的 Writable 流对象的方法：  </p>
<ul>
<li>write(chunk, [encoding], [callback])：将数据块写入流对象的数据位置。该数据可以是字符串或缓冲区。如果<br>指定 encoding，那么将其用于对字符串数据的编码。如果指定 callback，那么它在数据已被刷新后调用。</li>
<li>end([chunk], [encoding], [callback])：与 write() 相同，但是它把 Writable 对象置于不再接收数据的状态，<br>并发送 finish 事件。</li>
</ul>
<p>实现自定义 Writable 流对象，首先继承 Writable 流的功能，使用 util模块的 inherits() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(MyWritableStream, stream.Writable);</div></pre></td></tr></table></figure></p>
<p>创建对象调用的实例：<br><code>stream.Writable.call(this, opt);</code><br>还需实现一个 _write(data, encoding, callback) 方法存储 Writable 对象的数据。<br>下面代码说明了实现和写入 Writable 流的基本知识：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 实现一个 Writable 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Writer, stream.Writable);</div><div class="line">function Writer(opt) &#123;</div><div class="line">	stream.Writable.call(this, opt);</div><div class="line">	this.data = new Array();</div><div class="line">&#125;</div><div class="line">Writer.prototype._write = function(data, encoding, callback) &#123;</div><div class="line">	this.data.push(data.toString(&apos;utf8&apos;));</div><div class="line">	console.log(&quot;Adding: &quot; + data);</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">var w = new Writer();</div><div class="line">for (var i = 1; i &lt;= 5; i++) &#123;</div><div class="line">	w.write(&quot;Item&quot; + i, &apos;utf8&apos;);</div><div class="line">&#125;</div><div class="line">w.end(&quot;ItemLast&quot;);</div><div class="line">console.log(w.data);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ node stream_write.js</div><div class="line">Adding: Item1</div><div class="line">Adding: Item2</div><div class="line">Adding: Item3</div><div class="line">Adding: Item4</div><div class="line">Adding: Item5</div><div class="line">Adding: ItemLast</div><div class="line">[ &apos;Item1&apos;, &apos;Item2&apos;, &apos;Item3&apos;, &apos;Item4&apos;, &apos;Item5&apos;, &apos;ItemLast&apos; ]</div></pre></td></tr></table></figure></p>
<h3 id="5-3-3-Duplex-流"><a href="#5-3-3-Duplex-流" class="headerlink" title="5.3.3 Duplex 流"></a>5.3.3 Duplex 流</h3><p>Duplex（双向）流是结合可读写功能的流。Duplex 流的很好地例子是 TCP 套接字连接。可在创建套接字后读取和写入它。<br>实现自定义 Duplex 流对象，首先继承 Duplex 流的功能，使用 util 模块的 inherits() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(MuDuplexStream, stream.Duplex);</div></pre></td></tr></table></figure></p>
<p>然后创建对象调用实例：<br><code>stream.Duplex.call(this, opt);</code><br>创建一个 Duplex 流的 opt 参数接受一个 allowHalfOpen 数次那个设置为 true 或 false 的对象。true：即使可写入端<br>已经结束，可读取端也保持打开状态，反之亦然。false：结束可写入端也会结束可读取端，反之亦然。<br>当实现一个全 Duplex 流时，在原型化 Duplex 类的时候需要同时实现 _read(size) 和 _write(data, encoding, callback)<br>方法。<br>下面代码实现、写入、读取 Duplex 流。Duplex() 类继承自 Duplex 流，并实现了基本的 _write() 函数来将数据存储在该<br>对象中的数组内。_read() 函数使用 shift() 来获得此数组的第一个条目，如果等于“stop”，那么推入 null；如果有值，<br>那么推入它；或者如果没有值，则设置超时时间定时器来回调到 _read() 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">// 实现 Duplex 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Duplexer, stream.Duplex);</div><div class="line">function Duplexer(opt) &#123;</div><div class="line">	stream.Duplex.call(this, opt);</div><div class="line">	this.data = [];</div><div class="line">&#125;</div><div class="line">Duplexer.prototype._read = function readItem(size) &#123;</div><div class="line">	var chunk = this.data.shift();</div><div class="line">	if (chunk == &quot;stop&quot;) &#123;</div><div class="line">		this.push(null);</div><div class="line">	&#125; else &#123;</div><div class="line">		if (chunk) &#123;</div><div class="line">			this.push(chunk);</div><div class="line">		&#125; else &#123;</div><div class="line">			setTimeout(readItem.bind(this), 500, size);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">Duplexer.prototype._write = function(data, encoding, callback) &#123;</div><div class="line">	this.data.push(data);</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">var d = new Duplexer();</div><div class="line">d.on(&apos;data&apos;, function(chunk)&#123;</div><div class="line">	console.log(&apos;read: &apos;, chunk.toString());</div><div class="line">&#125;);</div><div class="line">d.on(&apos;end&apos;, function()&#123;</div><div class="line">	console.log(&apos;Message Complete&apos;);</div><div class="line">&#125;);</div><div class="line">d.write(&quot;I think, &quot;);</div><div class="line">d.write(&quot;therefore &quot;);</div><div class="line">d.write(&quot;I am.&quot;);</div><div class="line">d.write(&quot;Rene Descartes&quot;);</div><div class="line">d.write(&quot;stop&quot;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node stream_duplex.js</div><div class="line">read:  I think,</div><div class="line">read:  therefore</div><div class="line">read:  I am.</div><div class="line">read:  Rene Descartes</div><div class="line">Message Complete</div></pre></td></tr></table></figure></p>
<h3 id="5-3-4-Transform-流"><a href="#5-3-4-Transform-流" class="headerlink" title="5.3.4 Transform 流"></a>5.3.4 Transform 流</h3><p>Transform（变换）流扩展了 Duplex 流，但它修改 Writable 流和 Readable 流之间的数据。当需要修改从一个系统到<br>另一个系统的数据时，此类型会非常有用。<br>实例：  </p>
<ul>
<li>zlib 流</li>
<li>crypto 流</li>
</ul>
<p>Duplex 和 Transform 流区别：Transform 流不用实现 _read() 和 _write() 原型方法。这些被作为直通函数提供。但是<br>需要实现 _transform(chunk, encoding, callback) 和 _flush(callback) 方法。此 _transform() 方法应该接受来自<br>write() 请求的数据，对其修改，并推出修改后的数据。  </p>
<p>以下代码，实现 Transform 流，这个流接受 JSON 字符串，将它们转换为对象，然后发出发送对象的名为 object 的自定义<br>事件给所有监听器。该 _transform() 函数也修改对象来包括一个 handled 属性，然后以字符串形式发送。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 实现 Transform 流对象</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(JSONObjectStream, stream.Transform);</div><div class="line">function JSONObjectStream(opt) &#123;</div><div class="line">	stream.Transform.call(this, opt);</div><div class="line">&#125;</div><div class="line">JSONObjectStream.prototype._transform = function(data, encoding, callback) &#123;</div><div class="line">	object = data ? JSON.parse(data.toString()) : &quot;&quot;;</div><div class="line">	this.emit(&quot;object&quot;, object);</div><div class="line">	object.handled = true;</div><div class="line">	this.push(JSON.stringify(object));</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">JSONObjectStream.prototype._flush = function(cb) &#123;</div><div class="line">	cb();</div><div class="line">&#125;;</div><div class="line">var tc = new JSONObjectStream();</div><div class="line">tc.on(&quot;object&quot;, function() &#123;</div><div class="line">	console.log(&quot;Name: %s&quot;, object.name);</div><div class="line">	console.log(&quot;Color: %s&quot;, object.color);</div><div class="line">&#125;);</div><div class="line">tc.on(&quot;data&quot;, function(data) &#123;</div><div class="line">	console.log(&quot;Data: %s&quot;, data.toString());</div><div class="line">&#125;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Carolinus&quot;, &quot;color&quot;: &quot;Green&quot;&#125;&apos;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Solarius&quot;, &quot;color&quot;: &quot;Blue&quot;&#125;&apos;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Lo Tae Zhao&quot;, &quot;color&quot;: &quot;Gold&quot;&#125;&apos;);</div><div class="line">tc.write(&apos;&#123;&quot;name&quot;:&quot;Ommadon&quot;, &quot;color&quot;: &quot;Red&quot;&#125;&apos;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ node stream_transform.js</div><div class="line">Name: Carolinus</div><div class="line">Color: Green</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Carolinus&quot;,&quot;color&quot;:&quot;Green&quot;,&quot;handled&quot;:true&#125;</div><div class="line">Name: Solarius</div><div class="line">Color: Blue</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Solarius&quot;,&quot;color&quot;:&quot;Blue&quot;,&quot;handled&quot;:true&#125;</div><div class="line">Name: Lo Tae Zhao</div><div class="line">Color: Gold</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Lo Tae Zhao&quot;,&quot;color&quot;:&quot;Gold&quot;,&quot;handled&quot;:true&#125;</div><div class="line">Name: Ommadon</div><div class="line">Color: Red</div><div class="line">Data: &#123;&quot;name&quot;:&quot;Ommadon&quot;,&quot;color&quot;:&quot;Red&quot;,&quot;handled&quot;:true&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-3-5-把-Readable-流用管道输送到-Writable-流"><a href="#5-3-5-把-Readable-流用管道输送到-Writable-流" class="headerlink" title="5.3.5 把 Readable 流用管道输送到 Writable 流"></a>5.3.5 把 Readable 流用管道输送到 Writable 流</h3><p>通过 pipe(writableStream, [options]) 函数把 Readable 流的输出直接输入到 Writable 流。options 参数接受一个<br>end 属性为 true 或 false 的对象。true：Writable 流随着 Readable 流的结束而结束。这是默认行为。例如：<br><code>readStream.pipe(writeStream, {end:true});</code><br>可以使用 unpipe(destinationStream) 选项来打破管道。<br>下面代码实现了一个 Readable 流和 Writable 流，然后使用 pipe() 函数把它们链接在一起。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 把 Readable 流传送到 Writable 流</div><div class="line">var stream = require(&apos;stream&apos;);</div><div class="line">var util = require(&apos;util&apos;);</div><div class="line">util.inherits(Reader, stream.Readable);</div><div class="line">util.inherits(Writer, stream.Writable);</div><div class="line">function Reader(opt) &#123;</div><div class="line">	stream.Readable.call(this, opt);</div><div class="line">	this._index = 1;</div><div class="line">&#125;</div><div class="line">Reader.prototype._read = function(size) &#123;</div><div class="line">	var i = this._index++;</div><div class="line">	if (i &gt; 10) &#123;</div><div class="line">		this.push(null);</div><div class="line">	&#125; else &#123;</div><div class="line">		this.push(&quot;Item &quot; + i.toString());</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">function Writer(opt) &#123;</div><div class="line">	stream.Writable.call(this, opt);</div><div class="line">	this._index = 1;</div><div class="line">&#125;</div><div class="line">Writer.prototype._write = function(data, encoding, callback) &#123;</div><div class="line">	console.log(data.toString());</div><div class="line">	callback();</div><div class="line">&#125;;</div><div class="line">var r = new Reader();</div><div class="line">var w = new Writer();</div><div class="line">r.pipe(w);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ node stream_piped.js</div><div class="line">Item 1</div><div class="line">Item 2</div><div class="line">Item 3</div><div class="line">Item 4</div><div class="line">Item 5</div><div class="line">Item 6</div><div class="line">Item 7</div><div class="line">Item 8</div><div class="line">Item 9</div><div class="line">Item 10</div></pre></td></tr></table></figure></p>
<h2 id="5-4-用-Zlib-压缩与解压缩数据"><a href="#5-4-用-Zlib-压缩与解压缩数据" class="headerlink" title="5.4 用 Zlib 压缩与解压缩数据"></a>5.4 用 Zlib 压缩与解压缩数据</h2><p>在使用大的系统或移动大量数据时，压缩/解压缩数据的能力极为有用。<br>记住，压缩数据需要花费 CPU 周期，所以在招致压缩/解压缩成本之前，应该确信压缩数据会带来好处。<br>Zlib 支持如下压缩方法：  </p>
<ul>
<li>gzip/gunzip：标准 gzip 压缩。</li>
<li>deflate/inflate：基于 Huffman 编码的标准 deflate 压缩算法。</li>
<li>deflateRaw/inflateRaw：针对原始缓冲区的 deflate 压缩算法。</li>
</ul>
<h3 id="5-4-1-压缩和解压缩缓冲区"><a href="#5-4-1-压缩和解压缩缓冲区" class="headerlink" title="5.4.1 压缩和解压缩缓冲区"></a>5.4.1 压缩和解压缩缓冲区</h3><p>Zlib 模块提供了几个辅助含税，基本格式 function(buffer, callback)，其中 buffer 是被压缩/解压缩的缓冲区，<br>callback 是压缩/解压缩发生之后所执行的回调函数。<br>以下几种示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">// 使用 Zlib 模块压缩/解压缩缓冲区</div><div class="line">var zlib = require(&apos;zlib&apos;);</div><div class="line">var input = &apos;..................text................&apos;;</div><div class="line">zlib.deflate(input, function(err, buffer) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		console.log(&quot;deflate (%s): &quot;, buffer.length, buffer.toString(&apos;base64&apos;));</div><div class="line">		zlib.inflate(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;inflate (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		zlib.unzip(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;unzip deflate (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">zlib.deflateRaw(input, function(err, buffer) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		console.log(&quot;deflateRaw (%s): &quot;, buffer.length, buffer.toString(&apos;base64&apos;));</div><div class="line">		zlib.inflateRaw(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;inflateRaw (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">zlib.gzip(input, function(err, buffer) &#123;</div><div class="line">	if (!err) &#123;</div><div class="line">		console.log(&quot;gzip (%s): &quot;, buffer.length, buffer.toString(&apos;base64&apos;));</div><div class="line">		zlib.gunzip(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;gunzip (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		zlib.unzip(buffer, function(err, buffer) &#123;</div><div class="line">			if (!err) &#123;</div><div class="line">				console.log(&quot;unzip gzip (%s): &quot;, buffer.length, buffer.toString());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ node zlib_buffers.js</div><div class="line">deflate (17):  eJzT00MHJakVJehiAJizB+I=</div><div class="line">deflateRaw (11):  09NDByWpFSXoYgA=</div><div class="line">gzip (29):  H4sIAAAAAAAACtPTQwclqRUl6GIAandyAiYAAAA=</div><div class="line">inflate (38):  ..................text................</div><div class="line">unzip deflate (38):  ..................text................</div><div class="line">inflateRaw (38):  ..................text................</div><div class="line">gunzip (38):  ..................text................</div><div class="line">unzip gzip (38):  ..................text................</div></pre></td></tr></table></figure></p>
<h3 id="5-2-4-压缩-解压缩流"><a href="#5-2-4-压缩-解压缩流" class="headerlink" title="5.2.4 压缩/解压缩流"></a>5.2.4 压缩/解压缩流</h3><p>对流操作使用 pipe() 函数，用过压缩/解压缩对象把数据从一个流输送到另一个流。 适用于把任何 Readable 数据压缩成<br>Writable 流。<br>示例使用 fs.ReadStream 和 fs.WriteStream 压缩文件内容，通过使用 xlib.Gzip() 对象压缩一个文件的内容，然后<br>用 zlib.Gunzip() 对象对它解压缩。注意，在试图解压缩文件，以允许数据被刷新到磁盘之前，有 3 秒的超时时间延迟。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 使用 Zlib 模块压缩/解压缩文件流</div><div class="line">var zlib = require(&quot;zlib&quot;);</div><div class="line">var gzip = zlib.createGzip();</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">var inFile = fs.createReadStream(&apos;zlib_file.js&apos;);</div><div class="line">var outFile = fs.createWriteStream(&apos;zlib_file.gz&apos;);</div><div class="line">inFile.pipe(gzip).pipe(outFile);</div><div class="line">setTimeout(function()&#123;</div><div class="line">	var gunzip = zlib.createUnzip(&#123;flush: zlib.Z_FULL_FLUSH&#125;);</div><div class="line">	var inFile = fs.createReadStream(&apos;zlib_file.gz&apos;);</div><div class="line">	var outFile = fs.createWriteStream(&apos;zlib_file.unzipped&apos;);</div><div class="line">	inFile.pipe(gunzip).pipe(outFile);</div><div class="line">&#125;, 3000);</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/在 Node.js 中使用事件、监听器、定时器和回调/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/在 Node.js 中使用事件、监听器、定时器和回调/" itemprop="url">在 Node.js 中使用事件、监听器、定时器和回调</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T21:31:29+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在-Node-js-中使用事件、监听器、定时器和回调"><a href="#在-Node-js-中使用事件、监听器、定时器和回调" class="headerlink" title="在 Node.js 中使用事件、监听器、定时器和回调"></a>在 Node.js 中使用事件、监听器、定时器和回调</h1><h3 id="4-2-1-实现定时器"><a href="#4-2-1-实现定时器" class="headerlink" title="4.2.1 实现定时器"></a>4.2.1 实现定时器</h3><p><strong>用超时时间来延迟工作</strong><br>超时定时器用于将工作延迟一个特定时间数量。当时间到了时，回调函数执行，而定时器会消失。对于只需要执行一次的工作，<br>应当使用超时时间。<br>创建超时时间定时器使用 Node.js 中内置的 setTimeout(callback, delayMilliSeconds, [args]) 方法。当你调用<br>setTimeout() 时，回调函数在 delayMilliSeconds 到期后执行。例如，下面的语句在 1 秒后执行 myFunc()：<br><code>setTimeout(myFunc, 1000)</code><br>setTimeout() 函数返回定时器对象的 ID，可以在 delayMilliSeconds 到期前任何时候把此 ID 传递给 clearTimeout(timeoutId)<br>来取消超时时间函数。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myTimeout = setTimeout(myFunc,, 100000);</div><div class="line">...</div><div class="line">clearTimeout(myTimeout);</div></pre></td></tr></table></figure></p>
<p>以下代码实现了调用 simpleTimeout() 函数的一系列简单超时时间，它输出自从超时时间被安排后经历的毫秒数。请注意，<br>setTimeout() 的调用次序是无关紧要的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// simple_timer.js 在不同的时间间隔实现了一系列超时时间</div><div class="line">function simpleTimeout(consoleTimer) &#123;</div><div class="line">	console.timeEnd(consoleTimer);</div><div class="line">&#125;</div><div class="line">console.time(&quot;twoSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 2000, &quot;twoSecond&quot;);</div><div class="line">console.time(&quot;oneSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 1000, &quot;oneSecond&quot;);</div><div class="line">console.time(&quot;fiveSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 5000, &quot;fiveSecond&quot;);</div><div class="line">console.time(&quot;50MilliSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 50, &quot;50MilliSecond&quot;);</div></pre></td></tr></table></figure></p>
<p>下面结果按照其中的延时结束的顺序出现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node simple_timer.js</div><div class="line">50MilliSecond: 51.578ms</div><div class="line">oneSecond: 999.679ms</div><div class="line">twoSecond: 2001.768ms</div><div class="line">fiveSecond: 5000.161ms</div></pre></td></tr></table></figure></p>
<p><strong>用时间间隔执行定期工作</strong><br>时间间隔定时器用于按定期的延迟时间执行工作。当延时结束时，回调函数被执行，然后再次重新调度为改延迟时间，对于必须<br>定期进行的工作，你应该使用时间间隔。<br>可以通过 Node,js 中内置的 setInterval(callback, delayMilliSeconds, [args]) 方法创建时间间隔计时器。当你调用<br>setInterval() 时，么个 delayMilliSeconds 间隔到后，回调函数执行。例如，下面的语句每秒执行一次  myFunc()：<br><code>setInterval(myFunc, 1000);</code><br>setInterval() 函数返回定时器对象的 ID，你可以在 delayMilliSeconds 到期前把 ID 传递给 clearInterval(intervalId)<br>来取消超时时间函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myInterval = setInterval(myFunc, 1000);</div><div class="line">...</div><div class="line">clearInterval(myInterval);</div></pre></td></tr></table></figure></p>
<p>下面的代码实现了一系列在不同的时间间隔更新变量 x、y 和 z 值得简单时间间隔回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// simple_interval.js 在不同的时间间隔实现了一系列的更新回调</div><div class="line">var x=0, y=0, z=0;</div><div class="line">function displayValue() &#123;</div><div class="line">	console.log(&quot;X=%d; Y=%d; Z=%d&quot;, x, y, z);</div><div class="line">&#125;</div><div class="line">function updateX() &#123;</div><div class="line">	x += 1;</div><div class="line">&#125;</div><div class="line">function updateY() &#123;</div><div class="line">	y += 1;</div><div class="line">&#125;</div><div class="line">function updateZ() &#123;</div><div class="line">	z += 1;</div><div class="line">	displayValue();</div><div class="line">&#125;</div><div class="line">setInterval(updateX, 500);</div><div class="line">setInterval(updateY, 1000);</div><div class="line">setInterval(updateZ, 2000);</div></pre></td></tr></table></figure></p>
<p>请注意 x、y 和 z 的值的改变不同，因为该时间间隔量是不同的；x 得递增速度是 y 的两倍，y 的递增速度又是 z 的两倍，<br>输出如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ node simple_interval.js</div><div class="line">X=3; Y=1; Z=1</div><div class="line">X=7; Y=3; Z=2</div><div class="line">X=11; Y=5; Z=3</div><div class="line">X=15; Y=7; Z=4</div><div class="line">X=19; Y=9; Z=5</div><div class="line">X=23; Y=11; Z=6</div><div class="line">X=27; Y=13; Z=7</div><div class="line">X=31; Y=15; Z=8</div><div class="line">X=35; Y=17; Z=9</div><div class="line">X=39; Y=19; Z=10</div><div class="line">X=43; Y=21; Z=11</div><div class="line">X=47; Y=23; Z=12</div></pre></td></tr></table></figure></p>
<p><strong>使用及时计时器立即执行工作</strong><br>即时计时器用来在 I/O 事件的回调函数开始执行后，但任何超时时间或时间间隔事件被执行之前，立刻执行工作。它们允许你<br>把工作调度为在事件队列中的当前事件完成之后执行。你应该使用即时定时器为其他回调产生长期运行的执行段，以防止 I/O<br>事件饥饿。<br>可以使用 Node.js 中内置的 setImmediate(callback, [args]) 方法创建即时计时器。当你调用 setImmediate() 时，<br>回调函数被放置在事件队列中，并在遍历事件队列循环的每次迭代中，在 I/O 有机会被调用后弹出一次。例如，下面的代码调度<br>myFunc() 来在遍历事件队列的下一个周期内执行：<br><code>setimmediate(myFunc(), 1000);</code><br>setImmediate() 函数返回一个定时器对象的 ID，你可以在从事件队列提取出它前的任何时候把 ID 传递给 clearImmediate(<br>immediateId)。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myImmediate = setImmediate(myFunc);</div><div class="line">...</div><div class="line">clearImmediate(myImmediate);</div></pre></td></tr></table></figure></p>
<p><strong>从事件循环中取消定时器引用</strong><br>当定时器事件回调是留在事件队列中的仅有事件时，通常你不会希望它们继续被调度。setInterval 和 setTimeout 返回的对象<br>中的 unref() 函数，能在这些事件是队列中仅有的事件时，通知事件循环不要继续。<br>例如，下面的代码取消 myInterval 时间间隔定时器引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myInterval = setInterval(myFunc);</div><div class="line">myInterval.unref();</div></pre></td></tr></table></figure></p>
<p>如果以后由于某种原因，你不想在时间间隔函数是留在队列中的仅有事件时终止程序，就可以使用 ref() 函数来重新引用它：<br><code>myInterval.ref()</code>  </p>
<blockquote>
<p><strong>警告</strong><br>当 unref() 与 setTimeout 定时器结合使用时，要用一个独立的定时器来唤醒时间循环。大量使用这些功能会对你<br>的代码性能产生不利影响，所以应该尽量少地创建它们。  </p>
</blockquote>
<h3 id="4-2-2-使用-nextTick-来调度工作"><a href="#4-2-2-使用-nextTick-来调度工作" class="headerlink" title="4.2.2 使用 nextTick 来调度工作"></a>4.2.2 使用 nextTick 来调度工作</h3><p>在事件队列上调度工作的一个非常有用的方法是使用 process.nextTick(callback) 函数。此函数调度要在事件循环的下一次<br>循环中运行的工作。不像 setImmediate() 方法，nextTick() 在 I/O 事件被触发之前执行。这可能会导致 I/O 事件的饥饿，<br>所以 Node.js 通过默认值为 1000 的 process.maxTickDepth 来限制事件队列的每次循环可执行的 nextTick 事件的数目。<br>下面的代码说明了使用阻塞 I/O 调用、定时器和 nextTick() 时，事件的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// nexttick.js：实现了一系列阻塞 fs 调用，即时计时器和 nextTick() 调用来显示执行顺序</div><div class="line">var fs = require(&quot;fs&quot;);</div><div class="line">fs.stat(&quot;nexttick.js&quot;, function(err, stats) &#123;</div><div class="line">	if(stats) &#123;</div><div class="line">		console.log(&quot;nexttick.js Exists&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">setImmediate(function() &#123;</div><div class="line">	console.log(&quot;Immediate Timer 1 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">setImmediate(function() &#123;</div><div class="line">	console.log(&quot;Immediate Timer 2 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">process.nextTick(function() &#123;</div><div class="line">	console.log(&quot;Next Tick 1 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">process.nextTick(function() &#123;</div><div class="line">	console.log(&quot;Next Tick 2 Executed&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出如下，显示 nextTick() 调用先得到执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node nexttick.js</div><div class="line">Next Tick 1 Executed</div><div class="line">Next Tick 2 Executed</div><div class="line">Immediate Timer 1 Executed</div><div class="line">Immediate Timer 2 Executed</div><div class="line">nexttick.js Exists</div></pre></td></tr></table></figure></p>
<h3 id="4-2-3-实现事件发射器和监听器"><a href="#4-2-3-实现事件发射器和监听器" class="headerlink" title="4.2.3 实现事件发射器和监听器"></a>4.2.3 实现事件发射器和监听器</h3><p>本节重点介绍创建自己的自定义事件，以及实现党一个事件被发出时执行的监听器回调。<br><strong>将自定义事件添加到 JavaSript 对象</strong><br>事件使用一个 EventEmitter 对象来发出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var events = require(&apos;events&apos;);</div><div class="line">var emitter = new events.EventEmitter();</div><div class="line">emitter.emit(&quot;simpleEvent&apos;);</div></pre></td></tr></table></figure></p>
<p>直接把事件添加到 JavaScript 对象，需要通过在对象实例中调用 events.EventEmitter.call(this) 来在对象中继承<br>EventEmitter 功能，还需要把 events.EventEmitter.prototype 添加到对象的原型中。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function MyObj() &#123;</div><div class="line">    Events.EventEmitter.call(this);</div><div class="line">&#125;</div><div class="line">MyObj.prototype.__proto__ = events.EventEmitter.prototype;</div></pre></td></tr></table></figure></p>
<p>然后，就可以直接从对象实例中触发事件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myObj = new MyObj();</div><div class="line">myObj.emit(&quot;someEvent&quot;):</div></pre></td></tr></table></figure></p>
<p><strong>把事件监听器添加到对象</strong><br>一旦有了一个会发出事件的对象实例，就可以喂自己所关心的事件添加监听器。可以通过使用下面的功能之一把监听器添加到<br>EventEmitter 对象。  </p>
<ul>
<li><strong>.addListener(eventName, callback)</strong>：将回调函数附加到对象的监听器中。每当 eventName 事件被触发时，<br>回调函数就被放置在事件队列中执行。</li>
<li><strong>.on(eventName, callback)</strong>：同 .addListener()。</li>
<li><strong>.once(eventName, callback)</strong>：只有 eventName 事件第一次被触发时，回调函数才被放置在事件队列中执行。  </li>
</ul>
<p>例如，要在前面定义的 MyObject EventEmitter 类的实例中增加一个监听器，可以使用如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function myCallback() &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">var myObject = new MyObj();</div><div class="line">myObject.on(&quot;someEvent&quot;, myCallback);</div></pre></td></tr></table></figure></p>
<p><strong>从对象中删除监听器</strong><br>监听器会导致开销，只在必要时使用。Node.js 在 EventEmitter 对象上提供了多个辅助函数来管理监听器。  </p>
<ul>
<li><strong>.listener(eventName)：</strong> 返回一个连接到 eventName 事件的监听器函数的数组。</li>
<li><strong>.setMaxListeners(n)：</strong> 如果多于 n 的监听器都加入到 EventEmitter 对象，就会触发警报。默认值 10。</li>
<li><strong>.removeListener(eventName, callback)：</strong> 将 callback 函数从 EventEmitter 对象的 eventName 事件中删除。  </li>
</ul>
<p><strong>实现事件监听器和发射器事件</strong><br>一下代码演示在 Node.js 实现监听器和自定义事件发射器的过程。Account 对象从 EventEmitter 类继承并提供了两种方法，即<br>deposit（存款）和 withdraw（取款），它们都发射 balanceChanged 事件。然后，3 个回调函数的实现连接到 Account 对象<br>实例的 balanceChanged 事件并显示各种形式的数据。<br>请注意，checkGoal(acc, goal) 回调函数的实现有点不同于其他回调函数。这说明了如何在事件被触发时，将变量传递到该事件<br>监听函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// emitter_listener.js：创建一个自定义 EventEmitter 对象并实现当</div><div class="line">// balanceChanged 事件被触发时所触发的 3 个监听器</div><div class="line">var events = require(&apos;events&apos;);</div><div class="line">function Account() &#123;</div><div class="line">	this.balance = 0;</div><div class="line">	events.EventEmitter.call(this);</div><div class="line">	this.deposit = function(amount) &#123;</div><div class="line">		this.balance += amount;</div><div class="line">		this.emit(&apos;balanceChanged&apos;);</div><div class="line">	&#125;;</div><div class="line">	this.withdraw = function(amount) &#123;</div><div class="line">		this.balance -= amount;</div><div class="line">		this.emit(&apos;balanceChanged&apos;);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">Account.prototype.__proto__ = events.EventEmitter.prototype;</div><div class="line">function displayBalance()&#123;</div><div class="line">	console.log(&quot;Account balance: $%d&quot;, this.balance);</div><div class="line">&#125;</div><div class="line">function checkOverdraw() &#123;</div><div class="line">	if (this.balance &lt; 0) &#123;</div><div class="line">		console.log(&quot;Account overdrawn!!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function checkGoal(acc, goal) &#123;</div><div class="line">	if (acc.balance &gt; goal) &#123;</div><div class="line">		console.log(&quot;Goal Achieved!!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var account = new Account();</div><div class="line">account.on(&quot;balanceChanged&quot;, displayBalance);</div><div class="line">account.on(&quot;balanceChanged&quot;, checkOverdraw);</div><div class="line">account.on(&quot;balanceChanged&quot;, function() &#123;</div><div class="line">	checkGoal(this, 1000);</div><div class="line">&#125;);</div><div class="line">account.deposit(220);</div><div class="line">account.deposit(320);</div><div class="line">account.deposit(600);</div><div class="line">account.withdraw(1200);</div></pre></td></tr></table></figure></p>
<p>emitter_listener.js 的输出，显示了监听器回调函数输出的会计报表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node emitter_listener.js</div><div class="line">Account balance: $220</div><div class="line">Account balance: $540</div><div class="line">Account balance: $1140</div><div class="line">Goal Achieved!!!</div><div class="line">Account balance: $-60</div><div class="line">Account overdrawn!!!</div></pre></td></tr></table></figure></p>
<h2 id="4-3-实现回调"><a href="#4-3-实现回调" class="headerlink" title="4.3 实现回调"></a>4.3 实现回调</h2><h3 id="4-3-1-向回调函数传递额外的参数"><a href="#4-3-1-向回调函数传递额外的参数" class="headerlink" title="4.3.1 向回调函数传递额外的参数"></a>4.3.1 向回调函数传递额外的参数</h3><p>大部分回调函数都有传递给它们的自动参数，如错误或结果缓冲区。使用回调时，常见的一个问题是如何从调用函数给它们传递额外<br>的参数。方法是在一个匿名函数中实现该参数，然后用来自匿名函数的参数调用回调函数。<br>一下代码展示了如何实现回调函数的参数。有两个 sawCar 事件处理程序。请注意，sawCar 仅发出 make 参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// callback_parameter.js 创建一个匿名函数来添加未由事件发出的附加参数</div><div class="line">var events = require(&apos;events&apos;);</div><div class="line">function CarShow() &#123;</div><div class="line">	events.EventEmitter.call(this);</div><div class="line">	this.seeCar = function(make) &#123;</div><div class="line">		this.emit(&apos;sawCar&apos;, make);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">CarShow.prototype.__proto__ = events.EventEmitter.prototype;</div><div class="line">var show = new CarShow();</div><div class="line">function logCar(make) &#123;</div><div class="line">	console.log(&quot;Saw a &quot; + make);</div><div class="line">&#125;</div><div class="line">function logColorCar(make, color) &#123;</div><div class="line">	console.log(&quot;Saw a %s %s&quot;, color, make);</div><div class="line">&#125;</div><div class="line">// 实现了 logCar(make) 回调处理程序</div><div class="line">show.on(&quot;sawCar&quot;, logCar);</div><div class="line">// 事件处理程序调用了一个匿名函数，随机选择的颜色被传递到 logColorCar(make, color) 调用</div><div class="line">show.on(&quot;sawCar&quot;, function(make) &#123;</div><div class="line">	var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;black&apos;];</div><div class="line">	var color = colors[Math.floor(Math.random() * 3)];</div><div class="line">	logColorCar(make, color);</div><div class="line">&#125;);</div><div class="line">show.seeCar(&quot;Ferrari&quot;);</div><div class="line">show.seeCar(&quot;Porsche&quot;);</div><div class="line">show.seeCar(&quot;Bugatti&quot;);</div><div class="line">show.seeCar(&quot;Lamborghini&quot;);</div><div class="line">show.seeCar(&quot;Aston Martin&quot;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ node callback_parameter</div><div class="line">Saw a Ferrari</div><div class="line">Saw a blue Ferrari</div><div class="line">Saw a Porsche</div><div class="line">Saw a blue Porsche</div><div class="line">Saw a Bugatti</div><div class="line">Saw a blue Bugatti</div><div class="line">Saw a Lamborghini</div><div class="line">Saw a red Lamborghini</div><div class="line">Saw a Aston Martin</div><div class="line">Saw a black Aston Martin</div></pre></td></tr></table></figure></p>
<h3 id="4-3-2-在回调中实现闭包"><a href="#4-3-2-在回调中实现闭包" class="headerlink" title="4.3.2 在回调中实现闭包"></a>4.3.2 在回调中实现闭包</h3><p>一个与异步回调的有趣问题是闭包。闭包（Closure） 是一个 JavaScript 的术语，它表示变量被绑定到一个函数的作用域，但<br>不绑定到它的父函数的作用域。当你执行一个异步回调时，父函数的作用域可能更改（例如，通过遍历列表并在每次迭代时改变值）。<br>如果某个函数需要访问父函数的作用域的变量，就需要提供闭包，使这些值在回调函数从事件队列被提取出时可以得到。一个基本<br>方法是在函数块内部封装一个异步调用，并传入所需要的变量。<br>下面代码说明了如何实现为 logCar() 异步函数提供闭包的包装器函数。循环 1 实现了一个基本的回调函数。然而，输出显示中，<br>汽车的名字始终是被读取的最后一个条目，因为每次循环迭代时， message 的值都会变化。<br>循环 2 实现了把消息作为 msg 参数传递的包装器函数，而 msg 值被附着在回调函数上。因此，输出了正确的消息。为了使回调<br>真正异步，使用 process.nextTick() 方法来调度函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// callback_closure.js：创建一个包装器函数来提供异步回调所需的变量的闭包</div><div class="line">function logCar(logMsg, callback) &#123;</div><div class="line">	process.nextTick(function() &#123;</div><div class="line">		callback(logMsg);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">var cars = [&quot;Ferrari&quot;, &quot;Porsche&quot;, &quot;Bugatti&quot;];</div><div class="line">// 循环 1，基本的回调函数</div><div class="line">for (var idx in cars) &#123;</div><div class="line">	var message = &quot;Saw a &quot; + cars[idx];</div><div class="line">	logCar(message, function() &#123;</div><div class="line">		console.log(&quot;Normal Callback: &quot; + message);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">// 循环 2，把消息作为 msg 参数传递的包装器函数函数</div><div class="line">for (var idx in cars) &#123;</div><div class="line">	var message = &quot;Saw a &quot; + cars[idx];</div><div class="line">	(function(msg) &#123;</div><div class="line">		logCar(msg, function() &#123;</div><div class="line">			console.log(&quot;Closure Callback: &quot; + msg);</div><div class="line">		&#125;);</div><div class="line">	&#125;)(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node callback_closure.js</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Closure Callback: Saw a Ferrari</div><div class="line">Closure Callback: Saw a Porsche</div><div class="line">Closure Callback: Saw a Bugatti</div></pre></td></tr></table></figure></p>
<h3 id="4-3-3-链式回调"><a href="#4-3-3-链式回调" class="headerlink" title="4.3.3 链式回调"></a>4.3.3 链式回调</h3><p>使用异步函数时，如果两个函数都在事件队列上，无法保证它们的运行顺序。最佳方法是让来自异步函数的回调在此调用该函数，<br>直到没有更多的工作要做，以执行链式回调。这样，异步函数永远不会在时间队列上超过一次。<br>以下代码中，条目列表被传递到函数 logCars()，然后异步函数 logCar() 被调用，并且 logCars() 函数作为当 logCar() 完成<br>时的回调函数。一次，同一时间只有一个版本的 logCar() 在事件队列上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// callback_chain.js：实现一个回调链，在此来自一个匿名函数的</div><div class="line">// 回调函数回调到最初的函数来遍历列表</div><div class="line">function logCar(car, callback) &#123;</div><div class="line">	console.log(&quot;Saw a %s&quot;, car);</div><div class="line">	if(cars.length) &#123;</div><div class="line">		process.nextTick(function() &#123;</div><div class="line">			callback();</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function logCars(cars) &#123;</div><div class="line">	var car = cars.pop();</div><div class="line">	logCar(car, function() &#123;</div><div class="line">		logCars(cars);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">var cars = [&quot;Ferrari&quot;, &quot;Porsche&quot;, &quot;Bugatti&quot;, &quot;Lamborghini&quot;, &quot;Aston Martin&quot;];</div><div class="line">logCars(cars);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node callback_chain.js</div><div class="line">Saw a Aston Martin</div><div class="line">Saw a Lamborghini</div><div class="line">Saw a Bugatti</div><div class="line">Saw a Porsche</div><div class="line">Saw a Ferrari</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/开始使用 Node.js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/开始使用 Node.js/" itemprop="url">开始使用 Node.js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T20:29:15+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-开始使用-Node-js"><a href="#3-开始使用-Node-js" class="headerlink" title="3 开始使用 Node.js"></a>3 开始使用 Node.js</h1><h2 id="3-2-Node-js-安装"><a href="#3-2-Node-js-安装" class="headerlink" title="3.2 Node.js 安装"></a>3.2 Node.js 安装</h2><h3 id="3-2-1-纵观-Node-js-安装位置"><a href="#3-2-1-纵观-Node-js-安装位置" class="headerlink" title="3.2.1 纵观 Node.js 安装位置"></a>3.2.1 纵观 Node.js 安装位置</h3><ul>
<li><strong>node：</strong> 该文件启动一个 Node.js JavaScript 引擎。如果你传递一个 JavaScript 文件的位置， Node.js 就执行该脚本。如果没有制定目标 JavaScript 文件，就会出来一个脚本提示符，可以利用它直接从控制台执行 JavaScript 代码。  </li>
<li><strong>npm：</strong> 你可以侍弄此命令来管理 Node.js 包。  </li>
<li><strong>node_modules：</strong> 此文件夹包含安装的Node.js 包。这些包作为扩展 node.js 功能的库。  </li>
</ul>
<h3 id="3-2-2-验证-Node-js-可执行文件"><a href="#3-2-2-验证-Node-js-可执行文件" class="headerlink" title="3.2.2 验证 Node.js 可执行文件"></a>3.2.2 验证 Node.js 可执行文件</h3><p>打开命令提示符，执行以下命令，这将弹出一个 Node.js 虚拟机：<br><code>node</code><br>接下来，执行以下命令，将 “Hello World” 写到屏幕上：<br><code>&gt;console.log(&quot;Hello World&quot;);</code><br>当你看到 “Hello World” 被写入控制台屏幕后，可以按 Ctrl+C 组合键退出控制台。<br>接下来，通过在命令提示符下执行以下命令来验证 npm 命令能正常工作：<br><code>npm version</code><br>你应该看到类似如下的输出：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123; censorify: &apos;0.1.1&apos;,  </div><div class="line">  npm: &apos;3.10.10&apos;,  </div><div class="line">  ares: &apos;1.10.1-DEV&apos;,  </div><div class="line">  http_parser: &apos;2.7.0&apos;,  </div><div class="line">  icu: &apos;58.2&apos;,  </div><div class="line">  modules: &apos;48&apos;,  </div><div class="line">  node: &apos;6.10.3&apos;,  </div><div class="line">  openssl: &apos;1.0.2k&apos;,  </div><div class="line">  uv: &apos;1.9.1&apos;,  </div><div class="line">  v8: &apos;5.1.281.101&apos;,  </div><div class="line">  zlib: &apos;1.2.11&apos; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-3-选择-Node-js-IDE"><a href="#3-2-3-选择-Node-js-IDE" class="headerlink" title="3.2.3 选择 Node.js IDE"></a>3.2.3 选择 Node.js IDE</h3><p>暂时用 MarkdwonPad2 ，仍然有些问题。计划用 WebStorm。  </p>
<h2 id="3-3-使用-Node-js-包"><a href="#3-3-使用-Node-js-包" class="headerlink" title="3.3 使用 Node.js 包"></a>3.3 使用 Node.js 包</h2><p>Node.js 框架最强大功能之一是能够轻松地使用 Node 包管理器（Node Packaged Manager，NPM）用额外的 Node 封装模块<br>（NPM）将其扩展。没错：在 Node.js 世界，NPM 意味着两种东西。本文将 Node 封装模块成为模块（Node Package Module，<br>module），而不是 NPM，以避免混乱。  </p>
<h3 id="3-3-1-什么是-Node-封装模块"><a href="#3-3-1-什么是-Node-封装模块" class="headerlink" title="3.3.1 什么是 Node 封装模块"></a>3.3.1 什么是 Node 封装模块</h3><p>Node 封装模块是一个打包的库，它可以很容易地在不同的项目中被共享、重用和安装。  </p>
<h3 id="3-3-2-了解-Node-包注册表"><a href="#3-3-2-了解-Node-包注册表" class="headerlink" title="3.3.2 了解 Node 包注册表"></a>3.3.2 了解 Node 包注册表</h3><p>Node 包注册表位于 <a href="http://npmjs.org。" target="_blank" rel="external">http://npmjs.org。</a>  </p>
<h3 id="3-3-3-使用-Node-包管理器"><a href="#3-3-3-使用-Node-包管理器" class="headerlink" title="3.3.3 使用 Node 包管理器"></a>3.3.3 使用 Node 包管理器</h3><p>Node 包管理器是一个命令行实用程序，它可以让你查找、安装、删除、发布，以及做与 Node 封装模块相关的其他很多东西。<br>Node 包管理器提供了 Node 包的注册表和开发环境之间的联系。  </p>
<h3 id="3-3-4-搜索-Node-封装模块"><a href="#3-3-4-搜索-Node-封装模块" class="headerlink" title="3.3.4 搜索 Node 封装模块"></a>3.3.4 搜索 Node 封装模块</h3><p>你可以直接在命令提示符下使用 npm search <search_string> 命令搜索在 Node 程序包注册表中的模块。  </search_string></p>
<h3 id="3-3-5-安装-Node-封装模块"><a href="#3-3-5-安装-Node-封装模块" class="headerlink" title="3.3.5 安装 Node 封装模块"></a>3.3.5 安装 Node 封装模块</h3><p>在应用程序中使用 Node 模块，它必须先被安装在 Node 可以找到它的地方。要安装 Node 模块，使用 npm install <module_name><br>命令下载 Node 模块到你的开发环境，并将其放置在 node_modules 文件夹中，在哪里运行 install 命令。  </module_name></p>
<h3 id="3-3-6-使用-package-json"><a href="#3-3-6-使用-package-json" class="headerlink" title="3.3.6 使用 package.json"></a>3.3.6 使用 package.json</h3><p>所用 Node 的模块必须在其根目录下包含一个 package.json 文件。package.json 是定义了一个模块，包括其依赖关系的一个<br>简单的JSON 文本文件。改文件可以包含多个不同的指令来告诉 Node 包管理器如何处理模块。<br>下面是一个包含名称、版本、描述和依赖关系的 package.json 文件的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;my_module&quot;,</div><div class="line">    &quot;version&quot;: &quot;0.1.0&quot;,</div><div class="line">    &quot;description&quot;: &quot;a simple node.js module&quot;,</div><div class="line">    &quot;dependencies&quot;: &#123;</div><div class="line">        &quot;express&quot;: &quot;latest&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 package.json 文件中必须的指令只是名称和版本；其余取决于你想要包含什么。<br>从包的根目录运行下面的命令，express 模块会自动安装：<br><code>npm install</code><br>请注意，npm install 命令没有指定任何模块。这是因为 npm 在默认情况下会蟾照一个 package.json 文件。需要增加额外模块，<br>只要将这些模块添加到依赖指令中，然后再次运行 npm install。  </p>
<h2 id="3-4-创建-Node-js-应用程序"><a href="#3-4-创建-Node-js-应用程序" class="headerlink" title="3.4 创建 Node.js 应用程序"></a>3.4 创建 Node.js 应用程序</h2><p>本节中，将会创建自己的 Node 封装模块，然后把该模块在一个 Node.js 应用程序中作为库来使用。  </p>
<h3 id="3-4-1-创建-Node-js-模块封装"><a href="#3-4-1-创建-Node-js-模块封装" class="headerlink" title="3.4.1 创建 Node.js 模块封装"></a>3.4.1 创建 Node.js 模块封装</h3><p>建立一个 Node.js 封装模块 censorify，该模块接受文本并用星号代替某些特定的单词。  </p>
<ol>
<li>创建名为…/censorify 的项目文件夹。这将是此包的根目录。    </li>
<li>在该文件夹中创建 censortext.js 文件。  </li>
<li>添加以下代码  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var censoredWords = [&quot;sad&quot;, &quot;bad&quot;, &quot;mad&quot;];</div><div class="line">var customCensoredWords = [];</div><div class="line">function censor(inStr) &#123;</div><div class="line">    for (idx in censoredWords) &#123;</div><div class="line">        inStr = inStr.replace(censoredWords[idx], &quot;****&quot;);</div><div class="line">    &#125;</div><div class="line">    for (idx in customCensoredWords) &#123;</div><div class="line">        inStr = inStr.replace(customCensoredWords[idx], &quot;****&quot;);</div><div class="line">    &#125;</div><div class="line">    return inStr;</div><div class="line">&#125;</div><div class="line">function addCensoredWord(word) &#123;</div><div class="line">    customCensoredWords.push(word);</div><div class="line">&#125;</div><div class="line">function getCensoredWords() &#123;</div><div class="line">    return censoredWords.concat(customCensoredWords);</div><div class="line">&#125;</div><div class="line">// 导出函数</div><div class="line">exports.censor = censor;</div><div class="line">exports.addCensoredWord = addCensoredWord;</div><div class="line">exports.getCensoredWords = getCensoredWords;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>导出 censor 是使用这个模块的 Node.js 应用程序能够访问 censor() 函数所需的，对于其他两个函数也是如此。  </p>
<ol>
<li>要生成 Node.js 封装模块，需要 package.json 文件，在 …/censorify 文件夹中创建 package.json<br>文件。添加类似以下代码：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;author&quot;: &quot;Brad Dayley&quot;,</div><div class="line">  &quot;name&quot;: &quot;censorify&quot;,</div><div class="line">  &quot;version&quot;: &quot;0.1.1&quot;,</div><div class="line">  &quot;description&quot;: &quot;Censors words out of text&quot;,</div><div class="line">  &quot;main&quot;: &quot;censortext&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;&#125;,</div><div class="line">  &quot;engines&quot;: &#123;</div><div class="line">    &quot;node&quot;: &quot;*&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>具体而言，至少需要添加 name（名称）、version（版本）和 main 指令。main 指令需要时被加载的主 JavaScript<br>的模块的名称，本例中是 censortext。注意，.js 不是必需的：Node.js 会自动搜索 .js 扩展名。  </p>
<ol>
<li>在 …/censorify 文件夹中创建 README.md 的文件，填写任意自述说明。  </li>
<li>在控制台导航到 …/censorify 文件夹，执行以下命令来建立本地封装模块：<br><code>npm pack</code><br>npm pack 命令会在…/censorify 文件夹中生成 censorify-0.1.1.tgz 文件。这是你的第一个 Node.js<br>封装模块。   </li>
</ol>
<h3 id="3-4-2-将-Node-js-封装模块发布到-NPM-注册表"><a href="#3-4-2-将-Node-js-封装模块发布到-NPM-注册表" class="headerlink" title="3.4.2 将 Node.js 封装模块发布到 NPM 注册表"></a>3.4.2 将 Node.js 封装模块发布到 NPM 注册表</h3><h3 id="3-4-3-在-Node-js-应用程序中使用-Node-js-封装模块"><a href="#3-4-3-在-Node-js-应用程序中使用-Node-js-封装模块" class="headerlink" title="3.4.3 在 Node.js 应用程序中使用 Node.js 封装模块"></a>3.4.3 在 Node.js 应用程序中使用 Node.js 封装模块</h3><p>很简单，只要将模块安装到你的应用程序的结构中，再用 require() 方法加载该模块。<br>require() 方法接受任何已安装的模块名或位于文件系统上的 .js 文件路径。例如：<br>require(“censorify”)<br>require(“./lib/utils.js”)<br>.js 文件扩展名是可选的。如果它被省略，那么 Node.js 将搜索它。<br>按以下步骤操作：  </p>
<ol>
<li>创建项目文件夹 …/readwords，以此为根目录。    </li>
<li>从根目录的命令提示符下，使用以下命令来安装先前创建的 censorify-0.1.1.tgz 包 censorify 模块：<br><code>npm install ../censorify/censorify-0.1.1.tgz</code>  </li>
<li>或者，如果你已经发布了 censorify 模块，可使用标准命令从 NPM 注册表下载和安装：<br><code>npm install censorify</code>  </li>
<li>确认名为 node_modules 的文件夹，连同 censorify 的子文件夹应被创建。  </li>
<li>创建 …/readwords/readwords.js 文件。  </li>
<li><p>写入以下代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// readwords.js：一个显示文本时加载 censorify 模块的 Node.js 应用程序</div><div class="line">var censor = require(&quot;censorify&quot;);</div><div class="line">console.log(censor.getCensoredWords());</div><div class="line">console.log(censor.censor(&quot;Some very sad, bad and mad text&quot;));</div><div class="line">censor.addCensoredWord(&quot;gloomy&quot;);</div><div class="line">console.log(censor.getCensoredWords());</div><div class="line">console.log(censor.censor(&quot;A very gloomy day.&quot;));</div></pre></td></tr></table></figure>
</li>
<li><p>以下命令运行：<br><code>node readwords.js</code><br>输出如下，注意，审查词都被替换为 <em>**</em>，而且新的审查词 gloomy 被加入到 censorify 模块实例 sensor 中。  </p>
<pre><code>$ node readwords.js
[ &apos;sad&apos;, &apos;bad&apos;, &apos;mad&apos; ]
Some very ****, **** and **** text
[ &apos;sad&apos;, &apos;bad&apos;, &apos;mad&apos;, &apos;gloomy&apos; ]
A very **** day.
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/项目经理如何对接需求会议总结_20170621/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/21/项目经理如何对接需求会议总结_20170621/" itemprop="url">项目经理如何对接需求会议总结_20170621</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T20:44:43+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天下午开了关于“项目经理如何对接需求”的会议，受益良多，简单梳理一下。   </p>
<h3 id="1-0-目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？"><a href="#1-0-目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？" class="headerlink" title="1.0 目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？"></a>1.0 目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？</h3><h5 id="（1）无纸化“软件”"><a href="#（1）无纸化“软件”" class="headerlink" title="（1）无纸化“软件”"></a>（1）无纸化“软件”</h5><p>脱离纸张…  </p>
<h5 id="（2）流程化软件"><a href="#（2）流程化软件" class="headerlink" title="（2）流程化软件"></a>（2）流程化软件</h5><p>ERP 系统等… </p>
<h5 id="（3）智能化系统"><a href="#（3）智能化系统" class="headerlink" title="（3）智能化系统"></a>（3）智能化系统</h5><p>根据企业存在问题，提出解决方案…  </p>
<p>主要做前两种，第三种要求较高，是我们努力的目标。</p>
<h3 id="2-0-对于需求，我们分为哪些，同时对应几个阶段？"><a href="#2-0-对于需求，我们分为哪些，同时对应几个阶段？" class="headerlink" title="2.0 对于需求，我们分为哪些，同时对应几个阶段？"></a>2.0 对于需求，我们分为哪些，同时对应几个阶段？</h3><p>需求分为业务需求和开发需求。业务需求是在与客户交流的阶段，通过各种方式挖掘痛点，找出客户真正需要的；<br>开发需求是在开发阶段，根据业务需求制定的关于系统开发方方面面的，细节性的功能的需求。  </p>
<h3 id="3-0-如何挖掘用户的业务需求"><a href="#3-0-如何挖掘用户的业务需求" class="headerlink" title="3.0 如何挖掘用户的业务需求"></a>3.0 如何挖掘用户的业务需求</h3><h4 id="3-1-客户在你面前，你是否存在不知如何入手？"><a href="#3-1-客户在你面前，你是否存在不知如何入手？" class="headerlink" title="3.1 客户在你面前，你是否存在不知如何入手？"></a>3.1 客户在你面前，你是否存在不知如何入手？</h4><p>进行“破冰”，让客户打开话匣子，聊起来，双方不再尴尬，再过渡到深入挖掘客户的需求。 </p>
<p>不知如何入手原因：<br>（1） 知道要讲什么，但性格原因，不善于打交道<br>（2） 擅长打交道，但不知道要讲什么<br>（3） 不知道要什么，不擅长打交道<br>一些解决方案：<br>大声读文章 –》对着镜子背诵，观察面部表情 –》去街上进行调查问卷    </p>
<h4 id="3-2-客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？"><a href="#3-2-客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？" class="headerlink" title="3.2 客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？"></a>3.2 客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？</h4><p>客户可能很啰嗦，说不到重点。我们不能表现出不耐烦，不能让客户看出我们觉得他很“傻逼”，这不仅表现出我们缺乏基本的礼仪，有损个人形象，而且会损害本公司的形象，不利于与客户的进一步交流。我们应当认真倾听，从“啰嗦话”中挖掘客户真实需求。若能力足够，尽可能礼貌地引导客户到正确的方向。   </p>
<h4 id="3-3-你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？"><a href="#3-3-你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？" class="headerlink" title="3.3 你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？"></a>3.3 你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？</h4><p>类似于 3.2<br>了解客户所在行业情况，脑海中要有系统的雏形，再与客户进行系统可行性相关的、各种实现细节的论证。  </p>
<h4 id="3-4-你是不是觉得害怕自己提出的东西被否定？"><a href="#3-4-你是不是觉得害怕自己提出的东西被否定？" class="headerlink" title="3.4 你是不是觉得害怕自己提出的东西被否定？"></a>3.4 你是不是觉得害怕自己提出的东西被否定？</h4><p>用于提出自己的意见，有上级领导、公司做你的后盾，但不能过。东西被否定，也是好现象，说明客户知道自己想要什么。对接需求是双向的，相互交流，相互反馈，利于工作进展。  </p>
<h4 id="3-5-你觉得还有什么？"><a href="#3-5-你觉得还有什么？" class="headerlink" title="3.5 你觉得还有什么？"></a>3.5 你觉得还有什么？</h4><h4 id="3-6-你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？"><a href="#3-6-你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？" class="headerlink" title="3.6 你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？"></a>3.6 你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？</h4><p>这个需要大量项目经验的积累，经验不足的情况下，寻找大量优秀的系统，分析其需求，内化为自身知识。  </p>
<h4 id="业务需求最重要的是什么？"><a href="#业务需求最重要的是什么？" class="headerlink" title="业务需求最重要的是什么？"></a>业务需求最重要的是什么？</h4><p>将实际需求、客户的真实需求融入到系统开发之中。  </p>
<h3 id="4-0-根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？"><a href="#4-0-根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？" class="headerlink" title="4.0 根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？"></a>4.0 根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？</h3><h4 id="4-1-脱离无纸化的“软件”，我们要注意什么？"><a href="#4-1-脱离无纸化的“软件”，我们要注意什么？" class="headerlink" title="4.1 脱离无纸化的“软件”，我们要注意什么？"></a>4.1 脱离无纸化的“软件”，我们要注意什么？</h4><p>比较“简单粗暴”，可能只需要将单据融合到系统中就可以，风险、周期可控。但是要注意：单据格式正确、单据数据齐全，确保单据是我们系统所需要的。  </p>
<h4 id="4-2-有一定业务流程甚至是-ERP-类型的流程性的系统，我们要注意什么？"><a href="#4-2-有一定业务流程甚至是-ERP-类型的流程性的系统，我们要注意什么？" class="headerlink" title="4.2 有一定业务流程甚至是 ERP 类型的流程性的系统，我们要注意什么？"></a>4.2 有一定业务流程甚至是 ERP 类型的流程性的系统，我们要注意什么？</h4><p>尤其注意体量大的、多部门的公司，甚至集团，业务流程极其繁杂。<br>（1）没有专门的负责人，可能需要与很多领导协调，不利于工作进展。建议对方有单一对接人，或者说能拍板的人。<br>（2）需求对接周期很长，对接前请示领导。<br>（3）客户需求变更频繁。对于已经确认的需求，我们最好立马让客户在需求文档或者流程文档上签字，以防以后需求变更导致的种种问题。</p>
<h2 id="关于项目经理如何带项目"><a href="#关于项目经理如何带项目" class="headerlink" title="关于项目经理如何带项目"></a>关于项目经理如何带项目</h2><p>检验控制<br>（1）让所有人理解需求，且能复述出来；<br>（2）看页面，指出存在问题，并要求后面的模块遵循相同要求；<br>（3）看代码，团队统一代码规范，团队成员间互相阅读无障碍；<br>周期控制<br>开发周期 + 测试周期 + 改 bug 周期 </p>
<h2 id="关于项目-A-存在的问题及反思"><a href="#关于项目-A-存在的问题及反思" class="headerlink" title="关于项目 A 存在的问题及反思"></a>关于项目 A 存在的问题及反思</h2><p>（1）病态的合同关系<br>客户甲与公司乙签订合同，项目有公司乙完成；公司乙再与公司丙签订合同，把项目外包给公司丙做。<br>公司乙所理解的需求与客户甲的真实需求有所偏差。公司丙理解的需求与公司乙有所偏差，与客户需求则偏差更大。需求问题是个大坑。  </p>
<p>尽量不做二包，最好能直接与客户交流。</p>
<p>（2）初期没有让客户确认需求<br>仅靠口头约定，客户可能会出尔反尔，或者强加各种额外需求。  </p>
<p>为避免这种情况，对于已经确认的需求，我们最好立马让客户在需求文档或者流程文档上签字。如果有需求变化，增加工作周期，提高项目价格。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/JFinal Weixin 学习笔记（9）-- 微信账号二维码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/24/JFinal Weixin 学习笔记（9）-- 微信账号二维码/" itemprop="url">JFinal Weixin 学习笔记（9）-- 微信账号二维码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T17:02:43+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><hr>
<h4 id="生成带参数的二维码-QrcodeApi"><a href="#生成带参数的二维码-QrcodeApi" class="headerlink" title="生成带参数的二维码 QrcodeApi"></a>生成带参数的二维码 <code>QrcodeApi</code></h4><p>为了满足用户渠道推广分析和用户帐号绑定等场景的需要，公众平台提供了生成带参数二维码的接口。使用该接口可以获得多个带不同场景值的二维码，用户扫描后，公众号可以接收到事件推送。<br>1、临时二维码，是有过期时间的，最长可以设置为在二维码生成后的30天（即2592000秒）后过期，但能够生成较多数量。临时二维码主要用于帐号绑定等不要求二维码永久保存的业务场景  。<br>2、永久二维码，是无过期时间的，但数量较少（目前为最多10万个）。永久二维码主要用于适用于帐号绑定、用户来源统计等场景。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 创建临时二维码</div><div class="line"> * @param expireSeconds 该二维码有效时间，以秒为单位。 最大不超过604800（即7天）。</div><div class="line"> * @param sceneId 场景值ID，临时二维码时为32位非0整型</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createTemporary(int expireSeconds, int sceneId);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建永久二维码</div><div class="line"> * @param sceneId 场景值ID，永久二维码时最大值为100000（目前参数只支持1--100000）</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createPermanent(int sceneId);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建永久二维码</div><div class="line"> * @param sceneStr 场景值ID（字符串形式的ID），字符串类型，长度限制为1到64，仅永久二维码支持此字段</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createPermanent(String sceneStr);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过ticket换取二维码地址，拼接二维码连接，可直接通过&lt;img&gt;显示</div><div class="line"> * @param ticket 换取二维码参数</div><div class="line"> * @return String url</div><div class="line"> */</div><div class="line">public static String getShowQrcodeUrl(String ticket);</div></pre></td></tr></table></figure>
<h4 id="长链接转短链接接口-ShorturlApi"><a href="#长链接转短链接接口-ShorturlApi" class="headerlink" title="长链接转短链接接口 ShorturlApi"></a>长链接转短链接接口 <code>ShorturlApi</code></h4><p>将一条长链接转成短链接。<br>主要使用场景： 开发者用于生成二维码的原链接（商品、支付二维码等）太长导致扫码速度和成功率下降，将原长链接通过此接口转成短链接再生成二维码将大大提升扫码速度和成功率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 长链接转短链接接口</div><div class="line"> * @param longUrl 需要转换的长链接，支持http://、https://、weixin://wxpay 格式的url</div><div class="line"> * @return ApiResult 短连接信息</div><div class="line"> */</div><div class="line">public static ApiResult getShortUrl(String longUrl);</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><hr>
<h4 id="WeixinApiController-java"><a href="#WeixinApiController-java" class="headerlink" title="WeixinApiController.java"></a>WeixinApiController.java</h4><pre><code>// 生成带参数的二维码
// 创建临时二维码
public void createTemporary(){
    ApiResult apiResult = null;
    // 过期时间
    int expireSeconds = 604800;
    // 场景值
    int sceneId = 111;
    // 生成临时二维码
    apiResult = QrcodeApi.createTemporary(expireSeconds, sceneId);
    // 获取 ticket,拼接 url 
    JSONObject jsonObjec = JSONObject.parseObject(apiResult.getJson());
    String ticket = jsonObjec.getString(&quot;ticket&quot;);
    String outMessage = &quot;apiResult: &quot; + apiResult.getJson() +&quot;\n&quot;
            + &quot;QrcodeUrl: &quot; + QrcodeApi.getShowQrcodeUrl(ticket);
    renderText(outMessage);
}

// 长链接转短链接接口 ShorturlApi
public void getShortUrl(){
    ApiResult apiResult = null;
    String longUrl = &quot;https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQHT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyemlhcVFPa0JmUWoxM01GRk5wMW0AAgRw7x9ZAwSAOgkA&quot;;
    apiResult = ShorturlApi.getShortUrl(longUrl);
    JSONObject jsonObjec = JSONObject.parseObject(apiResult.getJson());
    String shorUrl = jsonObjec.getString(&quot;short_url&quot;);
    String outMessage = &quot;apiResult: &quot; + apiResult.getJson() +&quot;\n&quot;
            + &quot;longUrl: &quot; + longUrl + &quot;\n\n&quot;
            + &quot;shorUrl: &quot; + shorUrl;
    renderText(outMessage);
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;h3&gt;微信账号二维码&lt;/h3&gt;
点击&lt;a href=&apos;/api/createTemporary&apos;&gt;【创建临时二维码】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/getShortUrl&apos;&gt;【长链接转短链接】&lt;/a&gt;&lt;br&gt;
</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><hr>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9f40e18fe79d47a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试页面">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9d519c902e908093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建临时二维码"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-7a07dbca0607d4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长链接转短链接">  </p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/zyw_java/article/details/54024672" target="_blank" rel="external">微信开发之推广支持</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E5%B8%90%E5%8F%B7%E7%AE%A1%E7%90%86#长链接转短链接接口shorturlapi" target="_blank" rel="external">jfinal-weixin-wiki 帐号管理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/23/JFinal Weixin 学习笔记（8）-- 微信自定义菜单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/JFinal Weixin 学习笔记（8）-- 微信自定义菜单/" itemprop="url">JFinal Weixin 学习笔记（8）-- 微信自定义菜单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-23T11:05:43+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="自定义菜单接口"><a href="#自定义菜单接口" class="headerlink" title="自定义菜单接口"></a>自定义菜单接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 查询菜单</div><div class="line"> */</div><div class="line">MenuApi.getMenu();</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建菜单</div><div class="line"> */</div><div class="line">MenuApi.createMenu(String jsonStr);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 自定义菜单删除接口</div><div class="line"> */</div><div class="line">MenuApi.deleteMenu();</div></pre></td></tr></table></figure>
<h4 id="WeinxinApiController-java"><a href="#WeinxinApiController-java" class="headerlink" title="WeinxinApiController.java"></a>WeinxinApiController.java</h4><p><code>createMenu(String jsonStr)</code> 接受 json 格式的字符串，我们根据微信技术文档拼接自定义菜单字符串：</p>
<pre><code>/**
 * 创建菜单
 */
public void createMenu() {
    String path = Constants.HOST;
    String jsonstr = &quot;{&quot; +
            &quot;    \&quot;button\&quot;: [&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单1\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单11\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单12\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单13\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单14\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单15\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        },&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单2\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;测　　试\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api/index\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;click\&quot;,\&quot;type\&quot;: \&quot;click\&quot;,\&quot;key\&quot;: \&quot;22\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单23\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;百度\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;http://www.baidu.com\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单25\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        },&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单3\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot;+
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单31\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单32\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单33\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单34\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单35\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        }&quot; +
            &quot;    ]&quot; +
            &quot;}&quot;;
    ApiResult apiResult = MenuApi.createMenu(jsonstr);
    renderText(apiResult.getJson());
}
</code></pre><p>自定义菜单接口可实现多种类型按钮，详见：<a href="https://mp.weixin.qq.com/wiki" target="_blank" rel="external">微信公众平台技术文档</a>。<br>这里使用了两种：<br>1、<code>click</code>：点击推事件用户点击 click 类型按钮后，微信服务器会通过消息接口推送消息类型为 event 的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的 key 值，开发者可以通过自定义的 key 值与用户进行交互；<br>2、<code>view</code>：跳转 URL 用户点击 view 类型按钮后，微信客户端将会打开开发者在按钮中填写的网页 URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</p>
<p><code>getMenu()</code> 方法，查询自定义菜单：</p>
<pre><code>/**
 * 查询菜单
 */
public void getMenu() {
    ApiResult apiResult = MenuApi.getMenu();
    renderText(apiResult.getJson());
}
</code></pre><h4 id="WeixinMsgController-java"><a href="#WeixinMsgController-java" class="headerlink" title="WeixinMsgController.java"></a>WeixinMsgController.java</h4><p><code>processInMenuEvent(InMenuEvent inMenuEvent)</code>  方法接受菜单中 <code>click</code> 类型按钮的点击事件</p>
<pre><code>// 自定义菜单事件
@Override
protected void processInMenuEvent(InMenuEvent inMenuEvent) {
    OutTextMsg outMsg = new OutTextMsg(inMenuEvent);
    outMsg.setContent(&quot;processInMenuEvent() 方法测试成功&quot;);
    render(outMsg);
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;h3&gt;自定义菜单&lt;/h3&gt;
点击&lt;a href=&apos;/api/createMenu&apos;&gt;【创建自定义菜单】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/getMenu&apos;&gt;【获取自定义菜单】&lt;/a&gt;&lt;br&gt;
</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>点击创建菜单，微信客户端不会立马刷新。想立马看到效果，可以取消关注再关注。<br>微信菜单：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-9d135134a26c0b34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一级菜单"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-989b1cdda1ae9bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二级菜单"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9db99bf82a64d269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三级菜单"></p>
<p>点击 <code>click22</code><br><img src="http://upload-images.jianshu.io/upload_images/5343805-1f2158641ce18284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>新增了“测试”按钮，可以直接跳转主页面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-70dcadb1095aebd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试页面"></p>
<p>点击“获取自定义菜单”<br>得到 json 格式的菜单数据：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-72c4afa586b48cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="菜单数据"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/2d740d059fa0" target="_blank" rel="external">JFinal Weixin 学习笔记（9）– 微信账号二维码</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/zyw_java/article/details/61415114" target="_blank" rel="external">微信公众号开发之自定义菜单</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">jfinal-weixin-wiki 自定义菜单接口</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/23/JFinal Weixin 学习笔记（7）-- 微信用户管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/JFinal Weixin 学习笔记（7）-- 微信用户管理/" itemprop="url">JFinal Weixin 学习笔记（7）-- 微信用户管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-23T11:04:43+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="GroupsApi-接口"><a href="#GroupsApi-接口" class="headerlink" title="GroupsApi 接口"></a>GroupsApi 接口</h4><p>开发者可以使用 <code>GroupsApi</code> 接口，对公众平台的分组进行查询、创建、修改、删除等操作。  </p>
<p>相关方法：<br><code>create(String name)</code> 方法：<br>创建分组，一个公众账号，最多支持创建 100 个分组<br>参数 name： 分组名  </p>
<p><code>get()</code> 方法：<br>查询所有分组  </p>
<p><code>getId(String openid)</code> 方法：<br>通过用户的OpenID查询其所在的 GroupID<br>参数 openid： 普通用户的标识，对当前开发者帐号唯一  </p>
<p><code>update(int id, String name)</code> 方法：<br>修改分组名<br>参数 id：分组 id，由微信分配<br>参数 name： 分组名字（30 个字符以内）  </p>
<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>修改 <code>WeixinApiController.java</code>   </p>
<pre><code>// 获取用户分组列表
public void getGroups () {
    ApiResult apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 创建分组
public void createGroup () {
    Date date = new Date();
    GroupsApi.create(date.toString());
    ApiResult apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 删除分组
public void deleteGroup () {
    ApiResult apiResult = null;
    // 获取当前用户分组列表
    apiResult = GroupsApi.get();
    // 结果转化成 JSONArray 对象
    JSONArray jsonArray = JSON.parseObject(apiResult.toString()).getJSONArray(&quot;groups&quot;);
    // 删除 id &gt;= 100 的用户分组
    for(int i = 0, size = jsonArray.size(); i &lt; size; i++){
        // 转化成 JSONObject 对象
        JSONObject jsonObject = (JSONObject) jsonArray.get(i);
        // 获取分组 id
        int id = jsonObject.getInteger(&quot;id&quot;);
        if (id &gt;= 100){
            // 删除用户分组
            GroupsApi.delete(id);
        }
    }
    // 获取删除后的用户数组
    apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 修改分组名
public void updateGroup(){
    String msg = new String();

    // 更新前
    GroupsApi.create(&quot;原分组名&quot;);
    ApiResult apiResult = GroupsApi.get();
    msg += &quot;更新前： &quot; + apiResult.toString() + &quot;\n&quot;;

    // 结果转化成 JSONArray 对象
    JSONArray jsonArray = JSON.parseObject(apiResult.toString()).getJSONArray(&quot;groups&quot;);
    // 更新用户分组
    for(int i = 0, size = jsonArray.size(); i &lt; size; i++){
        // 转化成 JSONObject 对象
        JSONObject jsonObject = (JSONObject) jsonArray.get(i);
        // 获取分组名
        String origin = jsonObject.getString(&quot;name&quot;);
        if (&quot;原分组名&quot;.equals(origin)){
            // 更新用户分组
            GroupsApi.update(jsonObject.getInteger(&quot;id&quot;), &quot;新分组名&quot;);
            break;
        }
    }

    // 更新后
    msg += &quot;更新后： &quot; + GroupsApi.get().toString() + &quot;\n&quot;;
    renderText(msg);
}
</code></pre><p>修改 <code>index.html</code> </p>
<pre><code>&lt;h3&gt;用户管理&lt;/h3&gt;
点击&lt;a href=&apos;/api/getGroups&apos;&gt;【获取用户分组列表】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/createGroup&apos;&gt;【创建用户分组】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/deleteGroup&apos;&gt;【删除用户分组】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/updateGroup&apos;&gt;【修改用户分组名】&lt;/a&gt;&lt;br&gt;
</code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>主页面：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-250d7a21f6ea6191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页">  </p>
<p>获取用户分组列表：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-8c170d7c51dac536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取用户分组列表"></p>
<p>创建用户分组：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-1f12e305ac37050f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建用户分组"></p>
<p>删除用户分组：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-154a6af55b6672cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除用户分组"></p>
<p>修改用户分组名：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-4156f14aba45b9df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改用户分组名"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/0039f943f91d" target="_blank" rel="external">JFinal Weixin 学习笔记（8）– 微信自定义菜单</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86" target="_blank" rel="external">jfinal-weixin-wiki 用户管理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/20/JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据/" itemprop="url">JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T09:06:43+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="利用-AccessTokenApi-获取-access-token"><a href="#利用-AccessTokenApi-获取-access-token" class="headerlink" title="利用 AccessTokenApi 获取 access_token"></a>利用 AccessTokenApi 获取 access_token</h4><p><code>access_token</code> 是公众号的全局唯一票据，公众号调用各接口时都需使用 <code>access_token</code>。<br><code>jfinal-wein</code> 提供了 <code>AccessTokenApi</code> 接口，其中:<br><code>getAccessTokenStr()</code> 方法直接获取 <code>access_token</code> 字符串，方便使用；<br><code>getAccessToken()</code> 方法从缓存中获取 <code>access token</code>，如果未取到或者 <code>access token</code> 不可用则先更新再获取。  </p>
<h4 id="修改-WeixinApiController-java"><a href="#修改-WeixinApiController-java" class="headerlink" title="修改 WeixinApiController.java"></a>修改 WeixinApiController.java</h4><pre><code>// 获取 access token 字符串
public void getAccessTokenStr() {
    String accessTokenStr = AccessTokenApi.getAccessTokenStr();
    renderText(accessTokenStr);
}

// 获取 access token
public void getAccessToken() {
    AccessToken accessToken = AccessTokenApi.getAccessToken();
    renderText(accessToken.getAccessToken());
}
</code></pre><h4 id="修改-index-html"><a href="#修改-index-html" class="headerlink" title="修改 index.html"></a>修改 index.html</h4><pre><code>&lt;body&gt;
    &lt;h1&gt;欢迎来到主页&lt;/h1&gt;
    &lt;h3&gt;获取接口调用凭据&lt;/h3&gt;
    点击&lt;a href=&apos;/api/getAccessTokenStr&apos;&gt;【获取 access token 字符串】&lt;/a&gt;&lt;br&gt;
    点击&lt;a href=&apos;/api/getAccessToken&apos;&gt;【获取 access token】&lt;/a&gt;&lt;br&gt;
&lt;/body&gt;
</code></pre><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p>打开主页面    </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-f41c64286c149d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页面"></p>
<p>点击页面链接<br>微信服务器会返回 <code>access_token</code>，如图：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-457cd62b7f248b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信服务器返回的 access_token"></p>
<h4 id="获取微信服务器-IP-地址"><a href="#获取微信服务器-IP-地址" class="headerlink" title="获取微信服务器 IP 地址"></a>获取微信服务器 IP 地址</h4><p>如果公众号基于安全等考虑，需要获知微信服务器的 IP 地址列表，以便进行相关限制。<br>可以通过 <code>CallbackIpApi</code> 接口的 <code>getCallbackIp()</code> 方法获得微信服务器 IP 地址列表。<br>同上，修改 <code>WeixinApiController.java</code> 与 <code>index.html</code> 文件：    </p>
<pre><code>// 获取微信服务器IP地址
public void getCallbackIp() {
    ApiResult apiResult = CallbackIpApi.getCallbackIp();
    renderText(apiResult.toString());
}

// index.html 页面添加链接
点击&lt;a href=&apos;/api/getCallbackIp&apos;&gt;【获取微信服务器 IP 地址】&lt;/a&gt;&lt;br&gt;
</code></pre><p>运行结果：     </p>
<pre><code>// 微信服务器 IP 地址， IP 地址很多，多余结果已略去
{&quot;ip_list&quot;:[&quot;101.226.62.77&quot;,&quot;101.226.62.78&quot;&quot;]}
</code></pre><hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/061ad5a23e1f" target="_blank" rel="external">JFinal Weixin 学习笔记（7）– 微信用户管理</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%87%AD%E6%8D%AE" target="_blank" rel="external">jfinal-weixin-wiki 获取接口调用凭据</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/JFinal Weixin 学习笔记（5）-- 微信页面跳转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/JFinal Weixin 学习笔记（5）-- 微信页面跳转/" itemprop="url">JFinal Weixin 学习笔记（5）-- 微信页面跳转</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-18T16:42:43+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="http://upload-images.jianshu.io/upload_images/5343805-568813dea75afbc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构">  </p>
<h4 id="WeixinApiController"><a href="#WeixinApiController" class="headerlink" title="WeixinApiController"></a>WeixinApiController</h4><p><code>WeixinApiController</code> 继承 <code>ApiController</code> ，所有使用 Api 的 controller 都需要继承此类。<br>目前没有使用 jfinal-weixin 接口，只是简单地跳转到主页。</p>
<pre><code>package com.nancarp.controller;

import com.jfinal.weixin.sdk.api.ApiConfig;
import com.jfinal.weixin.sdk.jfinal.ApiController;
import com.nancarp.utils.WeixinUtil;

public class WeixinApiController extends ApiController {

    /**
     * 如果要支持多公众账号，只需要在此返回各个公众号对应的 ApiConfig 对象即可 可以通过在请求 url 中挂参数来动态从数据库中获取
     * ApiConfig 属性值
     */
    @Override
    public ApiConfig getApiConfig() {
        return WeixinUtil.getApiConfig();
    }

    // 主页
    public void index(){
        render(&quot;index.html&quot;);
    }

}
</code></pre><h4 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h4><p><code>Constants</code> 类保存项目中用到的常量</p>
<pre><code>package com.nancarp.utils;

import com.jfinal.kit.PropKit;

public class Constants {
    // 获取域名
    public static String host = PropKit.get(&quot;host&quot;);

}
</code></pre><h4 id="WeixinConfig-增加路由"><a href="#WeixinConfig-增加路由" class="headerlink" title="WeixinConfig 增加路由"></a>WeixinConfig 增加路由</h4><pre><code>@Override
public void configRoute(Routes me) {
    // HelloWorld 路由
    me.add(&quot;/hello&quot;,HelloWorldController.class);
    // 接收用户消息和发送消息
    me.add(&quot;/msg&quot;, WeixinMsgController.class);
    // 操作微信接口
    me.add(&quot;/api&quot;, WeixinApiController.class,&quot;/api&quot;);
}
</code></pre><h4 id="修改-WeixinMsgController"><a href="#修改-WeixinMsgController" class="headerlink" title="修改 WeixinMsgController"></a>修改 WeixinMsgController</h4><p><code>url</code>  要以 <code>http://</code> 或 <code>https://</code> 开头，否则微信返回的信息只是单纯的文本。</p>
<pre><code>@Override
protected void processInTextMsg(InTextMsg inTextMsg) {
    // 文本内容
    String msgContent = inTextMsg.getContent().trim();
    // 回复主页链接
    if (&quot;1&quot;.equals(msgContent) || &quot;主页&quot;.equals(msgContent)){
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        String url = Constants.host + &quot;/api/index&quot;;
        String urlStr = &quot;&lt;a href=\&quot;&quot;+url+&quot;\&quot;&gt;点击跳转主页&lt;/a&gt;&quot;;
        outMsg.setContent(urlStr);
        render(outMsg);
    } else {
        // 其它文本消息直接返回原值
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        outMsg.setContent(&quot;\t文本消息已成功接收，内容为： &quot; + inTextMsg.getContent());
        render(outMsg);
    }
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;主页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;欢迎来到主页&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>不出意外，将会得到如下结果：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-36366efdc5f74778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回复消息"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-c579c9fbffedc9e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/cfb13d02465f" target="_blank" rel="external">JFinal Weixin 学习笔记（6）– 获取微信接口调用凭据</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.jianshu.com/p/6e8caa616577" target="_blank" rel="external">微信公众号开发之如何实现消息交互</a><br><a href="http://www.jfinal.com/project/2" target="_blank" rel="external">JFinal Weixin 极速开发 SDK</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="NanCarp" />
          <p class="site-author-name" itemprop="name">NanCarp</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NanCarp</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
