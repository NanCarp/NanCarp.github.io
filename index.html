<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="李子园">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="李子园">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="李子园">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>李子园</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李子园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习、生活、感悟</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/在 Node.js 中使用事件、监听器、定时器和回调/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/在 Node.js 中使用事件、监听器、定时器和回调/" itemprop="url">在 Node.js 中使用事件、监听器、定时器和回调</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T21:31:29+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="在-Node-js-中使用事件、监听器、定时器和回调"><a href="#在-Node-js-中使用事件、监听器、定时器和回调" class="headerlink" title="在 Node.js 中使用事件、监听器、定时器和回调"></a>在 Node.js 中使用事件、监听器、定时器和回调</h1><h3 id="4-2-1-实现定时器"><a href="#4-2-1-实现定时器" class="headerlink" title="4.2.1 实现定时器"></a>4.2.1 实现定时器</h3><p><strong>用超时时间来延迟工作</strong><br>超时定时器用于将工作延迟一个特定时间数量。当时间到了时，回调函数执行，而定时器会消失。对于只需要执行一次的工作，<br>应当使用超时时间。<br>创建超时时间定时器使用 Node.js 中内置的 setTimeout(callback, delayMilliSeconds, [args]) 方法。当你调用<br>setTimeout() 时，回调函数在 delayMilliSeconds 到期后执行。例如，下面的语句在 1 秒后执行 myFunc()：<br><code>setTimeout(myFunc, 1000)</code><br>setTimeout() 函数返回定时器对象的 ID，可以在 delayMilliSeconds 到期前任何时候把此 ID 传递给 clearTimeout(timeoutId)<br>来取消超时时间函数。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myTimeout = setTimeout(myFunc,, 100000);</div><div class="line">...</div><div class="line">clearTimeout(myTimeout);</div></pre></td></tr></table></figure></p>
<p>以下代码实现了调用 simpleTimeout() 函数的一系列简单超时时间，它输出自从超时时间被安排后经历的毫秒数。请注意，<br>setTimeout() 的调用次序是无关紧要的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// simple_timer.js 在不同的时间间隔实现了一系列超时时间</div><div class="line">function simpleTimeout(consoleTimer) &#123;</div><div class="line">	console.timeEnd(consoleTimer);</div><div class="line">&#125;</div><div class="line">console.time(&quot;twoSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 2000, &quot;twoSecond&quot;);</div><div class="line">console.time(&quot;oneSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 1000, &quot;oneSecond&quot;);</div><div class="line">console.time(&quot;fiveSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 5000, &quot;fiveSecond&quot;);</div><div class="line">console.time(&quot;50MilliSecond&quot;);</div><div class="line">setTimeout(simpleTimeout, 50, &quot;50MilliSecond&quot;);</div></pre></td></tr></table></figure></p>
<p>下面结果按照其中的延时结束的顺序出现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ node simple_timer.js</div><div class="line">50MilliSecond: 51.578ms</div><div class="line">oneSecond: 999.679ms</div><div class="line">twoSecond: 2001.768ms</div><div class="line">fiveSecond: 5000.161ms</div></pre></td></tr></table></figure></p>
<p><strong>用时间间隔执行定期工作</strong><br>时间间隔定时器用于按定期的延迟时间执行工作。当延时结束时，回调函数被执行，然后再次重新调度为改延迟时间，对于必须<br>定期进行的工作，你应该使用时间间隔。<br>可以通过 Node,js 中内置的 setInterval(callback, delayMilliSeconds, [args]) 方法创建时间间隔计时器。当你调用<br>setInterval() 时，么个 delayMilliSeconds 间隔到后，回调函数执行。例如，下面的语句每秒执行一次  myFunc()：<br><code>setInterval(myFunc, 1000);</code><br>setInterval() 函数返回定时器对象的 ID，你可以在 delayMilliSeconds 到期前把 ID 传递给 clearInterval(intervalId)<br>来取消超时时间函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myInterval = setInterval(myFunc, 1000);</div><div class="line">...</div><div class="line">clearInterval(myInterval);</div></pre></td></tr></table></figure></p>
<p>下面的代码实现了一系列在不同的时间间隔更新变量 x、y 和 z 值得简单时间间隔回调。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// simple_interval.js 在不同的时间间隔实现了一系列的更新回调</div><div class="line">var x=0, y=0, z=0;</div><div class="line">function displayValue() &#123;</div><div class="line">	console.log(&quot;X=%d; Y=%d; Z=%d&quot;, x, y, z);</div><div class="line">&#125;</div><div class="line">function updateX() &#123;</div><div class="line">	x += 1;</div><div class="line">&#125;</div><div class="line">function updateY() &#123;</div><div class="line">	y += 1;</div><div class="line">&#125;</div><div class="line">function updateZ() &#123;</div><div class="line">	z += 1;</div><div class="line">	displayValue();</div><div class="line">&#125;</div><div class="line">setInterval(updateX, 500);</div><div class="line">setInterval(updateY, 1000);</div><div class="line">setInterval(updateZ, 2000);</div></pre></td></tr></table></figure></p>
<p>请注意 x、y 和 z 的值的改变不同，因为该时间间隔量是不同的；x 得递增速度是 y 的两倍，y 的递增速度又是 z 的两倍，<br>输出如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ node simple_interval.js</div><div class="line">X=3; Y=1; Z=1</div><div class="line">X=7; Y=3; Z=2</div><div class="line">X=11; Y=5; Z=3</div><div class="line">X=15; Y=7; Z=4</div><div class="line">X=19; Y=9; Z=5</div><div class="line">X=23; Y=11; Z=6</div><div class="line">X=27; Y=13; Z=7</div><div class="line">X=31; Y=15; Z=8</div><div class="line">X=35; Y=17; Z=9</div><div class="line">X=39; Y=19; Z=10</div><div class="line">X=43; Y=21; Z=11</div><div class="line">X=47; Y=23; Z=12</div></pre></td></tr></table></figure></p>
<p><strong>使用及时计时器立即执行工作</strong><br>即时计时器用来在 I/O 事件的回调函数开始执行后，但任何超时时间或时间间隔事件被执行之前，立刻执行工作。它们允许你<br>把工作调度为在事件队列中的当前事件完成之后执行。你应该使用即时定时器为其他回调产生长期运行的执行段，以防止 I/O<br>事件饥饿。<br>可以使用 Node.js 中内置的 setImmediate(callback, [args]) 方法创建即时计时器。当你调用 setImmediate() 时，<br>回调函数被放置在事件队列中，并在遍历事件队列循环的每次迭代中，在 I/O 有机会被调用后弹出一次。例如，下面的代码调度<br>myFunc() 来在遍历事件队列的下一个周期内执行：<br><code>setimmediate(myFunc(), 1000);</code><br>setImmediate() 函数返回一个定时器对象的 ID，你可以在从事件队列提取出它前的任何时候把 ID 传递给 clearImmediate(<br>immediateId)。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">myImmediate = setImmediate(myFunc);</div><div class="line">...</div><div class="line">clearImmediate(myImmediate);</div></pre></td></tr></table></figure></p>
<p><strong>从事件循环中取消定时器引用</strong><br>当定时器事件回调是留在事件队列中的仅有事件时，通常你不会希望它们继续被调度。setInterval 和 setTimeout 返回的对象<br>中的 unref() 函数，能在这些事件是队列中仅有的事件时，通知事件循环不要继续。<br>例如，下面的代码取消 myInterval 时间间隔定时器引用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myInterval = setInterval(myFunc);</div><div class="line">myInterval.unref();</div></pre></td></tr></table></figure></p>
<p>如果以后由于某种原因，你不想在时间间隔函数是留在队列中的仅有事件时终止程序，就可以使用 ref() 函数来重新引用它：<br><code>myInterval.ref()</code>  </p>
<blockquote>
<p><strong>警告</strong><br>当 unref() 与 setTimeout 定时器结合使用时，要用一个独立的定时器来唤醒时间循环。大量使用这些功能会对你<br>的代码性能产生不利影响，所以应该尽量少地创建它们。  </p>
</blockquote>
<h3 id="4-2-2-使用-nextTick-来调度工作"><a href="#4-2-2-使用-nextTick-来调度工作" class="headerlink" title="4.2.2 使用 nextTick 来调度工作"></a>4.2.2 使用 nextTick 来调度工作</h3><p>在事件队列上调度工作的一个非常有用的方法是使用 process.nextTick(callback) 函数。此函数调度要在事件循环的下一次<br>循环中运行的工作。不像 setImmediate() 方法，nextTick() 在 I/O 事件被触发之前执行。这可能会导致 I/O 事件的饥饿，<br>所以 Node.js 通过默认值为 1000 的 process.maxTickDepth 来限制事件队列的每次循环可执行的 nextTick 事件的数目。<br>下面的代码说明了使用阻塞 I/O 调用、定时器和 nextTick() 时，事件的顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// nexttick.js：实现了一系列阻塞 fs 调用，即时计时器和 nextTick() 调用来显示执行顺序</div><div class="line">var fs = require(&quot;fs&quot;);</div><div class="line">fs.stat(&quot;nexttick.js&quot;, function(err, stats) &#123;</div><div class="line">	if(stats) &#123;</div><div class="line">		console.log(&quot;nexttick.js Exists&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">setImmediate(function() &#123;</div><div class="line">	console.log(&quot;Immediate Timer 1 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">setImmediate(function() &#123;</div><div class="line">	console.log(&quot;Immediate Timer 2 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">process.nextTick(function() &#123;</div><div class="line">	console.log(&quot;Next Tick 1 Executed&quot;);</div><div class="line">&#125;);</div><div class="line">process.nextTick(function() &#123;</div><div class="line">	console.log(&quot;Next Tick 2 Executed&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>输出如下，显示 nextTick() 调用先得到执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node nexttick.js</div><div class="line">Next Tick 1 Executed</div><div class="line">Next Tick 2 Executed</div><div class="line">Immediate Timer 1 Executed</div><div class="line">Immediate Timer 2 Executed</div><div class="line">nexttick.js Exists</div></pre></td></tr></table></figure></p>
<h3 id="4-2-3-实现事件发射器和监听器"><a href="#4-2-3-实现事件发射器和监听器" class="headerlink" title="4.2.3 实现事件发射器和监听器"></a>4.2.3 实现事件发射器和监听器</h3><p>本节重点介绍创建自己的自定义事件，以及实现党一个事件被发出时执行的监听器回调。<br><strong>将自定义事件添加到 JavaSript 对象</strong><br>事件使用一个 EventEmitter 对象来发出。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var events = require(&apos;events&apos;);</div><div class="line">var emitter = new events.EventEmitter();</div><div class="line">emitter.emit(&quot;simpleEvent&apos;);</div></pre></td></tr></table></figure></p>
<p>直接把事件添加到 JavaScript 对象，需要通过在对象实例中调用 events.EventEmitter.call(this) 来在对象中继承<br>EventEmitter 功能，还需要把 events.EventEmitter.prototype 添加到对象的原型中。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function MyObj() &#123;</div><div class="line">    Events.EventEmitter.call(this);</div><div class="line">&#125;</div><div class="line">MyObj.prototype.__proto__ = events.EventEmitter.prototype;</div></pre></td></tr></table></figure></p>
<p>然后，就可以直接从对象实例中触发事件。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myObj = new MyObj();</div><div class="line">myObj.emit(&quot;someEvent&quot;):</div></pre></td></tr></table></figure></p>
<p><strong>把事件监听器添加到对象</strong><br>一旦有了一个会发出事件的对象实例，就可以喂自己所关心的事件添加监听器。可以通过使用下面的功能之一把监听器添加到<br>EventEmitter 对象。  </p>
<ul>
<li><strong>.addListener(eventName, callback)</strong>：将回调函数附加到对象的监听器中。每当 eventName 事件被触发时，<br>回调函数就被放置在事件队列中执行。</li>
<li><strong>.on(eventName, callback)</strong>：同 .addListener()。</li>
<li><strong>.once(eventName, callback)</strong>：只有 eventName 事件第一次被触发时，回调函数才被放置在事件队列中执行。  </li>
</ul>
<p>例如，要在前面定义的 MyObject EventEmitter 类的实例中增加一个监听器，可以使用如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function myCallback() &#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">var myObject = new MyObj();</div><div class="line">myObject.on(&quot;someEvent&quot;, myCallback);</div></pre></td></tr></table></figure></p>
<p><strong>从对象中删除监听器</strong><br>监听器会导致开销，只在必要时使用。Node.js 在 EventEmitter 对象上提供了多个辅助函数来管理监听器。  </p>
<ul>
<li><strong>.listener(eventName)：</strong> 返回一个连接到 eventName 事件的监听器函数的数组。</li>
<li><strong>.setMaxListeners(n)：</strong> 如果多于 n 的监听器都加入到 EventEmitter 对象，就会触发警报。默认值 10。</li>
<li><strong>.removeListener(eventName, callback)：</strong> 将 callback 函数从 EventEmitter 对象的 eventName 事件中删除。  </li>
</ul>
<p><strong>实现事件监听器和发射器事件</strong><br>一下代码演示在 Node.js 实现监听器和自定义事件发射器的过程。Account 对象从 EventEmitter 类继承并提供了两种方法，即<br>deposit（存款）和 withdraw（取款），它们都发射 balanceChanged 事件。然后，3 个回调函数的实现连接到 Account 对象<br>实例的 balanceChanged 事件并显示各种形式的数据。<br>请注意，checkGoal(acc, goal) 回调函数的实现有点不同于其他回调函数。这说明了如何在事件被触发时，将变量传递到该事件<br>监听函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">// emitter_listener.js：创建一个自定义 EventEmitter 对象并实现当</div><div class="line">// balanceChanged 事件被触发时所触发的 3 个监听器</div><div class="line">var events = require(&apos;events&apos;);</div><div class="line">function Account() &#123;</div><div class="line">	this.balance = 0;</div><div class="line">	events.EventEmitter.call(this);</div><div class="line">	this.deposit = function(amount) &#123;</div><div class="line">		this.balance += amount;</div><div class="line">		this.emit(&apos;balanceChanged&apos;);</div><div class="line">	&#125;;</div><div class="line">	this.withdraw = function(amount) &#123;</div><div class="line">		this.balance -= amount;</div><div class="line">		this.emit(&apos;balanceChanged&apos;);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">Account.prototype.__proto__ = events.EventEmitter.prototype;</div><div class="line">function displayBalance()&#123;</div><div class="line">	console.log(&quot;Account balance: $%d&quot;, this.balance);</div><div class="line">&#125;</div><div class="line">function checkOverdraw() &#123;</div><div class="line">	if (this.balance &lt; 0) &#123;</div><div class="line">		console.log(&quot;Account overdrawn!!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function checkGoal(acc, goal) &#123;</div><div class="line">	if (acc.balance &gt; goal) &#123;</div><div class="line">		console.log(&quot;Goal Achieved!!!&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var account = new Account();</div><div class="line">account.on(&quot;balanceChanged&quot;, displayBalance);</div><div class="line">account.on(&quot;balanceChanged&quot;, checkOverdraw);</div><div class="line">account.on(&quot;balanceChanged&quot;, function() &#123;</div><div class="line">	checkGoal(this, 1000);</div><div class="line">&#125;);</div><div class="line">account.deposit(220);</div><div class="line">account.deposit(320);</div><div class="line">account.deposit(600);</div><div class="line">account.withdraw(1200);</div></pre></td></tr></table></figure></p>
<p>emitter_listener.js 的输出，显示了监听器回调函数输出的会计报表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node emitter_listener.js</div><div class="line">Account balance: $220</div><div class="line">Account balance: $540</div><div class="line">Account balance: $1140</div><div class="line">Goal Achieved!!!</div><div class="line">Account balance: $-60</div><div class="line">Account overdrawn!!!</div></pre></td></tr></table></figure></p>
<h2 id="4-3-实现回调"><a href="#4-3-实现回调" class="headerlink" title="4.3 实现回调"></a>4.3 实现回调</h2><h3 id="4-3-1-向回调函数传递额外的参数"><a href="#4-3-1-向回调函数传递额外的参数" class="headerlink" title="4.3.1 向回调函数传递额外的参数"></a>4.3.1 向回调函数传递额外的参数</h3><p>大部分回调函数都有传递给它们的自动参数，如错误或结果缓冲区。使用回调时，常见的一个问题是如何从调用函数给它们传递额外<br>的参数。方法是在一个匿名函数中实现该参数，然后用来自匿名函数的参数调用回调函数。<br>一下代码展示了如何实现回调函数的参数。有两个 sawCar 事件处理程序。请注意，sawCar 仅发出 make 参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// callback_parameter.js 创建一个匿名函数来添加未由事件发出的附加参数</div><div class="line">var events = require(&apos;events&apos;);</div><div class="line">function CarShow() &#123;</div><div class="line">	events.EventEmitter.call(this);</div><div class="line">	this.seeCar = function(make) &#123;</div><div class="line">		this.emit(&apos;sawCar&apos;, make);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">CarShow.prototype.__proto__ = events.EventEmitter.prototype;</div><div class="line">var show = new CarShow();</div><div class="line">function logCar(make) &#123;</div><div class="line">	console.log(&quot;Saw a &quot; + make);</div><div class="line">&#125;</div><div class="line">function logColorCar(make, color) &#123;</div><div class="line">	console.log(&quot;Saw a %s %s&quot;, color, make);</div><div class="line">&#125;</div><div class="line">// 实现了 logCar(make) 回调处理程序</div><div class="line">show.on(&quot;sawCar&quot;, logCar);</div><div class="line">// 事件处理程序调用了一个匿名函数，随机选择的颜色被传递到 logColorCar(make, color) 调用</div><div class="line">show.on(&quot;sawCar&quot;, function(make) &#123;</div><div class="line">	var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;black&apos;];</div><div class="line">	var color = colors[Math.floor(Math.random() * 3)];</div><div class="line">	logColorCar(make, color);</div><div class="line">&#125;);</div><div class="line">show.seeCar(&quot;Ferrari&quot;);</div><div class="line">show.seeCar(&quot;Porsche&quot;);</div><div class="line">show.seeCar(&quot;Bugatti&quot;);</div><div class="line">show.seeCar(&quot;Lamborghini&quot;);</div><div class="line">show.seeCar(&quot;Aston Martin&quot;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ node callback_parameter</div><div class="line">Saw a Ferrari</div><div class="line">Saw a blue Ferrari</div><div class="line">Saw a Porsche</div><div class="line">Saw a blue Porsche</div><div class="line">Saw a Bugatti</div><div class="line">Saw a blue Bugatti</div><div class="line">Saw a Lamborghini</div><div class="line">Saw a red Lamborghini</div><div class="line">Saw a Aston Martin</div><div class="line">Saw a black Aston Martin</div></pre></td></tr></table></figure></p>
<h3 id="4-3-2-在回调中实现闭包"><a href="#4-3-2-在回调中实现闭包" class="headerlink" title="4.3.2 在回调中实现闭包"></a>4.3.2 在回调中实现闭包</h3><p>一个与异步回调的有趣问题是闭包。闭包（Closure） 是一个 JavaScript 的术语，它表示变量被绑定到一个函数的作用域，但<br>不绑定到它的父函数的作用域。当你执行一个异步回调时，父函数的作用域可能更改（例如，通过遍历列表并在每次迭代时改变值）。<br>如果某个函数需要访问父函数的作用域的变量，就需要提供闭包，使这些值在回调函数从事件队列被提取出时可以得到。一个基本<br>方法是在函数块内部封装一个异步调用，并传入所需要的变量。<br>下面代码说明了如何实现为 logCar() 异步函数提供闭包的包装器函数。循环 1 实现了一个基本的回调函数。然而，输出显示中，<br>汽车的名字始终是被读取的最后一个条目，因为每次循环迭代时， message 的值都会变化。<br>循环 2 实现了把消息作为 msg 参数传递的包装器函数，而 msg 值被附着在回调函数上。因此，输出了正确的消息。为了使回调<br>真正异步，使用 process.nextTick() 方法来调度函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// callback_closure.js：创建一个包装器函数来提供异步回调所需的变量的闭包</div><div class="line">function logCar(logMsg, callback) &#123;</div><div class="line">	process.nextTick(function() &#123;</div><div class="line">		callback(logMsg);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">var cars = [&quot;Ferrari&quot;, &quot;Porsche&quot;, &quot;Bugatti&quot;];</div><div class="line">// 循环 1，基本的回调函数</div><div class="line">for (var idx in cars) &#123;</div><div class="line">	var message = &quot;Saw a &quot; + cars[idx];</div><div class="line">	logCar(message, function() &#123;</div><div class="line">		console.log(&quot;Normal Callback: &quot; + message);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">// 循环 2，把消息作为 msg 参数传递的包装器函数函数</div><div class="line">for (var idx in cars) &#123;</div><div class="line">	var message = &quot;Saw a &quot; + cars[idx];</div><div class="line">	(function(msg) &#123;</div><div class="line">		logCar(msg, function() &#123;</div><div class="line">			console.log(&quot;Closure Callback: &quot; + msg);</div><div class="line">		&#125;);</div><div class="line">	&#125;)(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ node callback_closure.js</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Normal Callback: Saw a Bugatti</div><div class="line">Closure Callback: Saw a Ferrari</div><div class="line">Closure Callback: Saw a Porsche</div><div class="line">Closure Callback: Saw a Bugatti</div></pre></td></tr></table></figure></p>
<h3 id="4-3-3-链式回调"><a href="#4-3-3-链式回调" class="headerlink" title="4.3.3 链式回调"></a>4.3.3 链式回调</h3><p>使用异步函数时，如果两个函数都在事件队列上，无法保证它们的运行顺序。最佳方法是让来自异步函数的回调在此调用该函数，<br>直到没有更多的工作要做，以执行链式回调。这样，异步函数永远不会在时间队列上超过一次。<br>以下代码中，条目列表被传递到函数 logCars()，然后异步函数 logCar() 被调用，并且 logCars() 函数作为当 logCar() 完成<br>时的回调函数。一次，同一时间只有一个版本的 logCar() 在事件队列上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// callback_chain.js：实现一个回调链，在此来自一个匿名函数的</div><div class="line">// 回调函数回调到最初的函数来遍历列表</div><div class="line">function logCar(car, callback) &#123;</div><div class="line">	console.log(&quot;Saw a %s&quot;, car);</div><div class="line">	if(cars.length) &#123;</div><div class="line">		process.nextTick(function() &#123;</div><div class="line">			callback();</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">function logCars(cars) &#123;</div><div class="line">	var car = cars.pop();</div><div class="line">	logCar(car, function() &#123;</div><div class="line">		logCars(cars);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line">var cars = [&quot;Ferrari&quot;, &quot;Porsche&quot;, &quot;Bugatti&quot;, &quot;Lamborghini&quot;, &quot;Aston Martin&quot;];</div><div class="line">logCars(cars);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ node callback_chain.js</div><div class="line">Saw a Aston Martin</div><div class="line">Saw a Lamborghini</div><div class="line">Saw a Bugatti</div><div class="line">Saw a Porsche</div><div class="line">Saw a Ferrari</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/27/开始使用 Node.js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/27/开始使用 Node.js/" itemprop="url">开始使用 Node.js</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-27T20:29:15+08:00">
                2017-06-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-开始使用-Node-js"><a href="#3-开始使用-Node-js" class="headerlink" title="3 开始使用 Node.js"></a>3 开始使用 Node.js</h1><h2 id="3-2-Node-js-安装"><a href="#3-2-Node-js-安装" class="headerlink" title="3.2 Node.js 安装"></a>3.2 Node.js 安装</h2><h3 id="3-2-1-纵观-Node-js-安装位置"><a href="#3-2-1-纵观-Node-js-安装位置" class="headerlink" title="3.2.1 纵观 Node.js 安装位置"></a>3.2.1 纵观 Node.js 安装位置</h3><ul>
<li><strong>node：</strong> 该文件启动一个 Node.js JavaScript 引擎。如果你传递一个 JavaScript 文件的位置， Node.js 就执行该脚本。如果没有制定目标 JavaScript 文件，就会出来一个脚本提示符，可以利用它直接从控制台执行 JavaScript 代码。  </li>
<li><strong>npm：</strong> 你可以侍弄此命令来管理 Node.js 包。  </li>
<li><strong>node_modules：</strong> 此文件夹包含安装的Node.js 包。这些包作为扩展 node.js 功能的库。  </li>
</ul>
<h3 id="3-2-2-验证-Node-js-可执行文件"><a href="#3-2-2-验证-Node-js-可执行文件" class="headerlink" title="3.2.2 验证 Node.js 可执行文件"></a>3.2.2 验证 Node.js 可执行文件</h3><p>打开命令提示符，执行以下命令，这将弹出一个 Node.js 虚拟机：<br><code>node</code><br>接下来，执行以下命令，将 “Hello World” 写到屏幕上：<br><code>&gt;console.log(&quot;Hello World&quot;);</code><br>当你看到 “Hello World” 被写入控制台屏幕后，可以按 Ctrl+C 组合键退出控制台。<br>接下来，通过在命令提示符下执行以下命令来验证 npm 命令能正常工作：<br><code>npm version</code><br>你应该看到类似如下的输出：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123; censorify: &apos;0.1.1&apos;,  </div><div class="line">  npm: &apos;3.10.10&apos;,  </div><div class="line">  ares: &apos;1.10.1-DEV&apos;,  </div><div class="line">  http_parser: &apos;2.7.0&apos;,  </div><div class="line">  icu: &apos;58.2&apos;,  </div><div class="line">  modules: &apos;48&apos;,  </div><div class="line">  node: &apos;6.10.3&apos;,  </div><div class="line">  openssl: &apos;1.0.2k&apos;,  </div><div class="line">  uv: &apos;1.9.1&apos;,  </div><div class="line">  v8: &apos;5.1.281.101&apos;,  </div><div class="line">  zlib: &apos;1.2.11&apos; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-2-3-选择-Node-js-IDE"><a href="#3-2-3-选择-Node-js-IDE" class="headerlink" title="3.2.3 选择 Node.js IDE"></a>3.2.3 选择 Node.js IDE</h3><p>暂时用 MarkdwonPad2 ，仍然有些问题。计划用 WebStorm。  </p>
<h2 id="3-3-使用-Node-js-包"><a href="#3-3-使用-Node-js-包" class="headerlink" title="3.3 使用 Node.js 包"></a>3.3 使用 Node.js 包</h2><p>Node.js 框架最强大功能之一是能够轻松地使用 Node 包管理器（Node Packaged Manager，NPM）用额外的 Node 封装模块<br>（NPM）将其扩展。没错：在 Node.js 世界，NPM 意味着两种东西。本文将 Node 封装模块成为模块（Node Package Module，<br>module），而不是 NPM，以避免混乱。  </p>
<h3 id="3-3-1-什么是-Node-封装模块"><a href="#3-3-1-什么是-Node-封装模块" class="headerlink" title="3.3.1 什么是 Node 封装模块"></a>3.3.1 什么是 Node 封装模块</h3><p>Node 封装模块是一个打包的库，它可以很容易地在不同的项目中被共享、重用和安装。  </p>
<h3 id="3-3-2-了解-Node-包注册表"><a href="#3-3-2-了解-Node-包注册表" class="headerlink" title="3.3.2 了解 Node 包注册表"></a>3.3.2 了解 Node 包注册表</h3><p>Node 包注册表位于 <a href="http://npmjs.org。" target="_blank" rel="external">http://npmjs.org。</a>  </p>
<h3 id="3-3-3-使用-Node-包管理器"><a href="#3-3-3-使用-Node-包管理器" class="headerlink" title="3.3.3 使用 Node 包管理器"></a>3.3.3 使用 Node 包管理器</h3><p>Node 包管理器是一个命令行实用程序，它可以让你查找、安装、删除、发布，以及做与 Node 封装模块相关的其他很多东西。<br>Node 包管理器提供了 Node 包的注册表和开发环境之间的联系。  </p>
<h3 id="3-3-4-搜索-Node-封装模块"><a href="#3-3-4-搜索-Node-封装模块" class="headerlink" title="3.3.4 搜索 Node 封装模块"></a>3.3.4 搜索 Node 封装模块</h3><p>你可以直接在命令提示符下使用 npm search <search_string> 命令搜索在 Node 程序包注册表中的模块。  </search_string></p>
<h3 id="3-3-5-安装-Node-封装模块"><a href="#3-3-5-安装-Node-封装模块" class="headerlink" title="3.3.5 安装 Node 封装模块"></a>3.3.5 安装 Node 封装模块</h3><p>在应用程序中使用 Node 模块，它必须先被安装在 Node 可以找到它的地方。要安装 Node 模块，使用 npm install <module_name><br>命令下载 Node 模块到你的开发环境，并将其放置在 node_modules 文件夹中，在哪里运行 install 命令。  </module_name></p>
<h3 id="3-3-6-使用-package-json"><a href="#3-3-6-使用-package-json" class="headerlink" title="3.3.6 使用 package.json"></a>3.3.6 使用 package.json</h3><p>所用 Node 的模块必须在其根目录下包含一个 package.json 文件。package.json 是定义了一个模块，包括其依赖关系的一个<br>简单的JSON 文本文件。改文件可以包含多个不同的指令来告诉 Node 包管理器如何处理模块。<br>下面是一个包含名称、版本、描述和依赖关系的 package.json 文件的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;my_module&quot;,</div><div class="line">    &quot;version&quot;: &quot;0.1.0&quot;,</div><div class="line">    &quot;description&quot;: &quot;a simple node.js module&quot;,</div><div class="line">    &quot;dependencies&quot;: &#123;</div><div class="line">        &quot;express&quot;: &quot;latest&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在 package.json 文件中必须的指令只是名称和版本；其余取决于你想要包含什么。<br>从包的根目录运行下面的命令，express 模块会自动安装：<br><code>npm install</code><br>请注意，npm install 命令没有指定任何模块。这是因为 npm 在默认情况下会蟾照一个 package.json 文件。需要增加额外模块，<br>只要将这些模块添加到依赖指令中，然后再次运行 npm install。  </p>
<h2 id="3-4-创建-Node-js-应用程序"><a href="#3-4-创建-Node-js-应用程序" class="headerlink" title="3.4 创建 Node.js 应用程序"></a>3.4 创建 Node.js 应用程序</h2><p>本节中，将会创建自己的 Node 封装模块，然后把该模块在一个 Node.js 应用程序中作为库来使用。  </p>
<h3 id="3-4-1-创建-Node-js-模块封装"><a href="#3-4-1-创建-Node-js-模块封装" class="headerlink" title="3.4.1 创建 Node.js 模块封装"></a>3.4.1 创建 Node.js 模块封装</h3><p>建立一个 Node.js 封装模块 censorify，该模块接受文本并用星号代替某些特定的单词。  </p>
<ol>
<li>创建名为…/censorify 的项目文件夹。这将是此包的根目录。    </li>
<li>在该文件夹中创建 censortext.js 文件。  </li>
<li>添加以下代码  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var censoredWords = [&quot;sad&quot;, &quot;bad&quot;, &quot;mad&quot;];</div><div class="line">var customCensoredWords = [];</div><div class="line">function censor(inStr) &#123;</div><div class="line">    for (idx in censoredWords) &#123;</div><div class="line">        inStr = inStr.replace(censoredWords[idx], &quot;****&quot;);</div><div class="line">    &#125;</div><div class="line">    for (idx in customCensoredWords) &#123;</div><div class="line">        inStr = inStr.replace(customCensoredWords[idx], &quot;****&quot;);</div><div class="line">    &#125;</div><div class="line">    return inStr;</div><div class="line">&#125;</div><div class="line">function addCensoredWord(word) &#123;</div><div class="line">    customCensoredWords.push(word);</div><div class="line">&#125;</div><div class="line">function getCensoredWords() &#123;</div><div class="line">    return censoredWords.concat(customCensoredWords);</div><div class="line">&#125;</div><div class="line">// 导出函数</div><div class="line">exports.censor = censor;</div><div class="line">exports.addCensoredWord = addCensoredWord;</div><div class="line">exports.getCensoredWords = getCensoredWords;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>导出 censor 是使用这个模块的 Node.js 应用程序能够访问 censor() 函数所需的，对于其他两个函数也是如此。  </p>
<ol>
<li>要生成 Node.js 封装模块，需要 package.json 文件，在 …/censorify 文件夹中创建 package.json<br>文件。添加类似以下代码：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;author&quot;: &quot;Brad Dayley&quot;,</div><div class="line">  &quot;name&quot;: &quot;censorify&quot;,</div><div class="line">  &quot;version&quot;: &quot;0.1.1&quot;,</div><div class="line">  &quot;description&quot;: &quot;Censors words out of text&quot;,</div><div class="line">  &quot;main&quot;: &quot;censortext&quot;,</div><div class="line">  &quot;dependencies&quot;: &#123;&#125;,</div><div class="line">  &quot;engines&quot;: &#123;</div><div class="line">    &quot;node&quot;: &quot;*&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>具体而言，至少需要添加 name（名称）、version（版本）和 main 指令。main 指令需要时被加载的主 JavaScript<br>的模块的名称，本例中是 censortext。注意，.js 不是必需的：Node.js 会自动搜索 .js 扩展名。  </p>
<ol>
<li>在 …/censorify 文件夹中创建 README.md 的文件，填写任意自述说明。  </li>
<li>在控制台导航到 …/censorify 文件夹，执行以下命令来建立本地封装模块：<br><code>npm pack</code><br>npm pack 命令会在…/censorify 文件夹中生成 censorify-0.1.1.tgz 文件。这是你的第一个 Node.js<br>封装模块。   </li>
</ol>
<h3 id="3-4-2-将-Node-js-封装模块发布到-NPM-注册表"><a href="#3-4-2-将-Node-js-封装模块发布到-NPM-注册表" class="headerlink" title="3.4.2 将 Node.js 封装模块发布到 NPM 注册表"></a>3.4.2 将 Node.js 封装模块发布到 NPM 注册表</h3><h3 id="3-4-3-在-Node-js-应用程序中使用-Node-js-封装模块"><a href="#3-4-3-在-Node-js-应用程序中使用-Node-js-封装模块" class="headerlink" title="3.4.3 在 Node.js 应用程序中使用 Node.js 封装模块"></a>3.4.3 在 Node.js 应用程序中使用 Node.js 封装模块</h3><p>很简单，只要将模块安装到你的应用程序的结构中，再用 require() 方法加载该模块。<br>require() 方法接受任何已安装的模块名或位于文件系统上的 .js 文件路径。例如：<br>require(“censorify”)<br>require(“./lib/utils.js”)<br>.js 文件扩展名是可选的。如果它被省略，那么 Node.js 将搜索它。<br>按以下步骤操作：  </p>
<ol>
<li>创建项目文件夹 …/readwords，以此为根目录。    </li>
<li>从根目录的命令提示符下，使用以下命令来安装先前创建的 censorify-0.1.1.tgz 包 censorify 模块：<br><code>npm install ../censorify/censorify-0.1.1.tgz</code>  </li>
<li>或者，如果你已经发布了 censorify 模块，可使用标准命令从 NPM 注册表下载和安装：<br><code>npm install censorify</code>  </li>
<li>确认名为 node_modules 的文件夹，连同 censorify 的子文件夹应被创建。  </li>
<li>创建 …/readwords/readwords.js 文件。  </li>
<li><p>写入以下代码  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// readwords.js：一个显示文本时加载 censorify 模块的 Node.js 应用程序</div><div class="line">var censor = require(&quot;censorify&quot;);</div><div class="line">console.log(censor.getCensoredWords());</div><div class="line">console.log(censor.censor(&quot;Some very sad, bad and mad text&quot;));</div><div class="line">censor.addCensoredWord(&quot;gloomy&quot;);</div><div class="line">console.log(censor.getCensoredWords());</div><div class="line">console.log(censor.censor(&quot;A very gloomy day.&quot;));</div></pre></td></tr></table></figure>
</li>
<li><p>以下命令运行：<br><code>node readwords.js</code><br>输出如下，注意，审查词都被替换为 <em>**</em>，而且新的审查词 gloomy 被加入到 censorify 模块实例 sensor 中。  </p>
<pre><code>$ node readwords.js
[ &apos;sad&apos;, &apos;bad&apos;, &apos;mad&apos; ]
Some very ****, **** and **** text
[ &apos;sad&apos;, &apos;bad&apos;, &apos;mad&apos;, &apos;gloomy&apos; ]
A very **** day.
</code></pre></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/21/项目经理如何对接需求会议总结_20170621/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/21/项目经理如何对接需求会议总结_20170621/" itemprop="url">项目经理如何对接需求会议总结_20170621</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-21T20:44:43+08:00">
                2017-06-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天下午开了关于“项目经理如何对接需求”的会议，受益良多，简单梳理一下。   </p>
<h3 id="1-0-目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？"><a href="#1-0-目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？" class="headerlink" title="1.0 目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？"></a>1.0 目前的“软件”分为哪几种形式，我们能做什么形式的“软件”？</h3><h5 id="（1）无纸化“软件”"><a href="#（1）无纸化“软件”" class="headerlink" title="（1）无纸化“软件”"></a>（1）无纸化“软件”</h5><p>脱离纸张…  </p>
<h5 id="（2）流程化软件"><a href="#（2）流程化软件" class="headerlink" title="（2）流程化软件"></a>（2）流程化软件</h5><p>ERP 系统等… </p>
<h5 id="（3）智能化系统"><a href="#（3）智能化系统" class="headerlink" title="（3）智能化系统"></a>（3）智能化系统</h5><p>根据企业存在问题，提出解决方案…  </p>
<p>主要做前两种，第三种要求较高，是我们努力的目标。</p>
<h3 id="2-0-对于需求，我们分为哪些，同时对应几个阶段？"><a href="#2-0-对于需求，我们分为哪些，同时对应几个阶段？" class="headerlink" title="2.0 对于需求，我们分为哪些，同时对应几个阶段？"></a>2.0 对于需求，我们分为哪些，同时对应几个阶段？</h3><p>需求分为业务需求和开发需求。业务需求是在与客户交流的阶段，通过各种方式挖掘痛点，找出客户真正需要的；<br>开发需求是在开发阶段，根据业务需求制定的关于系统开发方方面面的，细节性的功能的需求。  </p>
<h3 id="3-0-如何挖掘用户的业务需求"><a href="#3-0-如何挖掘用户的业务需求" class="headerlink" title="3.0 如何挖掘用户的业务需求"></a>3.0 如何挖掘用户的业务需求</h3><h4 id="3-1-客户在你面前，你是否存在不知如何入手？"><a href="#3-1-客户在你面前，你是否存在不知如何入手？" class="headerlink" title="3.1 客户在你面前，你是否存在不知如何入手？"></a>3.1 客户在你面前，你是否存在不知如何入手？</h4><p>进行“破冰”，让客户打开话匣子，聊起来，双方不再尴尬，再过渡到深入挖掘客户的需求。 </p>
<p>不知如何入手原因：<br>（1） 知道要讲什么，但性格原因，不善于打交道<br>（2） 擅长打交道，但不知道要讲什么<br>（3） 不知道要什么，不擅长打交道<br>一些解决方案：<br>大声读文章 –》对着镜子背诵，观察面部表情 –》去街上进行调查问卷    </p>
<h4 id="3-2-客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？"><a href="#3-2-客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？" class="headerlink" title="3.2 客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？"></a>3.2 客户总是很“啰嗦”地说自己企业的业务流转情况，你觉得很烦躁，甚至觉得客户“傻逼”？</h4><p>客户可能很啰嗦，说不到重点。我们不能表现出不耐烦，不能让客户看出我们觉得他很“傻逼”，这不仅表现出我们缺乏基本的礼仪，有损个人形象，而且会损害本公司的形象，不利于与客户的进一步交流。我们应当认真倾听，从“啰嗦话”中挖掘客户真实需求。若能力足够，尽可能礼貌地引导客户到正确的方向。   </p>
<h4 id="3-3-你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？"><a href="#3-3-你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？" class="headerlink" title="3.3 你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？"></a>3.3 你是不是觉得客户什么都不懂，只知道说一些不着边际的所谓业务情况？</h4><p>类似于 3.2<br>了解客户所在行业情况，脑海中要有系统的雏形，再与客户进行系统可行性相关的、各种实现细节的论证。  </p>
<h4 id="3-4-你是不是觉得害怕自己提出的东西被否定？"><a href="#3-4-你是不是觉得害怕自己提出的东西被否定？" class="headerlink" title="3.4 你是不是觉得害怕自己提出的东西被否定？"></a>3.4 你是不是觉得害怕自己提出的东西被否定？</h4><p>用于提出自己的意见，有上级领导、公司做你的后盾，但不能过。东西被否定，也是好现象，说明客户知道自己想要什么。对接需求是双向的，相互交流，相互反馈，利于工作进展。  </p>
<h4 id="3-5-你觉得还有什么？"><a href="#3-5-你觉得还有什么？" class="headerlink" title="3.5 你觉得还有什么？"></a>3.5 你觉得还有什么？</h4><h4 id="3-6-你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？"><a href="#3-6-你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？" class="headerlink" title="3.6 你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？"></a>3.6 你能够根据用户的企业情况，通过自己做过的，或者知道的项目情况，有没有在脑子里认为客户可能需要做什么样的东西？</h4><p>这个需要大量项目经验的积累，经验不足的情况下，寻找大量优秀的系统，分析其需求，内化为自身知识。  </p>
<h4 id="业务需求最重要的是什么？"><a href="#业务需求最重要的是什么？" class="headerlink" title="业务需求最重要的是什么？"></a>业务需求最重要的是什么？</h4><p>将实际需求、客户的真实需求融入到系统开发之中。  </p>
<h3 id="4-0-根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？"><a href="#4-0-根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？" class="headerlink" title="4.0 根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？"></a>4.0 根据几种形式的“软件”，我们在对接需求的时候，需要注意什么？</h3><h4 id="4-1-脱离无纸化的“软件”，我们要注意什么？"><a href="#4-1-脱离无纸化的“软件”，我们要注意什么？" class="headerlink" title="4.1 脱离无纸化的“软件”，我们要注意什么？"></a>4.1 脱离无纸化的“软件”，我们要注意什么？</h4><p>比较“简单粗暴”，可能只需要将单据融合到系统中就可以，风险、周期可控。但是要注意：单据格式正确、单据数据齐全，确保单据是我们系统所需要的。  </p>
<h4 id="4-2-有一定业务流程甚至是-ERP-类型的流程性的系统，我们要注意什么？"><a href="#4-2-有一定业务流程甚至是-ERP-类型的流程性的系统，我们要注意什么？" class="headerlink" title="4.2 有一定业务流程甚至是 ERP 类型的流程性的系统，我们要注意什么？"></a>4.2 有一定业务流程甚至是 ERP 类型的流程性的系统，我们要注意什么？</h4><p>尤其注意体量大的、多部门的公司，甚至集团，业务流程极其繁杂。<br>（1）没有专门的负责人，可能需要与很多领导协调，不利于工作进展。建议对方有单一对接人，或者说能拍板的人。<br>（2）需求对接周期很长，对接前请示领导。<br>（3）客户需求变更频繁。对于已经确认的需求，我们最好立马让客户在需求文档或者流程文档上签字，以防以后需求变更导致的种种问题。</p>
<h2 id="关于项目经理如何带项目"><a href="#关于项目经理如何带项目" class="headerlink" title="关于项目经理如何带项目"></a>关于项目经理如何带项目</h2><p>检验控制<br>（1）让所有人理解需求，且能复述出来；<br>（2）看页面，指出存在问题，并要求后面的模块遵循相同要求；<br>（3）看代码，团队统一代码规范，团队成员间互相阅读无障碍；<br>周期控制<br>开发周期 + 测试周期 + 改 bug 周期 </p>
<h2 id="关于项目-A-存在的问题及反思"><a href="#关于项目-A-存在的问题及反思" class="headerlink" title="关于项目 A 存在的问题及反思"></a>关于项目 A 存在的问题及反思</h2><p>（1）病态的合同关系<br>客户甲与公司乙签订合同，项目有公司乙完成；公司乙再与公司丙签订合同，把项目外包给公司丙做。<br>公司乙所理解的需求与客户甲的真实需求有所偏差。公司丙理解的需求与公司乙有所偏差，与客户需求则偏差更大。需求问题是个大坑。  </p>
<p>尽量不做二包，最好能直接与客户交流。</p>
<p>（2）初期没有让客户确认需求<br>仅靠口头约定，客户可能会出尔反尔，或者强加各种额外需求。  </p>
<p>为避免这种情况，对于已经确认的需求，我们最好立马让客户在需求文档或者流程文档上签字。如果有需求变化，增加工作周期，提高项目价格。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/24/JFinal Weixin 学习笔记（9）-- 微信账号二维码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/24/JFinal Weixin 学习笔记（9）-- 微信账号二维码/" itemprop="url">JFinal Weixin 学习笔记（9）-- 微信账号二维码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-24T17:02:43+08:00">
                2017-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h2><hr>
<h4 id="生成带参数的二维码-QrcodeApi"><a href="#生成带参数的二维码-QrcodeApi" class="headerlink" title="生成带参数的二维码 QrcodeApi"></a>生成带参数的二维码 <code>QrcodeApi</code></h4><p>为了满足用户渠道推广分析和用户帐号绑定等场景的需要，公众平台提供了生成带参数二维码的接口。使用该接口可以获得多个带不同场景值的二维码，用户扫描后，公众号可以接收到事件推送。<br>1、临时二维码，是有过期时间的，最长可以设置为在二维码生成后的30天（即2592000秒）后过期，但能够生成较多数量。临时二维码主要用于帐号绑定等不要求二维码永久保存的业务场景  。<br>2、永久二维码，是无过期时间的，但数量较少（目前为最多10万个）。永久二维码主要用于适用于帐号绑定、用户来源统计等场景。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 创建临时二维码</div><div class="line"> * @param expireSeconds 该二维码有效时间，以秒为单位。 最大不超过604800（即7天）。</div><div class="line"> * @param sceneId 场景值ID，临时二维码时为32位非0整型</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createTemporary(int expireSeconds, int sceneId);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建永久二维码</div><div class="line"> * @param sceneId 场景值ID，永久二维码时最大值为100000（目前参数只支持1--100000）</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createPermanent(int sceneId);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建永久二维码</div><div class="line"> * @param sceneStr 场景值ID（字符串形式的ID），字符串类型，长度限制为1到64，仅永久二维码支持此字段</div><div class="line"> * @return ApiResult 二维码信息</div><div class="line"> */</div><div class="line">public static ApiResult createPermanent(String sceneStr);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过ticket换取二维码地址，拼接二维码连接，可直接通过&lt;img&gt;显示</div><div class="line"> * @param ticket 换取二维码参数</div><div class="line"> * @return String url</div><div class="line"> */</div><div class="line">public static String getShowQrcodeUrl(String ticket);</div></pre></td></tr></table></figure>
<h4 id="长链接转短链接接口-ShorturlApi"><a href="#长链接转短链接接口-ShorturlApi" class="headerlink" title="长链接转短链接接口 ShorturlApi"></a>长链接转短链接接口 <code>ShorturlApi</code></h4><p>将一条长链接转成短链接。<br>主要使用场景： 开发者用于生成二维码的原链接（商品、支付二维码等）太长导致扫码速度和成功率下降，将原长链接通过此接口转成短链接再生成二维码将大大提升扫码速度和成功率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 长链接转短链接接口</div><div class="line"> * @param longUrl 需要转换的长链接，支持http://、https://、weixin://wxpay 格式的url</div><div class="line"> * @return ApiResult 短连接信息</div><div class="line"> */</div><div class="line">public static ApiResult getShortUrl(String longUrl);</div></pre></td></tr></table></figure>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><hr>
<h4 id="WeixinApiController-java"><a href="#WeixinApiController-java" class="headerlink" title="WeixinApiController.java"></a>WeixinApiController.java</h4><pre><code>// 生成带参数的二维码
// 创建临时二维码
public void createTemporary(){
    ApiResult apiResult = null;
    // 过期时间
    int expireSeconds = 604800;
    // 场景值
    int sceneId = 111;
    // 生成临时二维码
    apiResult = QrcodeApi.createTemporary(expireSeconds, sceneId);
    // 获取 ticket,拼接 url 
    JSONObject jsonObjec = JSONObject.parseObject(apiResult.getJson());
    String ticket = jsonObjec.getString(&quot;ticket&quot;);
    String outMessage = &quot;apiResult: &quot; + apiResult.getJson() +&quot;\n&quot;
            + &quot;QrcodeUrl: &quot; + QrcodeApi.getShowQrcodeUrl(ticket);
    renderText(outMessage);
}

// 长链接转短链接接口 ShorturlApi
public void getShortUrl(){
    ApiResult apiResult = null;
    String longUrl = &quot;https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQHT7zwAAAAAAAAAAS5odHRwOi8vd2VpeGluLnFxLmNvbS9xLzAyemlhcVFPa0JmUWoxM01GRk5wMW0AAgRw7x9ZAwSAOgkA&quot;;
    apiResult = ShorturlApi.getShortUrl(longUrl);
    JSONObject jsonObjec = JSONObject.parseObject(apiResult.getJson());
    String shorUrl = jsonObjec.getString(&quot;short_url&quot;);
    String outMessage = &quot;apiResult: &quot; + apiResult.getJson() +&quot;\n&quot;
            + &quot;longUrl: &quot; + longUrl + &quot;\n\n&quot;
            + &quot;shorUrl: &quot; + shorUrl;
    renderText(outMessage);
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;h3&gt;微信账号二维码&lt;/h3&gt;
点击&lt;a href=&apos;/api/createTemporary&apos;&gt;【创建临时二维码】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/getShortUrl&apos;&gt;【长链接转短链接】&lt;/a&gt;&lt;br&gt;
</code></pre><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><hr>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9f40e18fe79d47a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试页面">  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9d519c902e908093.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建临时二维码"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-7a07dbca0607d4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="长链接转短链接">  </p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/zyw_java/article/details/54024672" target="_blank" rel="external">微信开发之推广支持</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E5%B8%90%E5%8F%B7%E7%AE%A1%E7%90%86#长链接转短链接接口shorturlapi" target="_blank" rel="external">jfinal-weixin-wiki 帐号管理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/23/JFinal Weixin 学习笔记（8）-- 微信自定义菜单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/JFinal Weixin 学习笔记（8）-- 微信自定义菜单/" itemprop="url">JFinal Weixin 学习笔记（8）-- 微信自定义菜单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-23T11:05:43+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="自定义菜单接口"><a href="#自定义菜单接口" class="headerlink" title="自定义菜单接口"></a>自定义菜单接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 查询菜单</div><div class="line"> */</div><div class="line">MenuApi.getMenu();</div><div class="line"></div><div class="line">/**</div><div class="line"> * 创建菜单</div><div class="line"> */</div><div class="line">MenuApi.createMenu(String jsonStr);</div><div class="line"></div><div class="line">/**</div><div class="line"> * 自定义菜单删除接口</div><div class="line"> */</div><div class="line">MenuApi.deleteMenu();</div></pre></td></tr></table></figure>
<h4 id="WeinxinApiController-java"><a href="#WeinxinApiController-java" class="headerlink" title="WeinxinApiController.java"></a>WeinxinApiController.java</h4><p><code>createMenu(String jsonStr)</code> 接受 json 格式的字符串，我们根据微信技术文档拼接自定义菜单字符串：</p>
<pre><code>/**
 * 创建菜单
 */
public void createMenu() {
    String path = Constants.HOST;
    String jsonstr = &quot;{&quot; +
            &quot;    \&quot;button\&quot;: [&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单1\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单11\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单12\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单13\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单14\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单15\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        },&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单2\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;测　　试\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api/index\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;click\&quot;,\&quot;type\&quot;: \&quot;click\&quot;,\&quot;key\&quot;: \&quot;22\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单23\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;百度\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;http://www.baidu.com\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单25\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        },&quot; +
            &quot;        {&quot; +
            &quot;            \&quot;name\&quot;: \&quot;一级菜单3\&quot;,&quot; +
            &quot;            \&quot;sub_button\&quot;: [&quot;+
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单31\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单32\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单33\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单34\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;},&quot; +
            &quot;                {\&quot;name\&quot;: \&quot;二级菜单35\&quot;,\&quot;type\&quot;: \&quot;view\&quot;,\&quot;url\&quot;: \&quot;&quot; + path + &quot;/api\&quot;}]&quot; +
            &quot;        }&quot; +
            &quot;    ]&quot; +
            &quot;}&quot;;
    ApiResult apiResult = MenuApi.createMenu(jsonstr);
    renderText(apiResult.getJson());
}
</code></pre><p>自定义菜单接口可实现多种类型按钮，详见：<a href="https://mp.weixin.qq.com/wiki" target="_blank" rel="external">微信公众平台技术文档</a>。<br>这里使用了两种：<br>1、<code>click</code>：点击推事件用户点击 click 类型按钮后，微信服务器会通过消息接口推送消息类型为 event 的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的 key 值，开发者可以通过自定义的 key 值与用户进行交互；<br>2、<code>view</code>：跳转 URL 用户点击 view 类型按钮后，微信客户端将会打开开发者在按钮中填写的网页 URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</p>
<p><code>getMenu()</code> 方法，查询自定义菜单：</p>
<pre><code>/**
 * 查询菜单
 */
public void getMenu() {
    ApiResult apiResult = MenuApi.getMenu();
    renderText(apiResult.getJson());
}
</code></pre><h4 id="WeixinMsgController-java"><a href="#WeixinMsgController-java" class="headerlink" title="WeixinMsgController.java"></a>WeixinMsgController.java</h4><p><code>processInMenuEvent(InMenuEvent inMenuEvent)</code>  方法接受菜单中 <code>click</code> 类型按钮的点击事件</p>
<pre><code>// 自定义菜单事件
@Override
protected void processInMenuEvent(InMenuEvent inMenuEvent) {
    OutTextMsg outMsg = new OutTextMsg(inMenuEvent);
    outMsg.setContent(&quot;processInMenuEvent() 方法测试成功&quot;);
    render(outMsg);
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;h3&gt;自定义菜单&lt;/h3&gt;
点击&lt;a href=&apos;/api/createMenu&apos;&gt;【创建自定义菜单】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/getMenu&apos;&gt;【获取自定义菜单】&lt;/a&gt;&lt;br&gt;
</code></pre><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>点击创建菜单，微信客户端不会立马刷新。想立马看到效果，可以取消关注再关注。<br>微信菜单：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-9d135134a26c0b34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一级菜单"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-989b1cdda1ae9bf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="二级菜单"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-9db99bf82a64d269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三级菜单"></p>
<p>点击 <code>click22</code><br><img src="http://upload-images.jianshu.io/upload_images/5343805-1f2158641ce18284.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>新增了“测试”按钮，可以直接跳转主页面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-70dcadb1095aebd1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="测试页面"></p>
<p>点击“获取自定义菜单”<br>得到 json 格式的菜单数据：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-72c4afa586b48cc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="菜单数据"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/2d740d059fa0" target="_blank" rel="external">JFinal Weixin 学习笔记（9）– 微信账号二维码</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/zyw_java/article/details/61415114" target="_blank" rel="external">微信公众号开发之自定义菜单</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E6%8E%A5%E5%8F%A3" target="_blank" rel="external">jfinal-weixin-wiki 自定义菜单接口</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/23/JFinal Weixin 学习笔记（7）-- 微信用户管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/23/JFinal Weixin 学习笔记（7）-- 微信用户管理/" itemprop="url">JFinal Weixin 学习笔记（7）-- 微信用户管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-23T11:04:43+08:00">
                2017-05-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="GroupsApi-接口"><a href="#GroupsApi-接口" class="headerlink" title="GroupsApi 接口"></a>GroupsApi 接口</h4><p>开发者可以使用 <code>GroupsApi</code> 接口，对公众平台的分组进行查询、创建、修改、删除等操作。  </p>
<p>相关方法：<br><code>create(String name)</code> 方法：<br>创建分组，一个公众账号，最多支持创建 100 个分组<br>参数 name： 分组名  </p>
<p><code>get()</code> 方法：<br>查询所有分组  </p>
<p><code>getId(String openid)</code> 方法：<br>通过用户的OpenID查询其所在的 GroupID<br>参数 openid： 普通用户的标识，对当前开发者帐号唯一  </p>
<p><code>update(int id, String name)</code> 方法：<br>修改分组名<br>参数 id：分组 id，由微信分配<br>参数 name： 分组名字（30 个字符以内）  </p>
<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>修改 <code>WeixinApiController.java</code>   </p>
<pre><code>// 获取用户分组列表
public void getGroups () {
    ApiResult apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 创建分组
public void createGroup () {
    Date date = new Date();
    GroupsApi.create(date.toString());
    ApiResult apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 删除分组
public void deleteGroup () {
    ApiResult apiResult = null;
    // 获取当前用户分组列表
    apiResult = GroupsApi.get();
    // 结果转化成 JSONArray 对象
    JSONArray jsonArray = JSON.parseObject(apiResult.toString()).getJSONArray(&quot;groups&quot;);
    // 删除 id &gt;= 100 的用户分组
    for(int i = 0, size = jsonArray.size(); i &lt; size; i++){
        // 转化成 JSONObject 对象
        JSONObject jsonObject = (JSONObject) jsonArray.get(i);
        // 获取分组 id
        int id = jsonObject.getInteger(&quot;id&quot;);
        if (id &gt;= 100){
            // 删除用户分组
            GroupsApi.delete(id);
        }
    }
    // 获取删除后的用户数组
    apiResult = GroupsApi.get();
    renderJson(apiResult.getList(&quot;groups&quot;));
}

// 修改分组名
public void updateGroup(){
    String msg = new String();

    // 更新前
    GroupsApi.create(&quot;原分组名&quot;);
    ApiResult apiResult = GroupsApi.get();
    msg += &quot;更新前： &quot; + apiResult.toString() + &quot;\n&quot;;

    // 结果转化成 JSONArray 对象
    JSONArray jsonArray = JSON.parseObject(apiResult.toString()).getJSONArray(&quot;groups&quot;);
    // 更新用户分组
    for(int i = 0, size = jsonArray.size(); i &lt; size; i++){
        // 转化成 JSONObject 对象
        JSONObject jsonObject = (JSONObject) jsonArray.get(i);
        // 获取分组名
        String origin = jsonObject.getString(&quot;name&quot;);
        if (&quot;原分组名&quot;.equals(origin)){
            // 更新用户分组
            GroupsApi.update(jsonObject.getInteger(&quot;id&quot;), &quot;新分组名&quot;);
            break;
        }
    }

    // 更新后
    msg += &quot;更新后： &quot; + GroupsApi.get().toString() + &quot;\n&quot;;
    renderText(msg);
}
</code></pre><p>修改 <code>index.html</code> </p>
<pre><code>&lt;h3&gt;用户管理&lt;/h3&gt;
点击&lt;a href=&apos;/api/getGroups&apos;&gt;【获取用户分组列表】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/createGroup&apos;&gt;【创建用户分组】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/deleteGroup&apos;&gt;【删除用户分组】&lt;/a&gt;&lt;br&gt;
点击&lt;a href=&apos;/api/updateGroup&apos;&gt;【修改用户分组名】&lt;/a&gt;&lt;br&gt;
</code></pre><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p>主页面：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-250d7a21f6ea6191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页">  </p>
<p>获取用户分组列表：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-8c170d7c51dac536.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取用户分组列表"></p>
<p>创建用户分组：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-1f12e305ac37050f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="创建用户分组"></p>
<p>删除用户分组：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-154a6af55b6672cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除用户分组"></p>
<p>修改用户分组名：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-4156f14aba45b9df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="修改用户分组名"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/0039f943f91d" target="_blank" rel="external">JFinal Weixin 学习笔记（8）– 微信自定义菜单</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86" target="_blank" rel="external">jfinal-weixin-wiki 用户管理</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/20/JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/20/JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据/" itemprop="url">JFinal Weixin 学习笔记（6）-- 获取微信接口调用凭据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-20T09:06:43+08:00">
                2017-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="利用-AccessTokenApi-获取-access-token"><a href="#利用-AccessTokenApi-获取-access-token" class="headerlink" title="利用 AccessTokenApi 获取 access_token"></a>利用 AccessTokenApi 获取 access_token</h4><p><code>access_token</code> 是公众号的全局唯一票据，公众号调用各接口时都需使用 <code>access_token</code>。<br><code>jfinal-wein</code> 提供了 <code>AccessTokenApi</code> 接口，其中:<br><code>getAccessTokenStr()</code> 方法直接获取 <code>access_token</code> 字符串，方便使用；<br><code>getAccessToken()</code> 方法从缓存中获取 <code>access token</code>，如果未取到或者 <code>access token</code> 不可用则先更新再获取。  </p>
<h4 id="修改-WeixinApiController-java"><a href="#修改-WeixinApiController-java" class="headerlink" title="修改 WeixinApiController.java"></a>修改 WeixinApiController.java</h4><pre><code>// 获取 access token 字符串
public void getAccessTokenStr() {
    String accessTokenStr = AccessTokenApi.getAccessTokenStr();
    renderText(accessTokenStr);
}

// 获取 access token
public void getAccessToken() {
    AccessToken accessToken = AccessTokenApi.getAccessToken();
    renderText(accessToken.getAccessToken());
}
</code></pre><h4 id="修改-index-html"><a href="#修改-index-html" class="headerlink" title="修改 index.html"></a>修改 index.html</h4><pre><code>&lt;body&gt;
    &lt;h1&gt;欢迎来到主页&lt;/h1&gt;
    &lt;h3&gt;获取接口调用凭据&lt;/h3&gt;
    点击&lt;a href=&apos;/api/getAccessTokenStr&apos;&gt;【获取 access token 字符串】&lt;/a&gt;&lt;br&gt;
    点击&lt;a href=&apos;/api/getAccessToken&apos;&gt;【获取 access token】&lt;/a&gt;&lt;br&gt;
&lt;/body&gt;
</code></pre><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p>打开主页面    </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-f41c64286c149d93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页面"></p>
<p>点击页面链接<br>微信服务器会返回 <code>access_token</code>，如图：  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-457cd62b7f248b14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信服务器返回的 access_token"></p>
<h4 id="获取微信服务器-IP-地址"><a href="#获取微信服务器-IP-地址" class="headerlink" title="获取微信服务器 IP 地址"></a>获取微信服务器 IP 地址</h4><p>如果公众号基于安全等考虑，需要获知微信服务器的 IP 地址列表，以便进行相关限制。<br>可以通过 <code>CallbackIpApi</code> 接口的 <code>getCallbackIp()</code> 方法获得微信服务器 IP 地址列表。<br>同上，修改 <code>WeixinApiController.java</code> 与 <code>index.html</code> 文件：    </p>
<pre><code>// 获取微信服务器IP地址
public void getCallbackIp() {
    ApiResult apiResult = CallbackIpApi.getCallbackIp();
    renderText(apiResult.toString());
}

// index.html 页面添加链接
点击&lt;a href=&apos;/api/getCallbackIp&apos;&gt;【获取微信服务器 IP 地址】&lt;/a&gt;&lt;br&gt;
</code></pre><p>运行结果：     </p>
<pre><code>// 微信服务器 IP 地址， IP 地址很多，多余结果已略去
{&quot;ip_list&quot;:[&quot;101.226.62.77&quot;,&quot;101.226.62.78&quot;&quot;]}
</code></pre><hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/061ad5a23e1f" target="_blank" rel="external">JFinal Weixin 学习笔记（7）– 微信用户管理</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E5%87%AD%E6%8D%AE" target="_blank" rel="external">jfinal-weixin-wiki 获取接口调用凭据</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/JFinal Weixin 学习笔记（5）-- 微信页面跳转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/JFinal Weixin 学习笔记（5）-- 微信页面跳转/" itemprop="url">JFinal Weixin 学习笔记（5）-- 微信页面跳转</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-18T16:42:43+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="http://upload-images.jianshu.io/upload_images/5343805-568813dea75afbc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构">  </p>
<h4 id="WeixinApiController"><a href="#WeixinApiController" class="headerlink" title="WeixinApiController"></a>WeixinApiController</h4><p><code>WeixinApiController</code> 继承 <code>ApiController</code> ，所有使用 Api 的 controller 都需要继承此类。<br>目前没有使用 jfinal-weixin 接口，只是简单地跳转到主页。</p>
<pre><code>package com.nancarp.controller;

import com.jfinal.weixin.sdk.api.ApiConfig;
import com.jfinal.weixin.sdk.jfinal.ApiController;
import com.nancarp.utils.WeixinUtil;

public class WeixinApiController extends ApiController {

    /**
     * 如果要支持多公众账号，只需要在此返回各个公众号对应的 ApiConfig 对象即可 可以通过在请求 url 中挂参数来动态从数据库中获取
     * ApiConfig 属性值
     */
    @Override
    public ApiConfig getApiConfig() {
        return WeixinUtil.getApiConfig();
    }

    // 主页
    public void index(){
        render(&quot;index.html&quot;);
    }

}
</code></pre><h4 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h4><p><code>Constants</code> 类保存项目中用到的常量</p>
<pre><code>package com.nancarp.utils;

import com.jfinal.kit.PropKit;

public class Constants {
    // 获取域名
    public static String host = PropKit.get(&quot;host&quot;);

}
</code></pre><h4 id="WeixinConfig-增加路由"><a href="#WeixinConfig-增加路由" class="headerlink" title="WeixinConfig 增加路由"></a>WeixinConfig 增加路由</h4><pre><code>@Override
public void configRoute(Routes me) {
    // HelloWorld 路由
    me.add(&quot;/hello&quot;,HelloWorldController.class);
    // 接收用户消息和发送消息
    me.add(&quot;/msg&quot;, WeixinMsgController.class);
    // 操作微信接口
    me.add(&quot;/api&quot;, WeixinApiController.class,&quot;/api&quot;);
}
</code></pre><h4 id="修改-WeixinMsgController"><a href="#修改-WeixinMsgController" class="headerlink" title="修改 WeixinMsgController"></a>修改 WeixinMsgController</h4><p><code>url</code>  要以 <code>http://</code> 或 <code>https://</code> 开头，否则微信返回的信息只是单纯的文本。</p>
<pre><code>@Override
protected void processInTextMsg(InTextMsg inTextMsg) {
    // 文本内容
    String msgContent = inTextMsg.getContent().trim();
    // 回复主页链接
    if (&quot;1&quot;.equals(msgContent) || &quot;主页&quot;.equals(msgContent)){
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        String url = Constants.host + &quot;/api/index&quot;;
        String urlStr = &quot;&lt;a href=\&quot;&quot;+url+&quot;\&quot;&gt;点击跳转主页&lt;/a&gt;&quot;;
        outMsg.setContent(urlStr);
        render(outMsg);
    } else {
        // 其它文本消息直接返回原值
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        outMsg.setContent(&quot;\t文本消息已成功接收，内容为： &quot; + inTextMsg.getContent());
        render(outMsg);
    }
}
</code></pre><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;主页&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;欢迎来到主页&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>不出意外，将会得到如下结果：<br><img src="http://upload-images.jianshu.io/upload_images/5343805-36366efdc5f74778.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回复消息"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-c579c9fbffedc9e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="主页"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/cfb13d02465f" target="_blank" rel="external">JFinal Weixin 学习笔记（6）– 获取微信接口调用凭据</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.jianshu.com/p/6e8caa616577" target="_blank" rel="external">微信公众号开发之如何实现消息交互</a><br><a href="http://www.jfinal.com/project/2" target="_blank" rel="external">JFinal Weixin 极速开发 SDK</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/18/JFinal Weixin 学习笔记（4）-- 实现微信信息交互/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/18/JFinal Weixin 学习笔记（4）-- 实现微信信息交互/" itemprop="url">JFinal Weixin 学习笔记（4）-- 实现微信信息交互</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-18T13:42:43+08:00">
                2017-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="http://upload-images.jianshu.io/upload_images/5343805-cbd15bd39f5857bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="项目结构">    </p>
<h4 id="WeixinMsgController"><a href="#WeixinMsgController" class="headerlink" title="WeixinMsgController"></a>WeixinMsgController</h4><p> <code>WixinMsgController</code>  继承自 <code>MsgControllerAdapter</code>，后者对 <code>MsgController</code> 的部分方法提供了默认实现，以便开发者不去关注 <code>MsgController</code> 中不需要处理的抽象方法，节省代码量。<br><code>getApiConfig()</code> 方法从 <code>a_little_config.txt</code> 文件中读取配置信息。<br><code>processInTextMsg()</code> 方法接受用户在微信中输入的文本信息，并对此作出相关回应。<br>现在我们实现最简单的功能，直接返回用输入的文本信息。  </p>
<pre><code>package com.nancarp.controller;

import com.jfinal.weixin.sdk.api.ApiConfig;
import com.jfinal.weixin.sdk.jfinal.MsgControllerAdapter;
import com.jfinal.weixin.sdk.msg.in.InTextMsg;
import com.jfinal.weixin.sdk.msg.in.event.InFollowEvent;
import com.jfinal.weixin.sdk.msg.in.event.InMenuEvent;
import com.jfinal.weixin.sdk.msg.out.OutTextMsg;
import com.nancarp.utils.WeixinUtil;

public class WeixinMsgController extends MsgControllerAdapter {

    /**
     * 如果要支持多公众账号，只需要在此返回各个公众号对应的 ApiConfig 对象即可 可以通过在请求 url 中挂参数来动态从数据库中获取
     * ApiConfig 属性值
     */
    @Override
    public ApiConfig getApiConfig() {
        return WeixinUtil.getApiConfig();
    }

    /* 
     * 接收文本消息事件
     */
    @Override
    protected void processInTextMsg(InTextMsg inTextMsg) {
        // 其它文本消息直接返回原值
        OutTextMsg outMsg = new OutTextMsg(inTextMsg);
        outMsg.setContent(&quot;\t文本消息已成功接收，内容为： &quot; + inTextMsg.getContent());
        render(outMsg);
    }

    @Override
    protected void processInFollowEvent(InFollowEvent inFollowEvent) {
        // TODO Auto-generated method stub

    }

    @Override
    protected void processInMenuEvent(InMenuEvent inMenuEvent) {
        // TODO Auto-generated method stub

    }

}
</code></pre><h4 id="WeixinUtil"><a href="#WeixinUtil" class="headerlink" title="WeixinUtil"></a>WeixinUtil</h4><p><code>getApiConfig()</code> 方法，获取 <code>token</code>、<code>appId</code>、<code>appSecret</code> 信息。</p>
<pre><code>package com.nancarp.utils;

import com.jfinal.kit.PropKit;
import com.jfinal.weixin.sdk.api.ApiConfig;

/**
 * 
 * 公众平台通用接口工具类
 */
public class WeixinUtil {
    /**
     * 获取配置
     */
    public static ApiConfig getApiConfig() {
        ApiConfig ac = new ApiConfig();

        // 配置微信 API 相关常量
        ac.setToken(PropKit.get(&quot;token&quot;));
        ac.setAppId(PropKit.get(&quot;appId&quot;));
        ac.setAppSecret(PropKit.get(&quot;appSecret&quot;));

        /**
         *  是否对消息进行加密，对应于微信平台的消息加解密方式：
         *  1：true进行加密且必须配置 encodingAesKey
         *  2：false采用明文模式，同时也支持混合模式
         */
        ac.setEncryptMessage(PropKit.getBoolean(&quot;encryptMessage&quot;, false));
        ac.setEncodingAesKey(PropKit.get(&quot;encodingAesKey&quot;, &quot;setting it in config file&quot;));
        return ac;
    }
}
</code></pre><h4 id="a-little-config-txt"><a href="#a-little-config-txt" class="headerlink" title="a_little_config.txt"></a>a_little_config.txt</h4><p><code>token</code>、<code>appId</code>、<code>appSecret</code>  参数要与先前申请的测试号保持一致。<a href="http://www.jianshu.com/p/e47edf0a49bf" target="_blank" rel="external">详见《微信开发前的准备》</a>  </p>
<pre><code># 微信服务器回调所用的 token
token=weixin

# 测试用的账号
appId=wxde758064398fa9bf
appSecret=89622f356fc2bca96ec647d55929afa5
</code></pre><h4 id="WeixinConfig-配置"><a href="#WeixinConfig-配置" class="headerlink" title="WeixinConfig 配置"></a>WeixinConfig 配置</h4><pre><code>@Override
public void configConstant(Constants me) {
    // 加载配置文件
    PropKit.use(&quot;a_little_config.txt&quot;);
    // 读取配置文件，判断是否为开发模式，默认 false
    me.setDevMode(PropKit.getBoolean(&quot;devMode&quot;, false));
    // ApiConfigKit 设为开发模式可以在开发阶段输出请求交互的 xml 与 json 数据
    ApiConfigKit.setDevMode(me.getDevMode());
    // 默认使用的jackson，下面示例是切换到fastJson
    //me.setJsonFactory(new FastJsonFactory());
}

@Override
public void configRoute(Routes me) {
    // HelloWorld 路由
    me.add(&quot;/hello&quot;,HelloWorldController.class);
    // 接收用户消息和发送消息
    me.add(&quot;/msg&quot;, WeixinMsgController.class);
}
</code></pre><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><ol>
<li>启动 Tomcat  </li>
<li>启动 ngrok<br>参考 <a href="http://www.cnblogs.com/zyw-205520/p/4733062.html" target="_blank" rel="external">让微信公众平台通过80端口访问本机</a>  </li>
</ol>
<h4 id="微信客户端的操作"><a href="#微信客户端的操作" class="headerlink" title="微信客户端的操作"></a>微信客户端的操作</h4><p>关注测试账号，输入内容“1”，测试号回复“文本消息已成功接收，内容为： 1”，大功告成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-0ebb11e9f5a49a6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信回复信息"></p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/e7ecdc6a85f3" target="_blank" rel="external">JFinal Weixin 学习笔记（5）– 微信页面跳转</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a>  </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://www.jianshu.com/p/6e8caa616577" target="_blank" rel="external">微信公众号开发之如何实现消息交互</a><br><a href="http://www.jfinal.com/project/2" target="_blank" rel="external">JFinal Weixin 极速开发 SDK</a><br><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/JFinal-weixin%E4%B8%AD%E7%9A%84WeixinConfig%E9%85%8D%E7%BD%AE" target="_blank" rel="external">JFinal weixin中的WeixinConfig配置</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/17/JFinal Weixin 学习笔记（3）-- Eclipse 搭建微信项目框架/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NanCarp">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李子园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/17/JFinal Weixin 学习笔记（3）-- Eclipse 搭建微信项目框架/" itemprop="url">JFinal Weixin 学习笔记（3）-- Eclipse 搭建微信项目框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-17T15:13:43+08:00">
                2017-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="新建-Eclipse-项目"><a href="#新建-Eclipse-项目" class="headerlink" title="新建 Eclipse 项目"></a>新建 Eclipse 项目</h4><p>新建 Dynamic Web Project<br>项目名： jfinal-weixin-nancarp<br>服务器： Tomcat v8.0  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-dbcb971fe77773e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<h4 id="导入-jar-包"><a href="#导入-jar-包" class="headerlink" title="导入 jar 包"></a>导入 jar 包</h4><p>项目必需以下 jar 包，或者更高版本    </p>
<pre><code>// jfinal 核心包
--jfinal-2.2.jar

// jfinal 微信开发 jar 包
--jfinal-weixin-1.8-bin-with-src.jar

// 可选Json处理包，必选其一
--fastjson-1.2.6.jar
//或者
--jackson-databind-2.4.3.jar
----jackson-annotations-2.4.0.jar
----jackson-core-2.4.3.jar
</code></pre><p>所需 jar 包可以在 JFinal 社区下载：<a href="http://www.jfinal.com/" target="_blank" rel="external">http://www.jfinal.com/</a>  </p>
<h4 id="搭建-JFinal-框架"><a href="#搭建-JFinal-框架" class="headerlink" title="搭建 JFinal 框架"></a>搭建 JFinal 框架</h4><p>项目结构  ：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/5343805-a4b5f842c6e7d478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p><strong>WeixinConfig.java：</strong>  </p>
<pre><code>package com.nancarp.config;

import com.jfinal.config.Constants;
import com.jfinal.config.Handlers;
import com.jfinal.config.Interceptors;
import com.jfinal.config.JFinalConfig;
import com.jfinal.config.Plugins;
import com.jfinal.config.Routes;
import com.jfinal.kit.PropKit;
import com.jfinal.template.Engine;
import com.nancarp.controller.HelloWorldController;

public class WeixinConfig extends JFinalConfig{

    @Override
    public void configConstant(Constants me) {
        // 加载配置文件
        PropKit.use(&quot;a_little_config.txt&quot;);
        // 读取配置文件，判断是否为开发模式，默认 false
        me.setDevMode(PropKit.getBoolean(&quot;devMode&quot;, false));
    }

    @Override
    public void configRoute(Routes me) {
        // HelloWorld 路由
        me.add(&quot;/hello&quot;,HelloWorldController.class);
    }

    @Override
    public void configEngine(Engine me) {

    }

    @Override
    public void configPlugin(Plugins me) {

    }

    @Override
    public void configInterceptor(Interceptors me) {

    }

    @Override
    public void configHandler(Handlers me) {

    }

}
</code></pre><p><strong>HelloWorldController.java：</strong>  </p>
<pre><code>package com.nancarp.controller;

import com.jfinal.core.Controller;

public class HelloWorldController extends Controller {
    public void index() {
        renderText(&quot;Hello World!&quot;);
    }
}
</code></pre><p><strong>a_little_config.txt：</strong>  </p>
<pre><code># 数据库相关设置
jdbcUrl=jdbc:mysql://localhost/__数据库名__?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull
user=_数据库账号_
password=_数据库密码_

# 开发模式
devMode = true

# 微信服务器回调所用的 token
token=weixin

# 测试用的账号
appId=wxde758064398fa9bf
appSecret=89622f356fc2bca96ec647d55929afa5
#webAppId=___web appid___
#webAppSecret=_________web appSecret____

#是否对消息进行加密，是否对消息进行加密，对应于微信平台的消息加解密方式，false支持明文模式及兼容模式，true支持安全模式及兼容模式
encryptMessage=false
encodingAesKey=5C8csBd4cG4c9039OKDnNaZmYlkAzXV31piXQFRZKHC

#####业务逻辑中的华丽的分割线#########
#授权域名
domain=http://********.com
subscribe_rul=http://mp.weixin.qq.com/s?__biz=MzA4MDA2OTA0Mg==&amp;mid=208184833&amp;idx=1&amp;sn=d9e615e45902c3c72db6c24b65c4af3e#rd
host=http://*****.com
</code></pre><p><strong>web.xml：</strong>  </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt;
  &lt;filter&gt;
        &lt;filter-name&gt;jfinal&lt;/filter-name&gt;
        &lt;filter-class&gt;com.jfinal.core.JFinalFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;configClass&lt;/param-name&gt;
            &lt;param-value&gt;com.nancarp.config.WeixinConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;

    &lt;filter-mapping&gt;
        &lt;filter-name&gt;jfinal&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;  
</code></pre><h4 id="项目部署到-Tomcat-上"><a href="#项目部署到-Tomcat-上" class="headerlink" title="项目部署到 Tomcat 上"></a>项目部署到 Tomcat 上</h4><p><img src="http://upload-images.jianshu.io/upload_images/5343805-cbee124232eabea5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">  </p>
<p>修改 server.xml 文件    </p>
<pre><code>&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;
// 修改端口号为 80 ，因为微信只支持 80 或 443 端口
&lt;Connector connectionTimeout=&quot;20000&quot; port=&quot;80&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot;/&gt;


&lt;Context docBase=&quot;jfinal-weixin-nancarp&quot; path=&quot;/jfinal-weixin-nancarp&quot; reloadable=&quot;true&quot; source=&quot;org.eclipse.jst.jee.server:jfinal-weixin-nancarp&quot;/&gt;
// path 修改为&quot;/&quot;，这样 url 就不需要带上项目名
&lt;Context docBase=&quot;jfinal-weixin-nancarp&quot; path=&quot;/&quot; reloadable=&quot;true&quot; source=&quot;org.eclipse.jst.jee.server:jfinal-weixin-nancarp&quot;/&gt;
</code></pre><h4 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h4><p>启动 tomcat，在浏览器输入 <a href="http://localhost/hello" target="_blank" rel="external">localhost/hello</a>，回车。<br>看到熟悉的 “Hello World” 就说明框架搭建成功。</p>
<hr>
<p><a href="http://git.oschina.net/NanCarp/jfinal-weixin-nancarp" target="_blank" rel="external">源码地址</a><br><a href="http://www.jianshu.com/p/191abc4da94d" target="_blank" rel="external">JFinal Weixin 学习笔记（4）– 实现微信信息交互</a><br><a href="http://www.jianshu.com/p/0ea20e77cf29" target="_blank" rel="external">JFinal Weixin 学习笔记（1）– 目录</a></p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://git.oschina.net/jfinal/jfinal-weixin/wikis/JFinal-weixin-1.6-Jar%E4%BE%9D%E8%B5%96" target="_blank" rel="external">JFinal-weixin Jar包依赖</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="NanCarp" />
          <p class="site-author-name" itemprop="name">NanCarp</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NanCarp</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
